// Copyright 2024 The tk9.0-go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build none

package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"slices"
	"strings"

	"github.com/adrg/xdg"
	"golang.org/x/net/html"
	util "modernc.org/fileutil/ccgo"
	libtk "modernc.org/libtk9.0"
	ngrab "modernc.org/ngrab/lib"
)

const (
	header = `// Code generated by generator.go, DO NOT EDIT.

package tk9_0 // import "modernc.org/tk9.0"

`
	head = `<html>
<head>
<style>
div {
	margin-left: 50px;
}
p {
    padding : 0;
    margin : 0;
    background-color: #FDFDC9;
}
.comment {
	background-color: lightgray;
}
.TH {
	background-color: #9E9E9E;
}
.SH {
	background-color: #2196F3;
}
.SO .text {
	background-color: #00FFFF;
}
.OP {
	background-color: #FFEB3B;
}
.BS {
	background-color: #F44336;
}
.CS .text {
	background-color: #87CEEB;
}
.DS {
	background-color: #F44336;
}
.RS {
	background-color: #F44336;
}
.sso {
	background-color: #616161;
}
.SS {
	background-color: #8f8;
}
.LP {
	background-color: #8f8;
}
</style>
</head>
<body>
`
	goarch  = runtime.GOARCH
	goos    = runtime.GOOS
	ofn     = "generated.go"
	tempDir = "html"
)

func main() {
	// w := bytes.NewBuffer(nil)
	// w.WriteString(header)
	// if err := os.WriteFile(ofn, w.Bytes(), 0660); err != nil {
	// 	panic(err)
	// }

	nFilesDir := filepath.Join(xdg.ConfigHome, "ccgo", "v4", "libtk9.0", goos, goarch, libtk.Version, "doc")
	fmt.Printf("nFilesDir=%s\n", nFilesDir)
	util.MustShell(true, nil, "sh", "-c", fmt.Sprintf("rm -rf %s", tempDir))
	util.MustShell(true, nil, "mkdir", "-p", tempDir)
	fmt.Printf("tempDir=%s\n", tempDir)
	m, err := filepath.Glob(filepath.Join(nFilesDir, "*.n"))
	if err != nil {
		panic(err)
	}
	slices.Sort(m)
	t, err := ngrab.NewTask(io.Discard, m)
	if err != nil {
		panic(err)
	}

	if err := t.Main(); err != nil {
		panic(err)
	}

	htmlFiles := makeHTML(t)
	j := newJob(htmlFiles)
	j.main()
}

func makeHTML(t *ngrab.Task) (htmlFiles []string) {
	var documentFN string
	var w *bytes.Buffer
	var path []string
	for _, v := range t.Nodes {
		switch v.Type {
		case "document":
			if documentFN != "" {
				base := filepath.Base(documentFN)
				base = base[:len(base)-len(".n")] + ".html"
				w.WriteString("<html>\n")
				ofn := filepath.Join(tempDir, base)
				if err := os.WriteFile(ofn, w.Bytes(), 0660); err != nil {
					panic(err)
				}

				htmlFiles = append(htmlFiles, ofn)
			}
			documentFN = v.Text
			w = bytes.NewBuffer(nil)
			w.WriteString(head)
		case
			"BS",
			"CS",
			"DS",
			"RS",
			"SO":

			path = append(path, v.Type)
			fmt.Fprintf(w, "<div class=%q title=%q>\n", v.Type, strings.Join(path, "/"))
		case
			"BE",
			"CE",
			"DE",
			"RE",
			"SE":

			path = path[:len(path)-1]
			fmt.Fprintf(w, "</div>\n")
		case "so":
			fmt.Fprintf(w, "<p class=%q title=%q>%s</p>", "sso", strings.Join(append(path, "sso"), "/"), html.EscapeString(v.Text))
		default:
			fmt.Fprintf(w, "<p class=%q title=%q>%s</p>\n", v.Type, strings.Join(append(path, v.Type), "/"), html.EscapeString(v.Text))
		}
	}
	if documentFN != "" {
		base := filepath.Base(documentFN)
		base = base[:len(base)-len(".n")] + ".html"
		w.WriteString("<html>\n")
		ofn := filepath.Join(tempDir, base)
		if err := os.WriteFile(ofn, w.Bytes(), 0660); err != nil {
			panic(err)
		}

		htmlFiles = append(htmlFiles, ofn)
	}
	return htmlFiles
}

func walk(lvl int, n *html.Node, visitor func(n *html.Node) (dive bool)) {
	for ; n != nil; n = n.NextSibling {
		if visitor(n) {
			walk(lvl+1, n.FirstChild, visitor)
		}
	}
}

func class(n *html.Node) string {
	for _, v := range n.Attr {
		if v.Key == "class" {
			return v.Val
		}
	}
	return ""
}

type job struct {
	files     []string
	documents []*document
}

func newJob(files []string) *job {
	return &job{files: files}
}

type document struct {
	fn  string
	sh  []*html.Node
	shx map[string]*html.Node
	so  []*html.Node
}

func (j *job) analyze(file string) {
	f, err := os.Open(file)
	if err != nil {
		panic(err)
	}

	defer f.Close()

	n, err := html.Parse(f)
	if err != nil {
		panic(err)
	}

	d := &document{
		fn:  file,
		shx: map[string]*html.Node{},
	}
	j.documents = append(j.documents, d)
	walk(0, n, func(n *html.Node) (dive bool) {
		switch n.Type {
		case html.ElementNode:
			switch n.Data {
			case "p":
				switch class(n) {
				case "SH":
					s := strings.TrimSpace(n.FirstChild.Data)
					if d.shx[s] != nil {
						panic("internal error")
					}

					d.shx[s] = n
					d.sh = append(d.sh, n)
				}
			case "div":
				switch class(n) {
				case "SO":
					d.so = append(d.so, n)
				}
			}
		}
		return true
	})
}

func (j *job) main() {
	for _, v := range j.files {
		j.analyze(v)
	}
	for _, v := range j.documents {
		var a []string
		for k := range v.shx {
			a = append(a, k)
		}
		slices.Sort(a)
		fmt.Printf("%s %v\n", v.fn, a)
	}
}
