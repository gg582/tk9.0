// Copyright 2024 The tk9.0-go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build none

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"slices"
	"strings"

	tklib "modernc.org/libtk9.0/library"
)

const (
	header = `// Code generated by generator.go, DO NOT EDIT.

package tk9_0 // import "modernc.org/tk9.0"

import (
	"fmt"
)

`
)

type document map[string]any

func main() {
	var docs []document
	if err := json.Unmarshal([]byte(tklib.API), &docs); err != nil {
		panic(err)
	}

	generated("generated.go", docs)
}

type optionDocs struct {
	page string
	docs string
}

func generated(fn string, docs []document) {
	w := bytes.NewBuffer(nil)
	w.WriteString(header)
	if err := os.WriteFile(fn, w.Bytes(), 0660); err != nil {
		panic(err)
	}

	var pages []string
	m := map[string]document{}
	for _, v := range docs {
		nm := v["Page"].(string)
		pages = append(pages, nm)
		m[nm] = v
	}
	slices.Sort(pages)

	options := map[string][]*optionDocs{}

	for _, nm0 := range pages {
		doc := m[nm0]
		switch page := doc["Page"].(string); page {
		case "options":
			for _, v := range doc["Options"].([]any) {
				v := v.(map[string]any)
				onms := v["Name"].(string)
				docs := v["Docs"].(string)
				for _, onm := range optionNames(onms) {
					options[onm] = append(options[onm], &optionDocs{"", docs})
				}
			}
		default:
			if opts := doc["Options"]; opts != nil {
				for _, v := range opts.([]any) {
					v := v.(map[string]any)
					onms := v["Name"].(string)
					docs := v["Docs"].(string)
					for _, onm := range optionNames(onms) {
						options[onm] = append(options[onm], &optionDocs{page, docs})
					}
				}
			}
			nm := tclName2GoName(nm0)
			isWindow := false
			if _, isWindow = doc["IsWindow"].(bool); isWindow {
				var description string
				var a []string
				switch x := doc["Options"].(type) {
				case []any:
					for _, v := range x {
						v := v.(map[string]any)
						if len(a) == 0 {
							a = append(a, "")
						}
						s := v["Name"].(string)
						b := strings.Fields(s)
						switch len(b) {
						case 3:
							a = append(a, "", fmt.Sprintf("# %s(%s(...))", nm, export(b[0][1:])), "")
						default:
							onms := optionNames(s)
							var c []string
							for _, onm := range onms {
								c = append(c, fmt.Sprintf("%s(%s(...))", nm, export(onm[1:])))
							}
							a = append(a, "", fmt.Sprintf("# %s", strings.Join(c, " or ")), "")
						}
						a = append(a, strings.Split(v["Docs"].(string), "\n")...)
					}
				}
				switch x := doc["Description"].(type) {
				case []any:
					if len(a) != 0 {
						a = append(a, "", "# Description")
					}
					for _, v := range x {
						if len(a) == 0 {
							a = append(a, "")
						}
						a = append(a, "")
						a = append(a, strings.Split(v.(string), "\n")...)
					}
				}
				description = strings.Join(a, "\n// ")
				fmt.Fprintf(w, "\n\n// %v", doc["Name"])
				fmt.Fprintf(w, "%s", description)
				fmt.Fprintf(w, "\n//\n// The resulting Window is a child of 'w'.")
				pageLink(w, page)
				fmt.Fprintf(w, "\nfunc (w *Window) %s(options ...option) *Window {", nm)
				fmt.Fprintf(w, "\n\treturn w.newChild(%q, options...)", nm0)
				fmt.Fprintf(w, "\n}")

				fmt.Fprintf(w, "\n\n// %v", doc["Name"])
				fmt.Fprintf(w, "%s", description)
				pageLink(w, page)
				fmt.Fprintf(w, "\nfunc %s(options ...option) *Window {", nm)
				fmt.Fprintf(w, "\n\treturn App.%s(options...)", nm)
				fmt.Fprintf(w, "\n}")
				if opts, ok := doc["Options"].([]any); ok {
					for _, v := range opts {
						v := v.(map[string]any)
						onms := v["Name"].(string)
						docs := v["Docs"].(string)
						for _, onm := range optionNames(onms) {
							options[onm] = append(options[onm], &optionDocs{page, docs})
						}
					}
				}
			}

			synops := doc["Synopsis"]
			methods := doc["Methods"]
			switch {
			case synops == nil && methods == nil:
				// nop
			case !isWindow && synops != nil && methods == nil:
				nonWinOnlySynops(w, doc)
			case !isWindow && synops != nil && methods != nil:
				nonWinSynopsAndMethods(w, doc)
			case isWindow && synops != nil && methods != nil:
				winSynopsAndMethods(w, doc)
			case isWindow && synops != nil && methods == nil:
				winOnlySynops(w, doc)
			default:
				fmt.Printf("TODO page=%s isWindow=%v synops=%v methods=%v\n", page, isWindow, synops != nil, methods != nil)
			}
		}
	}
	var onms []string
	for k := range options {
		onms = append(onms, k)
	}
	slices.Sort(onms)
	for _, onm := range onms {
		docsv := options[onm]
		slices.SortFunc(docsv, func(a, b *optionDocs) int { return strings.Compare(a.page, b.page) })
		option(w, onm, docsv)
	}

	moreOptions(w, optionsNeeded)

	if err := os.WriteFile(fn, w.Bytes(), 0660); err != nil {
		panic(err)
	}
}

func optionNames(nm string) (r []string) {
	nm = strings.ReplaceAll(nm, `"`, "")
	r = strings.Fields(nm)
	x := 0
	for i, v := range r {
		if strings.HasPrefix(v, "-") && (i == 0 || r[i-1] == "or") {
			r[x] = v
			x++
		}
	}
	return r[:x]
}

var optionsGenerated = map[string]struct{}{} // Key = Go name.

func option(w io.Writer, nm string, docsv []*optionDocs) {
	nm = strings.ReplaceAll(nm, `"`, "")
	a := optionNames(nm)
	for _, nm := range a {
		if nm == "--" {
			continue
		}

		nm = nm[1:] // remove leading '-'
		if !isCommand[nm] {
			fmt.Fprintf(w, "\n\ntype %sOption struct { v any }", nm)
			fmt.Fprintf(w, "\n\nfunc (o %sOption) optionString(w *Window) string {", nm)
			fmt.Fprintf(w, "\n\treturn fmt.Sprintf(`-%s %%s`, optionString(o.v))", nm)
			fmt.Fprintf(w, "\n}")
		}
		nm2 := nm
		if r := replaceOpt[nm]; r != "" {
			if r == "-" {
				continue
			}

			nm2 = r
		}
		fmt.Fprintf(w, "\n\n")
		if isCommand[nm] {
			fmt.Fprintf(w, "\n// See also [Event handlers]\n//")
		}
		for i, docs := range docsv {
			if docs.page != "" {
				if i != 0 {
					fmt.Fprintf(w, "\n//")
				}
				fmt.Fprintf(w, "\n// # %s(%s(...))\n//", tclName2GoName(docs.page), export(nm2))
			}
			d := strings.Split(strings.TrimSpace(docs.docs), "\n")
			fmt.Fprintf(w, "\n// %s", strings.Join(d, "\n// "))
		}
		enm := export(nm2)
		if _, ok := optionsGenerated[enm]; ok {
			panic(fmt.Sprintf("option %q already generated", enm))
		}

		optionsGenerated[enm] = struct{}{}
		switch {
		case isCommand[nm]:
			fmt.Fprintf(w, "\n//\n// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers")
			fmt.Fprintf(w, "\nfunc %s(args ...any) option {", enm)
			fmt.Fprintf(w, "\n\treturn newEventHandler(%q, args...)", "-"+nm)
			fmt.Fprintf(w, "\n}")
		default:
			fmt.Fprintf(w, "\nfunc %s(value any) option {", enm)
			fmt.Fprintf(w, "\n\treturn %sOption{value}", nm)
			fmt.Fprintf(w, "\n}")
		}
	}
}

var isCommand = map[string]bool{
	"command":         true,
	"invalidcommand":  true,
	"invcmd":          true,
	"postcommand":     true,
	"tearoffcommand":  true,
	"textvariable":    true,
	"validatecommand": true,
	"vcmd":            true,
	"xscrollcommand":  true,
	"yscrollcommand":  true,
}

var replaceOpt = map[string]string{
	"button":  "btn",
	"label":   "lbl",
	"menu":    "mnu",
	"message": "msg",
	"text":    "txt",
	"window":  "-",
}

func tclName2GoName(s string) string {
	switch {
	case strings.HasPrefix(s, "ttk_"):
		return "T" + export(s[len("ttk_"):])
	default:
		return export(s)
	}
}

func export(s string) (r string) {
	a := strings.Split(s, "_")
	for i, v := range a {
		a[i] = strings.ToUpper(v[:1]) + v[1:]
	}
	return strings.Join(a, "")
}

type synTok struct {
	tok string

	variadic bool
}

func (s synTok) String() string {
	return fmt.Sprintf("%s%s", s.tok, vari(s.variadic))
}

func vari(b bool) string {
	if b {
		return "..."
	}

	return ""
}

type synOpt struct {
	opt []string

	variadic bool
}

func (s synOpt) String() string {
	return fmt.Sprintf("%s%s", s.opt, vari(s.variadic))
}

func parseSynopsisLine(line string) (r []any) {
	line = strings.TrimSpace(line)
	if line == "." {
		return nil
	}
	line = strings.ReplaceAll(line, "??", "")
	for {
		line = strings.TrimSpace(line)
		switch {
		case line == "":
			return r
		case line[0] == '?':
			x := strings.IndexByte(line[1:], '?')
			opt := synOpt{opt: strings.Fields(line[1 : x+1])}
			if n := len(opt.opt); opt.opt[n-1] == "..." {
				opt.opt = opt.opt[:n-1]
				opt.variadic = true
			}
			r = append(r, opt)
			line = line[x+2:]
		default:
			x := strings.IndexByte(line, ' ')
			switch {
			case x < 0:
				r = append(r, synTok{tok: line})
				return
			default:
				r = append(r, synTok{tok: line[:x]})
				line = line[x+1:]
			}
		}
	}
}

var nonWinOnlySynopsSkip = map[string]struct{}{
	"bind":     {}, // Manual.
	"bindtags": {}, // Ignored, tkinter does not expose it either.
}

func nonWinOnlySynops(w io.Writer, doc document) {
	page := doc["Page"].(string)
	if _, ok := nonWinOnlySynopsSkip[page]; ok {
		return
	}

	for _, v := range doc["Synopsis"].([]any) {
		syn := parseSynopsisLine(v.(string))
		switch page {
		case "bell":
			command0(w, page, comment(doc["Name"], doc["Description"]), syn[0], winOpt{syn[1]}, syn[2])
		case "destroy":
			command0(w, page, comment(doc["Name"], doc["Description"]), syn[0], wins0Opt{})
		default:
			fmt.Printf("TODO nonWinOnlySynops: page=%s non-win only synops=%v\n", page, syn)
		}
	}
}

func winOnlySynops(w io.Writer, doc document) {
	page := doc["Page"].(string)
	for _, v := range doc["Synopsis"].([]any) {
		syn := parseSynopsisLine(v.(string))
		fmt.Printf("TODO winOnlySynopsManual: page=%s win only synops=%v\n", page, syn)
	}
}

var nonWinSynopsAndMethodsSkip = map[string]struct{}{
	"image": {}, // Manual.
}

func nonWinSynopsAndMethods(w io.Writer, doc document) {
	page := doc["Page"].(string)
	if _, ok := nonWinSynopsAndMethodsSkip[page]; ok {
		return
	}

	for _, v := range doc["Synopsis"].([]any) {
		syn := parseSynopsisLine(v.(string))
		if len(syn) == 0 {
			continue
		}

		switch page {
		case "pack":
			command0(w, page, comment(doc["Name"], doc["Description"].([]any)[:1]), syn[0], wins0Opt{})
		default:
			fmt.Printf("TODO nonWinSynopsAndMethods: page=%s non-win synops=%v\n", page, syn)
		}
	}
	for _, v := range doc["Methods"].([]any) {
		m := v.(map[string]any)
		fmt.Printf("TODO nonWinSynopsAndMethods: page=%s non-win method=%v\n", page, m["Name"])
	}
}

func winSynopsAndMethods(w io.Writer, doc document) {
	page := doc["Page"].(string)
	for _, v := range doc["Synopsis"].([]any) {
		syn := parseSynopsisLine(v.(string))
		fmt.Printf("TODO winSynopsAndMethods: page=%s win synops=%v\n", page, syn)
	}
	for _, v := range doc["Methods"].([]any) {
		m := v.(map[string]any)
		fmt.Printf("TODO winSynopsAndMethods: page=%s win method=%v\n", page, m["Name"])
	}
}

type winOpt struct {
	opt any
}

type wins0Opt struct{}

func comment(descriptionShort, descriptionLong any) string {
	var a []string
	switch x := descriptionShort.(type) {
	case string:
		a = append(a, x)
	default:
		panic(fmt.Sprintf("%T", x))
	}
	switch x := descriptionLong.(type) {
	case []any:
		for _, v := range x {
			a = append(a, "")
			a = append(a, strings.Split(v.(string), "\n")...)
		}
	default:
		panic(fmt.Sprintf("%T", x))
	}
	if len(a) != 0 {
		return "// " + strings.Join(a, "\n// ")
	}

	return ""
}

func params(syns []any) (r []string) {
	opts := false
	for _, v := range syns {
		switch x := v.(type) {
		case winOpt, synOpt, wins0Opt:
			opts = true
		default:
			panic(fmt.Sprintf("%T", x))
		}
	}
	if opts {
		r = append(r, "options ...option")
	}
	return r
}

var optionsNeeded = map[string][]any{} // Key = Go name

func registerOptions(syns []any) {
	for _, v := range syns {
		switch x := v.(type) {
		case winOpt:
			switch y := x.opt.(type) {
			case synOpt:
				enm := export(y.opt[0][1:])
				optionsNeeded[enm] = append(optionsNeeded[enm], x)
			default:
				panic(fmt.Sprintf("%T %v", y, y))
			}
		case wins0Opt:
			// nop
		case synOpt:
			enm := export(x.opt[0][1:])
			optionsNeeded[enm] = append(optionsNeeded[enm], x)
		default:
			panic(fmt.Sprintf("%T %v", x, x))
		}
	}
}

func command0(w io.Writer, page string, comment string, syns ...any) {
	fmt.Fprintf(w, "\n\n%s", comment)
	pageLink(w, page)
	params := params(syns[1:])
	registerOptions(syns[1:])
	fmt.Fprintf(w, "\nfunc %s(%s) {", export(fmt.Sprint(syns[0])), strings.Join(params, ", "))
	fmt.Fprintf(w, "\n\teval(fmt.Sprintf(`%s %%s`, collect(options...)))", syns[0])
	fmt.Fprintf(w, "\n}")
}

func pageLink(w io.Writer, page string) {
	if page == "" {
		return
	}

	fmt.Fprintf(w, "\n//\n// Additional information might be available at the [Tcl/Tk %s] page.", page)
	fmt.Fprintf(w, "\n//\n// [Tcl/Tk %s]: https://www.tcl.tk/man/tcl9.0/TkCmd/%[1]s.html ", page)
}

func moreOptions(w io.Writer, m map[string][]any) {
	var names []string
	for k := range m {
		names = append(names, k)
	}
	slices.Sort(names)
	for _, enm := range names {
		if _, ok := optionsGenerated[enm]; ok {
			continue
		}

		optionsGenerated[enm] = struct{}{}
		syn := m[enm][0]
		switch x := syn.(type) {
		case winOpt:
			switch y := x.opt.(type) {
			case synOpt:
				fmt.Fprintf(w, "\n\nfunc %s(w *Window) option {", enm)
				fmt.Fprintf(w, "\n\treturn stringOption(fmt.Sprintf(`%s %%s`, w.path()))", y.opt[0])
				fmt.Fprintf(w, "\n}")
			default:
				panic(fmt.Sprintf("%T %v", y, y))
			}
		case synOpt:
			switch len(x.opt) {
			case 1: // Boolean option
				fmt.Fprintf(w, "\n\nfunc %s() option {", enm)
				fmt.Fprintf(w, "\n\treturn stringOption(fmt.Sprintf(`%s`))", x.opt[0])
				fmt.Fprintf(w, "\n}")
			default:
				panic(fmt.Sprint(x))
			}
		default:
			// fmt.Fprintf(w, "\n\n//TODO func %s(...) {}", enm)
			panic(fmt.Sprintf("%T %v", x, x))
		}
	}
}
