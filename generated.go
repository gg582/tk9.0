// Code generated by generator.go, DO NOT EDIT.

package tk9_0 // import "modernc.org/tk9.0"

import (
	"fmt"
)

// bell - Ring a display's bell
//
// This command rings the bell on the display for window and
// returns an empty string.
// If the -displayof option is omitted, the display of the
// application's main window is used by default.
// The command uses the current bell-related settings for the display, which
// may be modified with programs such as xset.
//
// If -nice is not specified, this command also resets the screen saver
// for the screen.  Some screen savers will ignore this, but others will reset
// so that the screen becomes visible again.
//
// Additional information might be available at the [Tcl/Tk bell] page.
//
// [Tcl/Tk bell]: https://www.tcl.tk/man/tcl9.0/TkCmd/bell.html
func Bell(options ...option) {
	eval(fmt.Sprintf(`bell %s`, collect(options...)))
}

// button - Create and manipulate 'button' action widgets
//
// # Button(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
//
// # Button(Default(...))
//
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
//
// # Button(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Button(Overrelief(...))
//
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
//
// # Button(State(...))
//
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Button(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The button command creates a new window (given by the
// pathName argument) and makes it into a button widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the button such as its colors, font,
// text, and initial relief.  The button command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A button is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// It can display itself in either of three different ways, according
// to
// the -state option;
// it can be made to appear raised, sunken, or flat;
// and it can be made to flash.  When a user invokes the
// button (by pressing mouse button 1 with the cursor over the
// button), then the Tcl command specified in the -command
// option is invoked.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk button] page.
//
// [Tcl/Tk button]: https://www.tcl.tk/man/tcl9.0/TkCmd/button.html
func (w *Window) Button(options ...option) *Window {
	return w.newChild("button", options...)
}

// button - Create and manipulate 'button' action widgets
//
// # Button(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
//
// # Button(Default(...))
//
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
//
// # Button(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Button(Overrelief(...))
//
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
//
// # Button(State(...))
//
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Button(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The button command creates a new window (given by the
// pathName argument) and makes it into a button widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the button such as its colors, font,
// text, and initial relief.  The button command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A button is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// It can display itself in either of three different ways, according
// to
// the -state option;
// it can be made to appear raised, sunken, or flat;
// and it can be made to flash.  When a user invokes the
// button (by pressing mouse button 1 with the cursor over the
// button), then the Tcl command specified in the -command
// option is invoked.
//
// Additional information might be available at the [Tcl/Tk button] page.
//
// [Tcl/Tk button]: https://www.tcl.tk/man/tcl9.0/TkCmd/button.html
func Button(options ...option) *Window {
	return App.Button(options...)
}

// canvas - Create and manipulate 'canvas' hypergraphics drawing surface widgets
//
// # Canvas(Closeenough(...))
//
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
//
// # Canvas(Confine(...))
//
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
//
// # Canvas(Height(...))
//
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Scrollregion(...))
//
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
//
// # Canvas(State(...))
//
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
//
// # Canvas(Width(...))
//
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Xscrollincrement(...))
//
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
//
// # Canvas(Yscrollincrement(...))
//
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
//
// # Canvas(Channel(...))
//
// Specifies the name of the channel to which to write the Postscript.
// If this option and the -file option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Canvas(Colormap(...))
//
// VarName must be the name of an array variable
// that specifies a color mapping to use in the Postscript.
// Each element of varName must consist of Postscript
// code to set a particular color value (e.g.
//
// # Canvas(Colormode(...))
//
// Specifies how to output color information. Mode must be either
// color (for full color output), gray (convert all colors
// to their gray-scale equivalents) or mono (convert all colors
// to black or white).
//
// # Canvas(File(...))
//
// Specifies the name of the file in which to write the Postscript.
// If this option and the -channel option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Canvas(Fontmap(...))
//
// VarName must be the name of an array variable
// that specifies a font mapping to use in the Postscript.
// Each element of varName must consist of a Tcl list with
// two elements, which are the name and point size of a Postscript font.
// When outputting Postscript commands for a particular font, Tk
// checks to see if varName contains an element with the same
// name as the font.
// If there is such an element, then the font information contained in
// that element is used in the Postscript.
// Otherwise Tk attempts to guess what Postscript font to use.
// Tk's guesses generally only work for well-known fonts such as
// Times and Helvetica and Courier, and only if the X font name does not
// omit any dashes up through the point size.
//
// # Canvas(Height(...))
//
// Specifies the height of the area of the canvas to print.
// Defaults to the height of the canvas window.
//
// # Canvas(Pageanchor(...))
//
// Specifies which point of the printed area of the canvas should appear over
// the positioning point on the page (which is given by the -pagex
// and -pagey options).
//
// # Canvas(Pageheight(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size high on the Postscript page.
// Size consists of a floating-point number followed by
// c for centimeters, i for inches, m for millimeters,
// or p or nothing for printer's points (1/72 inch).
// Defaults to the height of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
//
// # Canvas(Pagewidth(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size wide on the Postscript page.
// Size has the same form as for -pageheight.
// Defaults to the width of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
//
// # Canvas(Pagex(...))
//
// Position gives the x-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagey and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
//
// # Canvas(Pagey(...))
//
// Position gives the y-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagex and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
//
// # Canvas(Rotate(...))
//
// Boolean specifies whether the printed area is to be rotated 90
// degrees.
// In non-rotated output the x-axis of the printed area runs along
// the short dimension of the page
//
// # Canvas(Width(...))
//
// Specifies the width of the area of the canvas to print.
// Defaults to the width of the canvas window.
//
// # Canvas(X(...))
//
// Specifies the x-coordinate of the left edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the left edge of the window.
//
// # Canvas(Y(...))
//
// Specifies the y-coordinate of the top edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the top edge of the window.
//
// # Canvas(Anchor(...))
//
// AnchorPos tells how to position the item relative to the
// positioning point for the item; it may have any of the forms
// accepted by Tk_GetAnchor. For example, if anchorPos
// is center then the item is centered on the point; if
// anchorPos is n then the item will be drawn so that
// its top center point is at the positioning point.
// This option defaults to center.
//
// # Canvas(Dash(...))
//
// # Canvas(Activedash(...))
//
// # Canvas(Disableddash(...))
//
// These options specify dash patterns for the normal, active
// state, and disabled state of an item.
// pattern may have any of the forms accepted by Tk_GetDash.
// If the dash options are omitted then the default is a solid outline.
// See DASH PATTERNS for more information.
//
// # Canvas(Dashoffset(...))
//
// The starting offset in pixels into the pattern provided by the
// -dash option. -dashoffset is ignored if there is no
// -dash pattern. The offset may have any of the forms described
// in the COORDINATES section above.
//
// # Canvas(Fill(...))
//
// # Canvas(Activefill(...))
//
// # Canvas(Disabledfill(...))
//
// These options specify the color to be used to fill item's area.
// in its normal, active, and disabled states.
// The even-odd fill rule is used.
// Color may have any of the forms accepted by Tk_GetColor.
// For the line item, it specifies the color of the line drawn.
// For the text item, it specifies the foreground color of the text.
// If color is an empty string (the default for all canvas items
// except line and text), then the item will not be filled.
//
// # Canvas(Outline(...))
//
// # Canvas(Activeoutline(...))
//
// # Canvas(Disabledoutline(...))
//
// These options specify the color that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Color may have any of the forms accepted by Tk_GetColor.
// If color is specified as an empty string then no outline is drawn
// for the item.
//
// # Canvas(Offset(...))
//
// Specifies the offset of stipples. The offset value can be of the form
// x,y or side, where side can be n, ne, e,
// se, s, sw, w, nw, or center. In the
// first case the origin is the origin of the toplevel of the current window.
// For the canvas itself and canvas objects the origin is the canvas origin,
// but putting # in front of the coordinate pair indicates using the
// toplevel origin instead. For canvas objects, the -offset option is
// used for stippling as well. For the line and polygon canvas items you can
// also specify an index as argument, which connects the stipple origin to one
// of the coordinate points of the line/polygon. Note that stipple offsets are
// only supported on X11; they are silently ignored on other platforms.
//
// # Canvas(Outlinestipple(...))
//
// # Canvas(Activeoutlinestipple(...))
//
// # Canvas(Disabledoutlinestipple(...))
//
// These options specify stipple patterns that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Indicates that the outline for the item should be drawn with a stipple pattern;
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -outline option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then the outline is drawn
// in a solid fashion.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
//
// # Canvas(Outlineoffset(...))
//
// Specifies the offset of the stipple pattern used for outlines, in the same way
// that the -outline option controls fill stipples. (See the
// -outline option for a description of the syntax of offset.)
//
// # Canvas(Stipple(...))
//
// # Canvas(Activestipple(...))
//
// # Canvas(Disabledstipple(...))
//
// These options specify stipple patterns that should be used to fill
// the item in its normal, active and disabled states.
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -fill option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then filling is done
// in a solid fashion.
// For the text item, it affects the actual text.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
//
// # Canvas(State(...))
//
// This allows an item to override the canvas widget's global state
// option. It takes the same values:
// normal, disabled or hidden.
//
// # Canvas(Tags(...))
//
// Specifies a set of tags to apply to the item.
// TagList consists of a list of tag names, which replace any
// existing tags for the item. TagList may be an empty list.
//
// # Canvas(Width(...))
//
// # Canvas(Activewidth(...))
//
// # Canvas(Disabledwidth(...))
//
// These options specify the width of the outline to be drawn around
// the item's region, in its normal, active and disabled states.
// outlineWidth may be in any of the forms described in the
// COORDINATES section above.
// If the -outline option has been specified as an empty string then
// this option has no effect. This option defaults to 1.0.
// For arcs, wide outlines will be drawn centered on the edges of the
// arc's region.
//
// # Canvas(Extent(...))
//
// Specifies the size of the angular range occupied by the arc.
// The arc's range extends for degrees degrees counter-clockwise
// from the starting angle given by the -start option.
// Degrees may be negative.
// If it is greater than 360 or less than -360, then degrees
// modulo 360 is used as the extent.
//
// # Canvas(Start(...))
//
// Specifies the beginning of the angular range occupied by the
// arc.
// Degrees is given in units of degrees measured counter-clockwise
// from the 3-o'clock position; it may be either positive or negative.
//
// # Canvas(Height(...))
//
// Provides a shortcut for creating a circular arc segment by defining the
// distance of the mid-point of the arc from its chord. When this option
// is used the coordinates are interpreted as the start and end coordinates
// of the chord, and the options -start and -extent are ignored.
// The value of distance has the following meaning:
//
// # Canvas(Style(...))
//
// Specifies how to draw the arc. If type is pieslice
// (the default) then the arc's region is defined by a section
// of the oval's perimeter plus two line segments, one between the center
// of the oval and each end of the perimeter section.
// If type is chord then the arc's region is defined
// by a section of the oval's perimeter plus a single line segment
// connecting the two end points of the perimeter section.
// If type is arc then the arc's region consists of
// a section of the perimeter alone.
// In this last case the -fill option is ignored.
//
// # Canvas(Background(...))
//
// # Canvas(Activebackground(...))
//
// # Canvas(Disabledbackground(...))
//
// # Specifies the color to use for each of the bitmap's
//
// # Canvas(Bitmap(...))
//
// # Canvas(Activebitmap(...))
//
// # Canvas(Disabledbitmap(...))
//
// These options specify the bitmaps to display in the item in its normal,
// active and disabled states.
// Bitmap may have any of the forms accepted by Tk_GetBitmap.
//
// # Canvas(Foreground(...))
//
// # Canvas(Activeforeground(...))
//
// # Canvas(Disabledforeground(...))
//
// # These options specify the color to use for each of the bitmap's
//
// # Canvas(Image(...))
//
// # Canvas(Activeimage(...))
//
// # Canvas(Disabledimage(...))
//
// Specifies the name of the images to display in the item in is normal,
// active and disabled states.
// This image must have been created previously with the
// image create command.
//
// # Canvas(Arrow(...))
//
// Indicates whether or not arrowheads are to be drawn at one or both
// ends of the line.
// Where must have one of the values none (for no arrowheads),
// first (for an arrowhead at the first point of the line),
// last (for an arrowhead at the last point of the line), or
// both (for arrowheads at both ends).
// This option defaults to none.
// When requested to draw an arrowhead, Tk internally adjusts the corresponding
// line end point so that the rendered line ends at the neck of the arrowhead
// rather than at its tip so that the line doesn't extend past the edge of the
// arrowhead. This may trigger a Leave event if the mouse is hovering this
// line end. Conversely, when removing an arrowhead Tk adjusts the corresponding
// line point the other way round, which may trigger an Enter event.
//
// # Canvas(Arrowshape(...))
//
// This option indicates how to draw arrowheads.
// The shape argument must be a list with three elements, each
// specifying a distance in any of the forms described in
// the COORDINATES section above.
// The first element of the list gives the distance along the line
// from the neck of the arrowhead to its tip.
// The second element gives the distance along the line from the
// trailing points of the arrowhead to the tip, and the third
// element gives the distance from the outside edge of the line to the
// trailing points.
// If this option is not specified then Tk picks a
//
// # Canvas(Capstyle(...))
//
// Specifies the ways in which caps are to be drawn at the endpoints
// of the line.
// Style may have any of the forms accepted by Tk_GetCapStyle
// (butt, projecting, or round).
// If this option is not specified then it defaults to butt.
// Where arrowheads are drawn the cap style is ignored.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the line.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
// If the line only contains two points then this option is
// irrelevant.
//
// # Canvas(Smooth(...))
//
// smoothMethod must have one of the forms accepted by
// Tcl_GetBoolean or a line smoothing method.
// Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the line
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the line
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is a
// control point and not a knot point, the point is repeated (one or two
// times) so that it also becomes a knot point.
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the outline.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
//
// # Canvas(Smooth(...))
//
// Boolean must have one of the forms accepted by Tcl_GetBoolean
// or a line smoothing method. Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the polygon
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the polygon
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is not the
// second point of a pair of control points, the point is repeated (one or two
// times) so that it also becomes the second point of a pair of control
// points (the associated knot point will be the first control point).
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Angle(...))
//
// RotationDegrees tells how many degrees to rotate the text anticlockwise
// about the positioning point for the text; it may have any floating-point value
// from 0.0 to 360.0. For example, if rotationDegrees is 90, then the
// text will be drawn vertically from bottom to top.
// This option defaults to 0.0.
//
// # Canvas(Font(...))
//
// Specifies the font to use for the text item.
// FontName may be any string acceptable to Tk_GetFont.
// If this option is not specified, it defaults to a system-dependent
// font.
//
// # Canvas(Justify(...))
//
// Specifies how to justify the text within its bounding region.
// How must be one of the values left, right,
// or center.
// This option will only matter if the text is displayed as multiple
// lines.
// If the option is omitted, it defaults to left.
//
// # Canvas(Text(...))
//
// String specifies the characters to be displayed in the text item.
// Newline characters cause line breaks.
// The characters in the item may also be changed with the
// insert and delete widget commands.
// This option defaults to an empty string.
//
// # Canvas(Underline(...))
//
// Specifies the integer index of a character within the text to be
// underlined. 0 corresponds to the first character of the text
// displayed, 1 to the next character, and so on. -1 means that no
// underline should be drawn (if the whole text item is to be underlined,
// the appropriate font should be used instead).
//
// # Canvas(Width(...))
//
// Specifies a maximum line length for the text, in any of the forms
// described in the COORDINATES section above.
// If this option is zero (the default) the text is broken into
// lines only at newline characters.
// However, if this option is non-zero then any line that would
// be longer than lineLength is broken just before a space
// character to make the line shorter than lineLength; the
// space character is treated as if it were a newline
// character.
//
// # Canvas(Height(...))
//
// Specifies the height to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever height it requests internally.
//
// # Canvas(Width(...))
//
// Specifies the width to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever width it requests internally.
//
// # Canvas(Window(...))
//
// Specifies the window to associate with this item.
// The window specified by pathName must either be a child of
// the canvas widget or a child of some ancestor of the canvas widget.
// PathName may not refer to a top-level window.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk canvas] page.
//
// [Tcl/Tk canvas]: https://www.tcl.tk/man/tcl9.0/TkCmd/canvas.html
func (w *Window) Canvas(options ...option) *Window {
	return w.newChild("canvas", options...)
}

// canvas - Create and manipulate 'canvas' hypergraphics drawing surface widgets
//
// # Canvas(Closeenough(...))
//
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
//
// # Canvas(Confine(...))
//
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
//
// # Canvas(Height(...))
//
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Scrollregion(...))
//
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
//
// # Canvas(State(...))
//
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
//
// # Canvas(Width(...))
//
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Xscrollincrement(...))
//
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
//
// # Canvas(Yscrollincrement(...))
//
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
//
// # Canvas(Channel(...))
//
// Specifies the name of the channel to which to write the Postscript.
// If this option and the -file option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Canvas(Colormap(...))
//
// VarName must be the name of an array variable
// that specifies a color mapping to use in the Postscript.
// Each element of varName must consist of Postscript
// code to set a particular color value (e.g.
//
// # Canvas(Colormode(...))
//
// Specifies how to output color information. Mode must be either
// color (for full color output), gray (convert all colors
// to their gray-scale equivalents) or mono (convert all colors
// to black or white).
//
// # Canvas(File(...))
//
// Specifies the name of the file in which to write the Postscript.
// If this option and the -channel option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Canvas(Fontmap(...))
//
// VarName must be the name of an array variable
// that specifies a font mapping to use in the Postscript.
// Each element of varName must consist of a Tcl list with
// two elements, which are the name and point size of a Postscript font.
// When outputting Postscript commands for a particular font, Tk
// checks to see if varName contains an element with the same
// name as the font.
// If there is such an element, then the font information contained in
// that element is used in the Postscript.
// Otherwise Tk attempts to guess what Postscript font to use.
// Tk's guesses generally only work for well-known fonts such as
// Times and Helvetica and Courier, and only if the X font name does not
// omit any dashes up through the point size.
//
// # Canvas(Height(...))
//
// Specifies the height of the area of the canvas to print.
// Defaults to the height of the canvas window.
//
// # Canvas(Pageanchor(...))
//
// Specifies which point of the printed area of the canvas should appear over
// the positioning point on the page (which is given by the -pagex
// and -pagey options).
//
// # Canvas(Pageheight(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size high on the Postscript page.
// Size consists of a floating-point number followed by
// c for centimeters, i for inches, m for millimeters,
// or p or nothing for printer's points (1/72 inch).
// Defaults to the height of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
//
// # Canvas(Pagewidth(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size wide on the Postscript page.
// Size has the same form as for -pageheight.
// Defaults to the width of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
//
// # Canvas(Pagex(...))
//
// Position gives the x-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagey and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
//
// # Canvas(Pagey(...))
//
// Position gives the y-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagex and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
//
// # Canvas(Rotate(...))
//
// Boolean specifies whether the printed area is to be rotated 90
// degrees.
// In non-rotated output the x-axis of the printed area runs along
// the short dimension of the page
//
// # Canvas(Width(...))
//
// Specifies the width of the area of the canvas to print.
// Defaults to the width of the canvas window.
//
// # Canvas(X(...))
//
// Specifies the x-coordinate of the left edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the left edge of the window.
//
// # Canvas(Y(...))
//
// Specifies the y-coordinate of the top edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the top edge of the window.
//
// # Canvas(Anchor(...))
//
// AnchorPos tells how to position the item relative to the
// positioning point for the item; it may have any of the forms
// accepted by Tk_GetAnchor. For example, if anchorPos
// is center then the item is centered on the point; if
// anchorPos is n then the item will be drawn so that
// its top center point is at the positioning point.
// This option defaults to center.
//
// # Canvas(Dash(...))
//
// # Canvas(Activedash(...))
//
// # Canvas(Disableddash(...))
//
// These options specify dash patterns for the normal, active
// state, and disabled state of an item.
// pattern may have any of the forms accepted by Tk_GetDash.
// If the dash options are omitted then the default is a solid outline.
// See DASH PATTERNS for more information.
//
// # Canvas(Dashoffset(...))
//
// The starting offset in pixels into the pattern provided by the
// -dash option. -dashoffset is ignored if there is no
// -dash pattern. The offset may have any of the forms described
// in the COORDINATES section above.
//
// # Canvas(Fill(...))
//
// # Canvas(Activefill(...))
//
// # Canvas(Disabledfill(...))
//
// These options specify the color to be used to fill item's area.
// in its normal, active, and disabled states.
// The even-odd fill rule is used.
// Color may have any of the forms accepted by Tk_GetColor.
// For the line item, it specifies the color of the line drawn.
// For the text item, it specifies the foreground color of the text.
// If color is an empty string (the default for all canvas items
// except line and text), then the item will not be filled.
//
// # Canvas(Outline(...))
//
// # Canvas(Activeoutline(...))
//
// # Canvas(Disabledoutline(...))
//
// These options specify the color that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Color may have any of the forms accepted by Tk_GetColor.
// If color is specified as an empty string then no outline is drawn
// for the item.
//
// # Canvas(Offset(...))
//
// Specifies the offset of stipples. The offset value can be of the form
// x,y or side, where side can be n, ne, e,
// se, s, sw, w, nw, or center. In the
// first case the origin is the origin of the toplevel of the current window.
// For the canvas itself and canvas objects the origin is the canvas origin,
// but putting # in front of the coordinate pair indicates using the
// toplevel origin instead. For canvas objects, the -offset option is
// used for stippling as well. For the line and polygon canvas items you can
// also specify an index as argument, which connects the stipple origin to one
// of the coordinate points of the line/polygon. Note that stipple offsets are
// only supported on X11; they are silently ignored on other platforms.
//
// # Canvas(Outlinestipple(...))
//
// # Canvas(Activeoutlinestipple(...))
//
// # Canvas(Disabledoutlinestipple(...))
//
// These options specify stipple patterns that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Indicates that the outline for the item should be drawn with a stipple pattern;
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -outline option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then the outline is drawn
// in a solid fashion.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
//
// # Canvas(Outlineoffset(...))
//
// Specifies the offset of the stipple pattern used for outlines, in the same way
// that the -outline option controls fill stipples. (See the
// -outline option for a description of the syntax of offset.)
//
// # Canvas(Stipple(...))
//
// # Canvas(Activestipple(...))
//
// # Canvas(Disabledstipple(...))
//
// These options specify stipple patterns that should be used to fill
// the item in its normal, active and disabled states.
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -fill option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then filling is done
// in a solid fashion.
// For the text item, it affects the actual text.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
//
// # Canvas(State(...))
//
// This allows an item to override the canvas widget's global state
// option. It takes the same values:
// normal, disabled or hidden.
//
// # Canvas(Tags(...))
//
// Specifies a set of tags to apply to the item.
// TagList consists of a list of tag names, which replace any
// existing tags for the item. TagList may be an empty list.
//
// # Canvas(Width(...))
//
// # Canvas(Activewidth(...))
//
// # Canvas(Disabledwidth(...))
//
// These options specify the width of the outline to be drawn around
// the item's region, in its normal, active and disabled states.
// outlineWidth may be in any of the forms described in the
// COORDINATES section above.
// If the -outline option has been specified as an empty string then
// this option has no effect. This option defaults to 1.0.
// For arcs, wide outlines will be drawn centered on the edges of the
// arc's region.
//
// # Canvas(Extent(...))
//
// Specifies the size of the angular range occupied by the arc.
// The arc's range extends for degrees degrees counter-clockwise
// from the starting angle given by the -start option.
// Degrees may be negative.
// If it is greater than 360 or less than -360, then degrees
// modulo 360 is used as the extent.
//
// # Canvas(Start(...))
//
// Specifies the beginning of the angular range occupied by the
// arc.
// Degrees is given in units of degrees measured counter-clockwise
// from the 3-o'clock position; it may be either positive or negative.
//
// # Canvas(Height(...))
//
// Provides a shortcut for creating a circular arc segment by defining the
// distance of the mid-point of the arc from its chord. When this option
// is used the coordinates are interpreted as the start and end coordinates
// of the chord, and the options -start and -extent are ignored.
// The value of distance has the following meaning:
//
// # Canvas(Style(...))
//
// Specifies how to draw the arc. If type is pieslice
// (the default) then the arc's region is defined by a section
// of the oval's perimeter plus two line segments, one between the center
// of the oval and each end of the perimeter section.
// If type is chord then the arc's region is defined
// by a section of the oval's perimeter plus a single line segment
// connecting the two end points of the perimeter section.
// If type is arc then the arc's region consists of
// a section of the perimeter alone.
// In this last case the -fill option is ignored.
//
// # Canvas(Background(...))
//
// # Canvas(Activebackground(...))
//
// # Canvas(Disabledbackground(...))
//
// # Specifies the color to use for each of the bitmap's
//
// # Canvas(Bitmap(...))
//
// # Canvas(Activebitmap(...))
//
// # Canvas(Disabledbitmap(...))
//
// These options specify the bitmaps to display in the item in its normal,
// active and disabled states.
// Bitmap may have any of the forms accepted by Tk_GetBitmap.
//
// # Canvas(Foreground(...))
//
// # Canvas(Activeforeground(...))
//
// # Canvas(Disabledforeground(...))
//
// # These options specify the color to use for each of the bitmap's
//
// # Canvas(Image(...))
//
// # Canvas(Activeimage(...))
//
// # Canvas(Disabledimage(...))
//
// Specifies the name of the images to display in the item in is normal,
// active and disabled states.
// This image must have been created previously with the
// image create command.
//
// # Canvas(Arrow(...))
//
// Indicates whether or not arrowheads are to be drawn at one or both
// ends of the line.
// Where must have one of the values none (for no arrowheads),
// first (for an arrowhead at the first point of the line),
// last (for an arrowhead at the last point of the line), or
// both (for arrowheads at both ends).
// This option defaults to none.
// When requested to draw an arrowhead, Tk internally adjusts the corresponding
// line end point so that the rendered line ends at the neck of the arrowhead
// rather than at its tip so that the line doesn't extend past the edge of the
// arrowhead. This may trigger a Leave event if the mouse is hovering this
// line end. Conversely, when removing an arrowhead Tk adjusts the corresponding
// line point the other way round, which may trigger an Enter event.
//
// # Canvas(Arrowshape(...))
//
// This option indicates how to draw arrowheads.
// The shape argument must be a list with three elements, each
// specifying a distance in any of the forms described in
// the COORDINATES section above.
// The first element of the list gives the distance along the line
// from the neck of the arrowhead to its tip.
// The second element gives the distance along the line from the
// trailing points of the arrowhead to the tip, and the third
// element gives the distance from the outside edge of the line to the
// trailing points.
// If this option is not specified then Tk picks a
//
// # Canvas(Capstyle(...))
//
// Specifies the ways in which caps are to be drawn at the endpoints
// of the line.
// Style may have any of the forms accepted by Tk_GetCapStyle
// (butt, projecting, or round).
// If this option is not specified then it defaults to butt.
// Where arrowheads are drawn the cap style is ignored.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the line.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
// If the line only contains two points then this option is
// irrelevant.
//
// # Canvas(Smooth(...))
//
// smoothMethod must have one of the forms accepted by
// Tcl_GetBoolean or a line smoothing method.
// Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the line
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the line
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is a
// control point and not a knot point, the point is repeated (one or two
// times) so that it also becomes a knot point.
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the outline.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
//
// # Canvas(Smooth(...))
//
// Boolean must have one of the forms accepted by Tcl_GetBoolean
// or a line smoothing method. Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the polygon
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the polygon
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is not the
// second point of a pair of control points, the point is repeated (one or two
// times) so that it also becomes the second point of a pair of control
// points (the associated knot point will be the first control point).
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Angle(...))
//
// RotationDegrees tells how many degrees to rotate the text anticlockwise
// about the positioning point for the text; it may have any floating-point value
// from 0.0 to 360.0. For example, if rotationDegrees is 90, then the
// text will be drawn vertically from bottom to top.
// This option defaults to 0.0.
//
// # Canvas(Font(...))
//
// Specifies the font to use for the text item.
// FontName may be any string acceptable to Tk_GetFont.
// If this option is not specified, it defaults to a system-dependent
// font.
//
// # Canvas(Justify(...))
//
// Specifies how to justify the text within its bounding region.
// How must be one of the values left, right,
// or center.
// This option will only matter if the text is displayed as multiple
// lines.
// If the option is omitted, it defaults to left.
//
// # Canvas(Text(...))
//
// String specifies the characters to be displayed in the text item.
// Newline characters cause line breaks.
// The characters in the item may also be changed with the
// insert and delete widget commands.
// This option defaults to an empty string.
//
// # Canvas(Underline(...))
//
// Specifies the integer index of a character within the text to be
// underlined. 0 corresponds to the first character of the text
// displayed, 1 to the next character, and so on. -1 means that no
// underline should be drawn (if the whole text item is to be underlined,
// the appropriate font should be used instead).
//
// # Canvas(Width(...))
//
// Specifies a maximum line length for the text, in any of the forms
// described in the COORDINATES section above.
// If this option is zero (the default) the text is broken into
// lines only at newline characters.
// However, if this option is non-zero then any line that would
// be longer than lineLength is broken just before a space
// character to make the line shorter than lineLength; the
// space character is treated as if it were a newline
// character.
//
// # Canvas(Height(...))
//
// Specifies the height to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever height it requests internally.
//
// # Canvas(Width(...))
//
// Specifies the width to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever width it requests internally.
//
// # Canvas(Window(...))
//
// Specifies the window to associate with this item.
// The window specified by pathName must either be a child of
// the canvas widget or a child of some ancestor of the canvas widget.
// PathName may not refer to a top-level window.
//
// Additional information might be available at the [Tcl/Tk canvas] page.
//
// [Tcl/Tk canvas]: https://www.tcl.tk/man/tcl9.0/TkCmd/canvas.html
func Canvas(options ...option) *Window {
	return App.Canvas(options...)
}

// checkbutton - Create and manipulate 'checkbutton' boolean selection widgets
//
// # Checkbutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Checkbutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Checkbutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Checkbutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Checkbutton(Offvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
//
// # Checkbutton(Onvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
//
// # Checkbutton(Overrelief(...))
//
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
//
// # Checkbutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Checkbutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Checkbutton(State(...))
//
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
//
// # Checkbutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Checkbutton(Tristatevalue(...))
//
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Checkbutton(Variable(...))
//
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
//
// # Checkbutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The checkbutton command creates a new window (given by the
// pathName argument) and makes it into a checkbutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the checkbutton such as its colors, font,
// text, and initial relief.  The checkbutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A checkbutton is a widget
// that displays a textual string, bitmap or image
// and a square called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// A checkbutton has
// all of the behavior of a simple button, including the
// following: it can display itself in either of three different
// ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// checkbutton.
//
// In addition, checkbuttons can be selected.
// If a checkbutton is selected then the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the checkbutton is set to a particular
// value (normally 1).
// The indicator is drawn with a check mark inside.
// If the checkbutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a check mark inside.  In the special case
// where the variable (if specified) has a value that matches the tristatevalue,
// the indicator is drawn with a tri-state appearance and is in the tri-state
// mode indicating mixed or multiple values.  (This is used when the check
// box represents the state of multiple items.)
// The indicator is drawn in a platform dependent manner.  Under Unix and
// Windows, the background interior of the box is
//
// Under Mac, the indicator is drawn with a dash mark inside.
// By default, the name of the variable associated with a checkbutton is the
// same as the name used to create the checkbutton.
// The variable name, and the
//
// and
//
// values stored in it, may be modified with options on the command line
// or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a checkbutton is configured to select and deselect
// itself on alternate button clicks.
// In addition, each checkbutton monitors its associated variable and
// automatically selects and deselects itself when the variables value
// changes to and from the button's
//
// and
//
// values.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk checkbutton] page.
//
// [Tcl/Tk checkbutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/checkbutton.html
func (w *Window) Checkbutton(options ...option) *Window {
	return w.newChild("checkbutton", options...)
}

// checkbutton - Create and manipulate 'checkbutton' boolean selection widgets
//
// # Checkbutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Checkbutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Checkbutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Checkbutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Checkbutton(Offvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
//
// # Checkbutton(Onvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
//
// # Checkbutton(Overrelief(...))
//
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
//
// # Checkbutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Checkbutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Checkbutton(State(...))
//
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
//
// # Checkbutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Checkbutton(Tristatevalue(...))
//
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Checkbutton(Variable(...))
//
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
//
// # Checkbutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The checkbutton command creates a new window (given by the
// pathName argument) and makes it into a checkbutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the checkbutton such as its colors, font,
// text, and initial relief.  The checkbutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A checkbutton is a widget
// that displays a textual string, bitmap or image
// and a square called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// A checkbutton has
// all of the behavior of a simple button, including the
// following: it can display itself in either of three different
// ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// checkbutton.
//
// In addition, checkbuttons can be selected.
// If a checkbutton is selected then the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the checkbutton is set to a particular
// value (normally 1).
// The indicator is drawn with a check mark inside.
// If the checkbutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a check mark inside.  In the special case
// where the variable (if specified) has a value that matches the tristatevalue,
// the indicator is drawn with a tri-state appearance and is in the tri-state
// mode indicating mixed or multiple values.  (This is used when the check
// box represents the state of multiple items.)
// The indicator is drawn in a platform dependent manner.  Under Unix and
// Windows, the background interior of the box is
//
// Under Mac, the indicator is drawn with a dash mark inside.
// By default, the name of the variable associated with a checkbutton is the
// same as the name used to create the checkbutton.
// The variable name, and the
//
// and
//
// values stored in it, may be modified with options on the command line
// or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a checkbutton is configured to select and deselect
// itself on alternate button clicks.
// In addition, each checkbutton monitors its associated variable and
// automatically selects and deselects itself when the variables value
// changes to and from the button's
//
// and
//
// values.
//
// Additional information might be available at the [Tcl/Tk checkbutton] page.
//
// [Tcl/Tk checkbutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/checkbutton.html
func Checkbutton(options ...option) *Window {
	return App.Checkbutton(options...)
}

// destroy - Destroy one or more windows
//
// This command deletes the windows given by the
// window arguments, plus all of their descendants.
// If a window
//
// is deleted then all windows will be destroyed and the application will
// (normally) exit.
// The windows are destroyed in order, and if an error occurs
// in destroying a window the command aborts without destroying the
// remaining windows.
// No error is returned if window does not exist.
//
// Additional information might be available at the [Tcl/Tk destroy] page.
//
// [Tcl/Tk destroy]: https://www.tcl.tk/man/tcl9.0/TkCmd/destroy.html
func Destroy(options ...option) {
	eval(fmt.Sprintf(`destroy %s`, collect(options...)))
}

// entry - Create and manipulate 'entry' one-line text entry widgets
//
// # Entry(Disabledbackground(...))
//
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Entry(Disabledforeground(...))
//
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Entry(Invalidcommand(...)) or Entry(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Entry(Readonlybackground(...))
//
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Entry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # Entry(State(...))
//
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Entry(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Entry(Validatecommand(...)) or Entry(Vcmd(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Entry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Description
//
// The entry command creates a new window (given by the
// pathName argument) and makes it into an entry widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the entry such as its colors, font,
// and relief.  The entry command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// An entry is a widget that displays a one-line text string and
// allows that string to be edited using widget commands described below, which
// are typically bound to keystrokes and mouse actions.
// When first created, an entry's string is empty.
// A portion of the entry may be selected as described below.
// If an entry is exporting its selection (see the -exportselection
// option), then it will observe the standard X11 protocols for handling the
// selection;  entry selections are available as type STRING.
// Entries also observe the standard Tk rules for dealing with the
// input focus.  When an entry has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
//
// Entries are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed;  commands described below
// may be used to change the view in the window.  Entries use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk entry] page.
//
// [Tcl/Tk entry]: https://www.tcl.tk/man/tcl9.0/TkCmd/entry.html
func (w *Window) Entry(options ...option) *Window {
	return w.newChild("entry", options...)
}

// entry - Create and manipulate 'entry' one-line text entry widgets
//
// # Entry(Disabledbackground(...))
//
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Entry(Disabledforeground(...))
//
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Entry(Invalidcommand(...)) or Entry(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Entry(Readonlybackground(...))
//
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Entry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # Entry(State(...))
//
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Entry(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Entry(Validatecommand(...)) or Entry(Vcmd(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Entry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Description
//
// The entry command creates a new window (given by the
// pathName argument) and makes it into an entry widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the entry such as its colors, font,
// and relief.  The entry command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// An entry is a widget that displays a one-line text string and
// allows that string to be edited using widget commands described below, which
// are typically bound to keystrokes and mouse actions.
// When first created, an entry's string is empty.
// A portion of the entry may be selected as described below.
// If an entry is exporting its selection (see the -exportselection
// option), then it will observe the standard X11 protocols for handling the
// selection;  entry selections are available as type STRING.
// Entries also observe the standard Tk rules for dealing with the
// input focus.  When an entry has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
//
// Entries are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed;  commands described below
// may be used to change the view in the window.  Entries use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
//
// Additional information might be available at the [Tcl/Tk entry] page.
//
// [Tcl/Tk entry]: https://www.tcl.tk/man/tcl9.0/TkCmd/entry.html
func Entry(options ...option) *Window {
	return App.Entry(options...)
}

// frame - Create and manipulate 'frame' simple container widgets
//
// # Frame(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Frame(Backgroundimage(...))
//
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
//
// # Frame(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Frame(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Frame(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
//
// # Frame(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
//
// # Frame(Tile(...))
//
//	"8.7, TIP262"
//
// # Frame(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Frame(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
//
// # Description
//
// The frame command creates a new window (given by the
// pathName argument) and makes it into a frame widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the frame such as its background color
// and relief.  The frame command returns the
// path name of the new window.
//
// A frame is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  The only features
// of a frame are its background and an optional 3-D border to make the
// frame appear raised or sunken.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk frame] page.
//
// [Tcl/Tk frame]: https://www.tcl.tk/man/tcl9.0/TkCmd/frame.html
func (w *Window) Frame(options ...option) *Window {
	return w.newChild("frame", options...)
}

// frame - Create and manipulate 'frame' simple container widgets
//
// # Frame(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Frame(Backgroundimage(...))
//
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
//
// # Frame(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Frame(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Frame(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
//
// # Frame(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
//
// # Frame(Tile(...))
//
//	"8.7, TIP262"
//
// # Frame(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Frame(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
//
// # Description
//
// The frame command creates a new window (given by the
// pathName argument) and makes it into a frame widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the frame such as its background color
// and relief.  The frame command returns the
// path name of the new window.
//
// A frame is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  The only features
// of a frame are its background and an optional 3-D border to make the
// frame appear raised or sunken.
//
// Additional information might be available at the [Tcl/Tk frame] page.
//
// [Tcl/Tk frame]: https://www.tcl.tk/man/tcl9.0/TkCmd/frame.html
func Frame(options ...option) *Window {
	return App.Frame(options...)
}

// label - Create and manipulate 'label' non-interactive text or image widgets
//
// # Label(Height(...))
//
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Label(State(...))
//
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
//
// # Label(Width(...))
//
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The label command creates a new window (given by the
// pathName argument) and makes it into a label widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the label such as its colors, font,
// text, and initial relief.  The label command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A label is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// The label can be manipulated in a few simple ways, such as
// changing its relief or text, using the commands described below.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk label] page.
//
// [Tcl/Tk label]: https://www.tcl.tk/man/tcl9.0/TkCmd/label.html
func (w *Window) Label(options ...option) *Window {
	return w.newChild("label", options...)
}

// label - Create and manipulate 'label' non-interactive text or image widgets
//
// # Label(Height(...))
//
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Label(State(...))
//
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
//
// # Label(Width(...))
//
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The label command creates a new window (given by the
// pathName argument) and makes it into a label widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the label such as its colors, font,
// text, and initial relief.  The label command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A label is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// The label can be manipulated in a few simple ways, such as
// changing its relief or text, using the commands described below.
//
// Additional information might be available at the [Tcl/Tk label] page.
//
// [Tcl/Tk label]: https://www.tcl.tk/man/tcl9.0/TkCmd/label.html
func Label(options ...option) *Window {
	return App.Label(options...)
}

// labelframe - Create and manipulate 'labelframe' labelled container widgets
//
// # Labelframe(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Labelframe(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Labelframe(Labelanchor(...))
//
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
//
// # Labelframe(Labelwidget(...))
//
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
//
// # Labelframe(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Labelframe(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Description
//
// The labelframe command creates a new window (given by the
// pathName argument) and makes it into a labelframe widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the labelframe such as its background color
// and relief.  The labelframe command returns the
// path name of the new window.
//
// A labelframe is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  It has the features
// of a frame plus the ability to display a label.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk labelframe] page.
//
// [Tcl/Tk labelframe]: https://www.tcl.tk/man/tcl9.0/TkCmd/labelframe.html
func (w *Window) Labelframe(options ...option) *Window {
	return w.newChild("labelframe", options...)
}

// labelframe - Create and manipulate 'labelframe' labelled container widgets
//
// # Labelframe(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Labelframe(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Labelframe(Labelanchor(...))
//
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
//
// # Labelframe(Labelwidget(...))
//
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
//
// # Labelframe(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Labelframe(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Description
//
// The labelframe command creates a new window (given by the
// pathName argument) and makes it into a labelframe widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the labelframe such as its background color
// and relief.  The labelframe command returns the
// path name of the new window.
//
// A labelframe is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  It has the features
// of a frame plus the ability to display a label.
//
// Additional information might be available at the [Tcl/Tk labelframe] page.
//
// [Tcl/Tk labelframe]: https://www.tcl.tk/man/tcl9.0/TkCmd/labelframe.html
func Labelframe(options ...option) *Window {
	return App.Labelframe(options...)
}

// listbox - Create and manipulate 'listbox' item list widgets
//
// # Listbox(Activestyle(...))
//
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
//
// # Listbox(Height(...))
//
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
//
// # Listbox(Listvariable(...))
//
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
//
// # Listbox(Selectmode(...))
//
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
//
// # Listbox(State(...))
//
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
//
// # Listbox(Width(...))
//
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
//
// # Listbox(Background(...))
//
// Color specifies the background color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Listbox(Foreground(...))
//
// Color specifies the foreground color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Listbox(Selectbackground(...))
//
// color specifies the background color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Listbox(Selectforeground(...))
//
// color specifies the foreground color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Description
//
// The listbox command creates a new window (given by the
// pathName argument) and makes it into a listbox widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the listbox such as its colors, font,
// text, and relief.  The listbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A listbox is a widget that displays a list of strings, one per line.
// When first created, a new listbox has no elements.
// Elements may be added or deleted using widget commands described
// below.  In addition, one or more elements may be selected as described
// below.
// If a listbox is exporting its selection (see -exportselection
// option), then it will observe the standard X11 protocols
// for handling the selection.
// Listbox selections are available as type STRING;
// the value of the selection will be the text of the selected elements, with
// newlines separating the elements.
//
// It is not necessary for all the elements to be
// displayed in the listbox window at once;  commands described below
// may be used to change the view in the window.  Listboxes allow
// scrolling in both directions using the standard -xscrollcommand
// and -yscrollcommand options.
// They also support scanning, as described below.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk listbox] page.
//
// [Tcl/Tk listbox]: https://www.tcl.tk/man/tcl9.0/TkCmd/listbox.html
func (w *Window) Listbox(options ...option) *Window {
	return w.newChild("listbox", options...)
}

// listbox - Create and manipulate 'listbox' item list widgets
//
// # Listbox(Activestyle(...))
//
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
//
// # Listbox(Height(...))
//
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
//
// # Listbox(Listvariable(...))
//
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
//
// # Listbox(Selectmode(...))
//
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
//
// # Listbox(State(...))
//
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
//
// # Listbox(Width(...))
//
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
//
// # Listbox(Background(...))
//
// Color specifies the background color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Listbox(Foreground(...))
//
// Color specifies the foreground color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Listbox(Selectbackground(...))
//
// color specifies the background color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Listbox(Selectforeground(...))
//
// color specifies the foreground color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Description
//
// The listbox command creates a new window (given by the
// pathName argument) and makes it into a listbox widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the listbox such as its colors, font,
// text, and relief.  The listbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A listbox is a widget that displays a list of strings, one per line.
// When first created, a new listbox has no elements.
// Elements may be added or deleted using widget commands described
// below.  In addition, one or more elements may be selected as described
// below.
// If a listbox is exporting its selection (see -exportselection
// option), then it will observe the standard X11 protocols
// for handling the selection.
// Listbox selections are available as type STRING;
// the value of the selection will be the text of the selected elements, with
// newlines separating the elements.
//
// It is not necessary for all the elements to be
// displayed in the listbox window at once;  commands described below
// may be used to change the view in the window.  Listboxes allow
// scrolling in both directions using the standard -xscrollcommand
// and -yscrollcommand options.
// They also support scanning, as described below.
//
// Additional information might be available at the [Tcl/Tk listbox] page.
//
// [Tcl/Tk listbox]: https://www.tcl.tk/man/tcl9.0/TkCmd/listbox.html
func Listbox(options ...option) *Window {
	return App.Listbox(options...)
}

// menu, tk_menuSetFocus - Create and manipulate 'menu' widgets and menubars
//
// # Menu(Postcommand(...))
//
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
//
// # Menu(Selectcolor(...))
//
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
//
// # Menu(Tearoff(...))
//
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
//
// # Menu(Tearoffcommand(...))
//
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
//
// # Menu(Title(...))
//
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
//
// # Menu(Type(...))
//
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
//
// # Menu(Activebackground(...))
//
// Specifies a background color to use for displaying this entry when it
// is active. This option is ignored on Aqua/MacOS.
// If it is specified as an empty string (the default), then the
// -activebackground option for the overall menu is used.
// If the tk_strictMotif variable has been set to request strict
// Motif compliance, then this option is ignored and the -background
// option is used in its place.
// This option is not available for separator or tear-off entries.
//
// # Menu(Activeforeground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is active.   This option is ignored on Aqua/macOS.
// If this option is specified as an empty string (the default), then the
// -activeforeground option for the overall menu is used.
//
// # Menu(Accelerator(...))
//
// Specifies a string to display at the right side of the menu entry.
// Normally describes an accelerator keystroke sequence that may be
// used to invoke the same function as the menu entry. This is a display
// option, it does not actually set the corresponding binding (which can
// be achieved using the bind command). This option is not available
// for separator or tear-off entries.
//
// # Menu(Background(...))
//
// Specifies a background color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -background option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Bitmap(...))
//
// Specifies a bitmap to display in the menu instead of a textual
// label, in any of the forms accepted by Tk_GetBitmap.
// This option overrides the -label option
// (as controlled by the -compound option)
// but may be reset
// to an empty string to enable a textual label to be displayed.
// If a -image option has been specified, it overrides
// -bitmap.
// This option is not available for separator or tear-off entries.
//
// # Menu(Columnbreak(...))
//
// When this option is zero, the entry appears below the previous entry. When
// this option is one, the entry appears at the top of a new column in the
// menu.
// This option is ignored on Aqua/macOS, where menus are always a single
// column.
//
// # Menu(Command(...))
//
// Specifies a Tcl command to execute when the menu entry is invoked.
// Not available for separator or tear-off entries.
//
// # Menu(Compound(...))
//
// Specifies whether the menu entry should display both an image and text,
// and if so, where the image should be placed relative to the text.
// Valid values for this option are bottom, center,
// left, none, right and top.  The default value
// is none, meaning that the button will display either an image or
// text, depending on the values of the -image and -bitmap
// options.
//
// # Menu(Font(...))
//
// Specifies the font to use when drawing the label or accelerator
// string in this entry.
// If this option is specified as an empty string (the default) then
// the -font option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Foreground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -foreground option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Hidemargin(...))
//
// Specifies whether the standard margins should be drawn for this menu
// entry. This is useful when creating palette with images in them, i.e.,
// color palettes, pattern palettes, etc. 1 indicates that the margin for
// the entry is hidden; 0 means that the margin is used.
//
// # Menu(Image(...))
//
// Specifies an image to display in the menu instead of a text string
// or bitmap.
// The image must have been created by some previous invocation of
// image create.
// This option overrides the -label and -bitmap options
// (as controlled by the -compound option)
// but may be reset to an empty string to enable a textual or
// bitmap label to be displayed.
// This option is not available for separator or tear-off entries.
//
// # Menu(Indicatoron(...))
//
// Available only for checkbutton and radiobutton entries.
// Value is a boolean that determines whether or not the
// indicator should be displayed.
//
// # Menu(Label(...))
//
// Specifies a string to display as an identifying label in the menu
// entry.  Not available for separator or tear-off entries.
//
// # Menu(Menu(...))
//
// Available only for cascade entries.  Specifies the path name of
// the submenu associated with this entry.
// The submenu must be a child of the menu.
//
// # Menu(Offvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is
// deselected.
//
// # Menu(Onvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
//
// # Menu(Selectcolor(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies the color to display in the indicator when the entry is
// selected.
// If the value is an empty string (the default) then the -selectcolor
// option for the menu determines the indicator color.
//
// # Menu(Selectimage(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies an image to display in the entry (in place of
// the -image option) when it is selected.
// Value is the name of an image, which must have been created
// by some previous invocation of image create.
// This option is ignored unless the -image option has
// been specified.
//
// # Menu(State(...))
//
// Specifies one of three states for the entry:  normal, active,
// or disabled.  In normal state the entry is displayed using the
// -foreground option for the menu and the -background
// option from the entry or the menu.
// The active state is typically used when the pointer is over the entry.
// In active state the entry is displayed using the -activeforeground
// option for the menu along with the -activebackground option from
// the entry.  Disabled state means that the entry
// should be insensitive:  the default bindings will refuse to activate
// or invoke the entry.
// In this state the entry is displayed according to the
// -disabledforeground option for the menu and the
// -background option from the entry.
// This option is not available for separator entries.
//
// # Menu(Underline(...))
//
// Specifies the integer index of a character to underline in the entry.
// This option is also queried by the default bindings and used to
// implement keyboard traversal.
// 0 corresponds to the first character of the text displayed in the entry,
// 1 to the next character, and so on.
// If a bitmap or image is displayed in the entry then this option is ignored.
// This option is not available for separator or tear-off entries.
//
// # Menu(Value(...))
//
// Available only for radiobutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
// If an empty string is specified, then the -label option
// for the entry as the value to store in the variable.
//
// # Menu(Variable(...))
//
// Available only for checkbutton and radiobutton entries.  Specifies
// the name of a global variable to set when the entry is selected.
// For checkbutton entries the variable is also set when the entry
// is deselected.  For radiobutton entries, changing the variable
// causes the currently-selected entry to deselect itself.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk menu] page.
//
// [Tcl/Tk menu]: https://www.tcl.tk/man/tcl9.0/TkCmd/menu.html
func (w *Window) Menu(options ...option) *Window {
	return w.newChild("menu", options...)
}

// menu, tk_menuSetFocus - Create and manipulate 'menu' widgets and menubars
//
// # Menu(Postcommand(...))
//
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
//
// # Menu(Selectcolor(...))
//
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
//
// # Menu(Tearoff(...))
//
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
//
// # Menu(Tearoffcommand(...))
//
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
//
// # Menu(Title(...))
//
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
//
// # Menu(Type(...))
//
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
//
// # Menu(Activebackground(...))
//
// Specifies a background color to use for displaying this entry when it
// is active. This option is ignored on Aqua/MacOS.
// If it is specified as an empty string (the default), then the
// -activebackground option for the overall menu is used.
// If the tk_strictMotif variable has been set to request strict
// Motif compliance, then this option is ignored and the -background
// option is used in its place.
// This option is not available for separator or tear-off entries.
//
// # Menu(Activeforeground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is active.   This option is ignored on Aqua/macOS.
// If this option is specified as an empty string (the default), then the
// -activeforeground option for the overall menu is used.
//
// # Menu(Accelerator(...))
//
// Specifies a string to display at the right side of the menu entry.
// Normally describes an accelerator keystroke sequence that may be
// used to invoke the same function as the menu entry. This is a display
// option, it does not actually set the corresponding binding (which can
// be achieved using the bind command). This option is not available
// for separator or tear-off entries.
//
// # Menu(Background(...))
//
// Specifies a background color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -background option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Bitmap(...))
//
// Specifies a bitmap to display in the menu instead of a textual
// label, in any of the forms accepted by Tk_GetBitmap.
// This option overrides the -label option
// (as controlled by the -compound option)
// but may be reset
// to an empty string to enable a textual label to be displayed.
// If a -image option has been specified, it overrides
// -bitmap.
// This option is not available for separator or tear-off entries.
//
// # Menu(Columnbreak(...))
//
// When this option is zero, the entry appears below the previous entry. When
// this option is one, the entry appears at the top of a new column in the
// menu.
// This option is ignored on Aqua/macOS, where menus are always a single
// column.
//
// # Menu(Command(...))
//
// Specifies a Tcl command to execute when the menu entry is invoked.
// Not available for separator or tear-off entries.
//
// # Menu(Compound(...))
//
// Specifies whether the menu entry should display both an image and text,
// and if so, where the image should be placed relative to the text.
// Valid values for this option are bottom, center,
// left, none, right and top.  The default value
// is none, meaning that the button will display either an image or
// text, depending on the values of the -image and -bitmap
// options.
//
// # Menu(Font(...))
//
// Specifies the font to use when drawing the label or accelerator
// string in this entry.
// If this option is specified as an empty string (the default) then
// the -font option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Foreground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -foreground option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Hidemargin(...))
//
// Specifies whether the standard margins should be drawn for this menu
// entry. This is useful when creating palette with images in them, i.e.,
// color palettes, pattern palettes, etc. 1 indicates that the margin for
// the entry is hidden; 0 means that the margin is used.
//
// # Menu(Image(...))
//
// Specifies an image to display in the menu instead of a text string
// or bitmap.
// The image must have been created by some previous invocation of
// image create.
// This option overrides the -label and -bitmap options
// (as controlled by the -compound option)
// but may be reset to an empty string to enable a textual or
// bitmap label to be displayed.
// This option is not available for separator or tear-off entries.
//
// # Menu(Indicatoron(...))
//
// Available only for checkbutton and radiobutton entries.
// Value is a boolean that determines whether or not the
// indicator should be displayed.
//
// # Menu(Label(...))
//
// Specifies a string to display as an identifying label in the menu
// entry.  Not available for separator or tear-off entries.
//
// # Menu(Menu(...))
//
// Available only for cascade entries.  Specifies the path name of
// the submenu associated with this entry.
// The submenu must be a child of the menu.
//
// # Menu(Offvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is
// deselected.
//
// # Menu(Onvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
//
// # Menu(Selectcolor(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies the color to display in the indicator when the entry is
// selected.
// If the value is an empty string (the default) then the -selectcolor
// option for the menu determines the indicator color.
//
// # Menu(Selectimage(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies an image to display in the entry (in place of
// the -image option) when it is selected.
// Value is the name of an image, which must have been created
// by some previous invocation of image create.
// This option is ignored unless the -image option has
// been specified.
//
// # Menu(State(...))
//
// Specifies one of three states for the entry:  normal, active,
// or disabled.  In normal state the entry is displayed using the
// -foreground option for the menu and the -background
// option from the entry or the menu.
// The active state is typically used when the pointer is over the entry.
// In active state the entry is displayed using the -activeforeground
// option for the menu along with the -activebackground option from
// the entry.  Disabled state means that the entry
// should be insensitive:  the default bindings will refuse to activate
// or invoke the entry.
// In this state the entry is displayed according to the
// -disabledforeground option for the menu and the
// -background option from the entry.
// This option is not available for separator entries.
//
// # Menu(Underline(...))
//
// Specifies the integer index of a character to underline in the entry.
// This option is also queried by the default bindings and used to
// implement keyboard traversal.
// 0 corresponds to the first character of the text displayed in the entry,
// 1 to the next character, and so on.
// If a bitmap or image is displayed in the entry then this option is ignored.
// This option is not available for separator or tear-off entries.
//
// # Menu(Value(...))
//
// Available only for radiobutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
// If an empty string is specified, then the -label option
// for the entry as the value to store in the variable.
//
// # Menu(Variable(...))
//
// Available only for checkbutton and radiobutton entries.  Specifies
// the name of a global variable to set when the entry is selected.
// For checkbutton entries the variable is also set when the entry
// is deselected.  For radiobutton entries, changing the variable
// causes the currently-selected entry to deselect itself.
//
// Additional information might be available at the [Tcl/Tk menu] page.
//
// [Tcl/Tk menu]: https://www.tcl.tk/man/tcl9.0/TkCmd/menu.html
func Menu(options ...option) *Window {
	return App.Menu(options...)
}

// menubutton - Create and manipulate 'menubutton' pop-up menu indicator widgets
//
// # Menubutton(Direction(...))
//
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
//
// # Menubutton(Height(...))
//
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Menubutton(Indicatoron(...))
//
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
//
// # Menubutton(Menu(...))
//
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
//
// # Menubutton(State(...))
//
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Menubutton(Width(...))
//
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk menubutton] page.
//
// [Tcl/Tk menubutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/menubutton.html
func (w *Window) Menubutton(options ...option) *Window {
	return w.newChild("menubutton", options...)
}

// menubutton - Create and manipulate 'menubutton' pop-up menu indicator widgets
//
// # Menubutton(Direction(...))
//
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
//
// # Menubutton(Height(...))
//
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Menubutton(Indicatoron(...))
//
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
//
// # Menubutton(Menu(...))
//
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
//
// # Menubutton(State(...))
//
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Menubutton(Width(...))
//
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// Additional information might be available at the [Tcl/Tk menubutton] page.
//
// [Tcl/Tk menubutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/menubutton.html
func Menubutton(options ...option) *Window {
	return App.Menubutton(options...)
}

// message - Create and manipulate 'message' non-interactive text widgets
//
// # Message(Aspect(...))
//
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
//
// # Message(Justify(...))
//
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
//
// # Message(Width(...))
//
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
//
// # Description
//
// The message command creates a new window (given by the
// pathName argument) and makes it into a message widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the message such as its colors, font,
// text, and initial relief.  The message command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A message is a widget that displays a textual string.  A message
// widget has three special features that differentiate it from a
// label widget.  First, it breaks up
// its string into lines in order to produce a given aspect ratio
// for the window.  The line breaks are chosen at word boundaries
// wherever possible (if not even a single word would fit on a
// line, then the word will be split across lines).  Newline characters
// in the string will force line breaks;  they can be used, for example,
// to leave blank lines in the display.
//
// The second feature of a message widget is justification.  The text
// may be displayed left-justified (each line starts at the left side of
// the window), centered on a line-by-line basis, or right-justified
// (each line ends at the right side of the window).
//
// The third feature of a message widget is that it handles control
// characters and non-printing characters specially.  Tab characters
// are replaced with enough blank space to line up on the next
// 8-character boundary.  Newlines cause line breaks.  Other control
// characters (ASCII code less than 0x20) and characters not defined
// in the font are displayed as a four-character sequence \exhh where
// hh is the two-digit hexadecimal number corresponding to
// the character.  In the unusual case where the font does not contain
// all of the characters in
//
// then control characters and undefined characters are not displayed at all.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk message] page.
//
// [Tcl/Tk message]: https://www.tcl.tk/man/tcl9.0/TkCmd/message.html
func (w *Window) Message(options ...option) *Window {
	return w.newChild("message", options...)
}

// message - Create and manipulate 'message' non-interactive text widgets
//
// # Message(Aspect(...))
//
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
//
// # Message(Justify(...))
//
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
//
// # Message(Width(...))
//
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
//
// # Description
//
// The message command creates a new window (given by the
// pathName argument) and makes it into a message widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the message such as its colors, font,
// text, and initial relief.  The message command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A message is a widget that displays a textual string.  A message
// widget has three special features that differentiate it from a
// label widget.  First, it breaks up
// its string into lines in order to produce a given aspect ratio
// for the window.  The line breaks are chosen at word boundaries
// wherever possible (if not even a single word would fit on a
// line, then the word will be split across lines).  Newline characters
// in the string will force line breaks;  they can be used, for example,
// to leave blank lines in the display.
//
// The second feature of a message widget is justification.  The text
// may be displayed left-justified (each line starts at the left side of
// the window), centered on a line-by-line basis, or right-justified
// (each line ends at the right side of the window).
//
// The third feature of a message widget is that it handles control
// characters and non-printing characters specially.  Tab characters
// are replaced with enough blank space to line up on the next
// 8-character boundary.  Newlines cause line breaks.  Other control
// characters (ASCII code less than 0x20) and characters not defined
// in the font are displayed as a four-character sequence \exhh where
// hh is the two-digit hexadecimal number corresponding to
// the character.  In the unusual case where the font does not contain
// all of the characters in
//
// then control characters and undefined characters are not displayed at all.
//
// Additional information might be available at the [Tcl/Tk message] page.
//
// [Tcl/Tk message]: https://www.tcl.tk/man/tcl9.0/TkCmd/message.html
func Message(options ...option) *Window {
	return App.Message(options...)
}

// tk_optionMenu - Create an option menubutton and its menu
//
// This procedure creates an option menubutton whose name is pathName,
// plus an associated menu.
// Together they allow the user to select one of the values
// given by the value arguments.
// The current value will be stored in the global variable whose
// name is given by varName and it will also be displayed as the label
// in the option menubutton.
// The user can click on the menubutton to display a menu containing
// all of the values and thereby select a new value.
// Once a new value is selected, it will be stored in the variable
// and appear in the option menubutton.
// The current value can also be changed by setting the variable.
//
// The return value from tk_optionMenu is the name of the menu
// associated with pathName, so that the caller can change its
// configuration options or manipulate it in other ways.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk optionMenu] page.
//
// [Tcl/Tk optionMenu]: https://www.tcl.tk/man/tcl9.0/TkCmd/optionMenu.html
func (w *Window) OptionMenu(options ...option) *Window {
	return w.newChild("optionMenu", options...)
}

// tk_optionMenu - Create an option menubutton and its menu
//
// This procedure creates an option menubutton whose name is pathName,
// plus an associated menu.
// Together they allow the user to select one of the values
// given by the value arguments.
// The current value will be stored in the global variable whose
// name is given by varName and it will also be displayed as the label
// in the option menubutton.
// The user can click on the menubutton to display a menu containing
// all of the values and thereby select a new value.
// Once a new value is selected, it will be stored in the variable
// and appear in the option menubutton.
// The current value can also be changed by setting the variable.
//
// The return value from tk_optionMenu is the name of the menu
// associated with pathName, so that the caller can change its
// configuration options or manipulate it in other ways.
//
// Additional information might be available at the [Tcl/Tk optionMenu] page.
//
// [Tcl/Tk optionMenu]: https://www.tcl.tk/man/tcl9.0/TkCmd/optionMenu.html
func OptionMenu(options ...option) *Window {
	return App.OptionMenu(options...)
}

// pack - Geometry manager that packs around edges of cavity
//
// The pack command is used to communicate with the packer,
// a geometry manager that arranges the children of a parent by
// packing them in order around the edges of the parent.
// The pack command can have any of several forms, depending
// on the option argument:
//
// Additional information might be available at the [Tcl/Tk pack] page.
//
// [Tcl/Tk pack]: https://www.tcl.tk/man/tcl9.0/TkCmd/pack.html
func Pack(options ...option) {
	eval(fmt.Sprintf(`pack %s`, collect(options...)))
}

// panedwindow - Create and manipulate 'panedwindow' split container widgets
//
// # Panedwindow(Handlepad(...))
//
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Handlesize(...))
//
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Height(...))
//
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
//
// # Panedwindow(Opaqueresize(...))
//
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
//
// # Panedwindow(Proxybackground(...))
//
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
//
// # Panedwindow(Proxyborderwidth(...))
//
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
//
// # Panedwindow(Proxyrelief(...))
//
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
//
// # Panedwindow(Sashcursor(...))
//
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
//
// # Panedwindow(Sashpad(...))
//
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Sashrelief(...))
//
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
//
// # Panedwindow(Sashwidth(...))
//
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
//
// # Panedwindow(Showhandle(...))
//
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
//
// # Panedwindow(Width(...))
//
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
//
// # Panedwindow(After(...))
//
// Insert the window after the window specified.  window should be the
// name of a window already managed by pathName.
//
// # Panedwindow(Before(...))
//
// Insert the window before the window specified.  window should be
// the name of a window already managed by pathName.
//
// # Panedwindow(Height(...))
//
// Specify a height for the window.  The height will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -height is not specified, then the
// height requested internally by the window will be used initially; the
// height may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Panedwindow(Hide(...))
//
// Controls the visibility of a pane.  When the boolean is true
// (according to Tcl_GetBoolean) the pane will not be visible, but
// it will still be maintained in the list of panes.
//
// # Panedwindow(Minsize(...))
//
// Specifies that the size of the window cannot be made less than
// n.  This constraint only affects the size of the widget in the
// paned dimension \(em the x dimension for horizontal panedwindows, the y
// dimension for vertical panedwindows.  May be any value accepted by
// Tk_GetPixels.
//
// # Panedwindow(Padx(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the X-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Panedwindow(Pady(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the Y-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Panedwindow(Sticky(...))
//
// If a window's pane is larger than the requested dimensions of the
// window, this option may be used to position (or stretch) the window
// within its pane.  Style  is a string that contains zero or more
// of the characters n, s, e or w.  The string
// can optionally contains spaces or commas, but they are ignored.  Each
// letter refers to a side (north, south, east, or west) that the window
// will
//
// # Panedwindow(Stretch(...))
//
// Controls how extra space is allocated to each of the panes.
// When is one of always, first, last,
// middle, and never.
// The panedwindow will calculate the required size of all its panes. Any
// remaining (or deficit) space will be distributed to those panes marked
// for stretching. The space will be distributed based on each panes
// current ratio of the whole.  The when values have the following
// definition:
//
// # Panedwindow(Width(...))
//
// Specify a width for the window.  The width will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -width is not specified, then the
// width requested internally by the window will be used initially; the
// width may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Description
//
// The panedwindow command creates a new window (given by the
// pathName argument) and makes it into a panedwindow widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the panedwindow
// such as its default background color and relief.  The
// panedwindow command returns the path name of the new window.
//
// A panedwindow widget contains any number of panes, arranged
// horizontally or vertically, according to the value of the
// -orient option.  Each pane contains one widget, and each pair of
// panes is separated by a moveable (via mouse movements) sash.  Moving a
// sash causes the widgets on either side of the sash to be resized.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk panedwindow] page.
//
// [Tcl/Tk panedwindow]: https://www.tcl.tk/man/tcl9.0/TkCmd/panedwindow.html
func (w *Window) Panedwindow(options ...option) *Window {
	return w.newChild("panedwindow", options...)
}

// panedwindow - Create and manipulate 'panedwindow' split container widgets
//
// # Panedwindow(Handlepad(...))
//
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Handlesize(...))
//
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Height(...))
//
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
//
// # Panedwindow(Opaqueresize(...))
//
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
//
// # Panedwindow(Proxybackground(...))
//
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
//
// # Panedwindow(Proxyborderwidth(...))
//
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
//
// # Panedwindow(Proxyrelief(...))
//
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
//
// # Panedwindow(Sashcursor(...))
//
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
//
// # Panedwindow(Sashpad(...))
//
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Sashrelief(...))
//
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
//
// # Panedwindow(Sashwidth(...))
//
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
//
// # Panedwindow(Showhandle(...))
//
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
//
// # Panedwindow(Width(...))
//
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
//
// # Panedwindow(After(...))
//
// Insert the window after the window specified.  window should be the
// name of a window already managed by pathName.
//
// # Panedwindow(Before(...))
//
// Insert the window before the window specified.  window should be
// the name of a window already managed by pathName.
//
// # Panedwindow(Height(...))
//
// Specify a height for the window.  The height will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -height is not specified, then the
// height requested internally by the window will be used initially; the
// height may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Panedwindow(Hide(...))
//
// Controls the visibility of a pane.  When the boolean is true
// (according to Tcl_GetBoolean) the pane will not be visible, but
// it will still be maintained in the list of panes.
//
// # Panedwindow(Minsize(...))
//
// Specifies that the size of the window cannot be made less than
// n.  This constraint only affects the size of the widget in the
// paned dimension \(em the x dimension for horizontal panedwindows, the y
// dimension for vertical panedwindows.  May be any value accepted by
// Tk_GetPixels.
//
// # Panedwindow(Padx(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the X-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Panedwindow(Pady(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the Y-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Panedwindow(Sticky(...))
//
// If a window's pane is larger than the requested dimensions of the
// window, this option may be used to position (or stretch) the window
// within its pane.  Style  is a string that contains zero or more
// of the characters n, s, e or w.  The string
// can optionally contains spaces or commas, but they are ignored.  Each
// letter refers to a side (north, south, east, or west) that the window
// will
//
// # Panedwindow(Stretch(...))
//
// Controls how extra space is allocated to each of the panes.
// When is one of always, first, last,
// middle, and never.
// The panedwindow will calculate the required size of all its panes. Any
// remaining (or deficit) space will be distributed to those panes marked
// for stretching. The space will be distributed based on each panes
// current ratio of the whole.  The when values have the following
// definition:
//
// # Panedwindow(Width(...))
//
// Specify a width for the window.  The width will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -width is not specified, then the
// width requested internally by the window will be used initially; the
// width may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Description
//
// The panedwindow command creates a new window (given by the
// pathName argument) and makes it into a panedwindow widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the panedwindow
// such as its default background color and relief.  The
// panedwindow command returns the path name of the new window.
//
// A panedwindow widget contains any number of panes, arranged
// horizontally or vertically, according to the value of the
// -orient option.  Each pane contains one widget, and each pair of
// panes is separated by a moveable (via mouse movements) sash.  Moving a
// sash causes the widgets on either side of the sash to be resized.
//
// Additional information might be available at the [Tcl/Tk panedwindow] page.
//
// [Tcl/Tk panedwindow]: https://www.tcl.tk/man/tcl9.0/TkCmd/panedwindow.html
func Panedwindow(options ...option) *Window {
	return App.Panedwindow(options...)
}

// radiobutton - Create and manipulate 'radiobutton' pick-one widgets
//
// # Radiobutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Radiobutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Radiobutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Radiobutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Radiobutton(Overrelief(...))
//
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
//
// # Radiobutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Radiobutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(State(...))
//
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
//
// # Radiobutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Tristatevalue(...))
//
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Radiobutton(Value(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.
//
// # Radiobutton(Variable(...))
//
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
//
// # Radiobutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The radiobutton command creates a new window (given by the
// pathName argument) and makes it into a radiobutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the radiobutton such as its colors, font,
// text, and initial relief.  The radiobutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A radiobutton is a widget that displays a textual string, bitmap or image
// and a diamond or circle called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.  A radiobutton has
// all of the behavior of a simple button: it can display itself in either
// of three different ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// check button.
//
// In addition, radiobuttons can be selected.
// If a radiobutton is selected, the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the radiobutton is set to a particular
// value (normally 1).
// Under Unix, the indicator is drawn with a sunken relief and a special
// color.  Under Windows, the indicator is drawn with a round mark inside.
// If the radiobutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a round mark inside.
// Typically, several radiobuttons share a single variable and the
// value of the variable indicates which radiobutton is to be selected.
// When a radiobutton is selected it sets the value of the variable to
// indicate that fact;  each radiobutton also monitors the value of
// the variable and automatically selects and deselects itself when the
// variable's value changes.
// If the variable's value matches the -tristatevalue, then the radiobutton
// is drawn using the tri-state mode.  This mode is used to indicate mixed or
// multiple values.  (This is used when the radiobutton represents the state
// of multiple items.)
// By default the variable selectedButton
// is used;  its contents give the name of the button that is
// selected, or the empty string if no button associated with that
// variable is selected.
// The name of the variable for a radiobutton,
// plus the variable to be stored into it, may be modified with options
// on the command line or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a radiobutton is configured to select itself on button clicks.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk radiobutton] page.
//
// [Tcl/Tk radiobutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/radiobutton.html
func (w *Window) Radiobutton(options ...option) *Window {
	return w.newChild("radiobutton", options...)
}

// radiobutton - Create and manipulate 'radiobutton' pick-one widgets
//
// # Radiobutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Radiobutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Radiobutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Radiobutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Radiobutton(Overrelief(...))
//
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
//
// # Radiobutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Radiobutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(State(...))
//
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
//
// # Radiobutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Tristatevalue(...))
//
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Radiobutton(Value(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.
//
// # Radiobutton(Variable(...))
//
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
//
// # Radiobutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Description
//
// The radiobutton command creates a new window (given by the
// pathName argument) and makes it into a radiobutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the radiobutton such as its colors, font,
// text, and initial relief.  The radiobutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A radiobutton is a widget that displays a textual string, bitmap or image
// and a diamond or circle called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.  A radiobutton has
// all of the behavior of a simple button: it can display itself in either
// of three different ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// check button.
//
// In addition, radiobuttons can be selected.
// If a radiobutton is selected, the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the radiobutton is set to a particular
// value (normally 1).
// Under Unix, the indicator is drawn with a sunken relief and a special
// color.  Under Windows, the indicator is drawn with a round mark inside.
// If the radiobutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a round mark inside.
// Typically, several radiobuttons share a single variable and the
// value of the variable indicates which radiobutton is to be selected.
// When a radiobutton is selected it sets the value of the variable to
// indicate that fact;  each radiobutton also monitors the value of
// the variable and automatically selects and deselects itself when the
// variable's value changes.
// If the variable's value matches the -tristatevalue, then the radiobutton
// is drawn using the tri-state mode.  This mode is used to indicate mixed or
// multiple values.  (This is used when the radiobutton represents the state
// of multiple items.)
// By default the variable selectedButton
// is used;  its contents give the name of the button that is
// selected, or the empty string if no button associated with that
// variable is selected.
// The name of the variable for a radiobutton,
// plus the variable to be stored into it, may be modified with options
// on the command line or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a radiobutton is configured to select itself on button clicks.
//
// Additional information might be available at the [Tcl/Tk radiobutton] page.
//
// [Tcl/Tk radiobutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/radiobutton.html
func Radiobutton(options ...option) *Window {
	return App.Radiobutton(options...)
}

// scale - Create and manipulate 'scale' value-controlled slider widgets
//
// # Scale(Bigincrement(...))
//
// # Some interactions with the scale cause its value to change by
//
// # Scale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
//
// # Scale(Digits(...))
//
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
//
// # Scale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # Scale(Label(...))
//
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
//
// # Scale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
//
// # Scale(Resolution(...))
//
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
//
// # Scale(Showvalue(...))
//
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
//
// # Scale(Sliderlength(...))
//
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
//
// # Scale(Sliderrelief(...))
//
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
//
// # Scale(State(...))
//
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
//
// # Scale(Tickinterval(...))
//
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
//
// # Scale(To(...))
//
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # Scale(Variable(...))
//
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
//
// # Scale(Width(...))
//
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
//
// # Description
//
// The scale command creates a new window (given by the
// pathName argument) and makes it into a scale widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the scale such as its colors, orientation,
// and relief.  The scale command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A scale is a widget that displays a rectangular trough and a
// small slider.  The trough corresponds to a range
// of real values (determined by the -from, -to, and
// -resolution options),
// and the position of the slider selects a particular real value.
// The slider's position (and hence the scale's value) may be adjusted
// with the mouse or keyboard as described in the BINDINGS
// section below.  Whenever the scale's value is changed, a Tcl
// command is invoked (using the -command option) to notify
// other interested widgets of the change.
// In addition, the value
// of the scale can be linked to a Tcl variable (using the -variable
// option), so that changes in either are reflected in the other.
//
// Three annotations may be displayed in a scale widget:  a label
// appearing at the top right of the widget (top left for horizontal
// scales), a number displayed just to the left of the slider
// (just above the slider for horizontal scales), and a collection
// of numerical tick marks just to the left of the current value
// (just below the trough for horizontal scales).  Each of these three
// annotations may be enabled or disabled using the
// configuration options.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk scale] page.
//
// [Tcl/Tk scale]: https://www.tcl.tk/man/tcl9.0/TkCmd/scale.html
func (w *Window) Scale(options ...option) *Window {
	return w.newChild("scale", options...)
}

// scale - Create and manipulate 'scale' value-controlled slider widgets
//
// # Scale(Bigincrement(...))
//
// # Some interactions with the scale cause its value to change by
//
// # Scale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
//
// # Scale(Digits(...))
//
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
//
// # Scale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # Scale(Label(...))
//
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
//
// # Scale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
//
// # Scale(Resolution(...))
//
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
//
// # Scale(Showvalue(...))
//
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
//
// # Scale(Sliderlength(...))
//
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
//
// # Scale(Sliderrelief(...))
//
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
//
// # Scale(State(...))
//
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
//
// # Scale(Tickinterval(...))
//
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
//
// # Scale(To(...))
//
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # Scale(Variable(...))
//
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
//
// # Scale(Width(...))
//
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
//
// # Description
//
// The scale command creates a new window (given by the
// pathName argument) and makes it into a scale widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the scale such as its colors, orientation,
// and relief.  The scale command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A scale is a widget that displays a rectangular trough and a
// small slider.  The trough corresponds to a range
// of real values (determined by the -from, -to, and
// -resolution options),
// and the position of the slider selects a particular real value.
// The slider's position (and hence the scale's value) may be adjusted
// with the mouse or keyboard as described in the BINDINGS
// section below.  Whenever the scale's value is changed, a Tcl
// command is invoked (using the -command option) to notify
// other interested widgets of the change.
// In addition, the value
// of the scale can be linked to a Tcl variable (using the -variable
// option), so that changes in either are reflected in the other.
//
// Three annotations may be displayed in a scale widget:  a label
// appearing at the top right of the widget (top left for horizontal
// scales), a number displayed just to the left of the slider
// (just above the slider for horizontal scales), and a collection
// of numerical tick marks just to the left of the current value
// (just below the trough for horizontal scales).  Each of these three
// annotations may be enabled or disabled using the
// configuration options.
//
// Additional information might be available at the [Tcl/Tk scale] page.
//
// [Tcl/Tk scale]: https://www.tcl.tk/man/tcl9.0/TkCmd/scale.html
func Scale(options ...option) *Window {
	return App.Scale(options...)
}

// scrollbar - Create and manipulate 'scrollbar' scrolling control and indicator widgets
//
// # Scrollbar(Activerelief(...))
//
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
//
// # Scrollbar(Command(...))
//
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
//
// # Scrollbar(Elementborderwidth(...))
//
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
//
// # Scrollbar(Width(...))
//
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # Description
//
// The scrollbar command creates a new window (given by the
// pathName argument) and makes it into a scrollbar widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the scrollbar
// such as its colors, orientation, and relief.
// The scrollbar command returns its pathName argument.
// At the time this command is invoked, there must not exist a window
// named pathName, but pathName's parent must exist.
//
// A scrollbar is a widget that displays two arrows, one at each end of
// the scrollbar, and a slider in the middle portion of the
// scrollbar.
// It provides information about what is visible in an associated window
// that displays a document of some sort (such as a file being edited or
// a drawing).
// The position and size of the slider indicate which portion of the
// document is visible in the associated window.  For example, if the
// slider in a vertical scrollbar covers the top third of the area
// between the two arrows, it means that the associated window displays
// the top third of its document.
//
// Scrollbars can be used to adjust the view in the associated window
// by clicking or dragging with the mouse.  See the BINDINGS section
// below for details.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk scrollbar] page.
//
// [Tcl/Tk scrollbar]: https://www.tcl.tk/man/tcl9.0/TkCmd/scrollbar.html
func (w *Window) Scrollbar(options ...option) *Window {
	return w.newChild("scrollbar", options...)
}

// scrollbar - Create and manipulate 'scrollbar' scrolling control and indicator widgets
//
// # Scrollbar(Activerelief(...))
//
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
//
// # Scrollbar(Command(...))
//
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
//
// # Scrollbar(Elementborderwidth(...))
//
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
//
// # Scrollbar(Width(...))
//
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # Description
//
// The scrollbar command creates a new window (given by the
// pathName argument) and makes it into a scrollbar widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the scrollbar
// such as its colors, orientation, and relief.
// The scrollbar command returns its pathName argument.
// At the time this command is invoked, there must not exist a window
// named pathName, but pathName's parent must exist.
//
// A scrollbar is a widget that displays two arrows, one at each end of
// the scrollbar, and a slider in the middle portion of the
// scrollbar.
// It provides information about what is visible in an associated window
// that displays a document of some sort (such as a file being edited or
// a drawing).
// The position and size of the slider indicate which portion of the
// document is visible in the associated window.  For example, if the
// slider in a vertical scrollbar covers the top third of the area
// between the two arrows, it means that the associated window displays
// the top third of its document.
//
// Scrollbars can be used to adjust the view in the associated window
// by clicking or dragging with the mouse.  See the BINDINGS section
// below for details.
//
// Additional information might be available at the [Tcl/Tk scrollbar] page.
//
// [Tcl/Tk scrollbar]: https://www.tcl.tk/man/tcl9.0/TkCmd/scrollbar.html
func Scrollbar(options ...option) *Window {
	return App.Scrollbar(options...)
}

// spinbox - Create and manipulate 'spinbox' value spinner widgets
//
// # Spinbox(Buttonbackground(...))
//
// The background color to be used for the spin buttons.
//
// # Spinbox(Buttoncursor(...))
//
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
//
// # Spinbox(Buttondownrelief(...))
//
// The relief to be used for the upper spin button.
//
// # Spinbox(Buttonuprelief(...))
//
// The relief to be used for the lower spin button.
//
// # Spinbox(Command(...))
//
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
//
// # Spinbox(Disabledbackground(...))
//
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Disabledforeground(...))
//
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Spinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # Spinbox(From(...))
//
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # Spinbox(Invalidcommand(...)) or Spinbox(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// # Spinbox(Increment(...))
//
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
//
// # Spinbox(Readonlybackground(...))
//
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(State(...))
//
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Spinbox(To(...))
//
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # Spinbox(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Spinbox(Validatecommand(...)) or Spinbox(Vcmd(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Values(...))
//
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
//
// # Spinbox(Width(...))
//
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Spinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Description
//
// The spinbox command creates a new window (given by the
// pathName argument) and makes it into a spinbox widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the spinbox such as its colors, font,
// and relief.  The spinbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A spinbox is an extended entry widget that allows he user
// to move, or spin, through a fixed set of ascending or descending values
// such as times or dates in addition to editing the value as in an
// entry.  When first created, a spinbox's string is empty.
// A portion of the spinbox may be selected as described below.
// If a spinbox is exporting its selection (see the -exportselection
// option), then it will observe the standard protocols for handling the
// selection;  spinbox selections are available as type STRING.
// Spinboxes also observe the standard Tk rules for dealing with the
// input focus.  When a spinbox has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
//
// Spinboxes are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed; commands described below
// may be used to change the view in the window.  Spinboxes use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk spinbox] page.
//
// [Tcl/Tk spinbox]: https://www.tcl.tk/man/tcl9.0/TkCmd/spinbox.html
func (w *Window) Spinbox(options ...option) *Window {
	return w.newChild("spinbox", options...)
}

// spinbox - Create and manipulate 'spinbox' value spinner widgets
//
// # Spinbox(Buttonbackground(...))
//
// The background color to be used for the spin buttons.
//
// # Spinbox(Buttoncursor(...))
//
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
//
// # Spinbox(Buttondownrelief(...))
//
// The relief to be used for the upper spin button.
//
// # Spinbox(Buttonuprelief(...))
//
// The relief to be used for the lower spin button.
//
// # Spinbox(Command(...))
//
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
//
// # Spinbox(Disabledbackground(...))
//
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Disabledforeground(...))
//
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Spinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # Spinbox(From(...))
//
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # Spinbox(Invalidcommand(...)) or Spinbox(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// # Spinbox(Increment(...))
//
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
//
// # Spinbox(Readonlybackground(...))
//
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(State(...))
//
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Spinbox(To(...))
//
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # Spinbox(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Spinbox(Validatecommand(...)) or Spinbox(Vcmd(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Values(...))
//
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
//
// # Spinbox(Width(...))
//
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Spinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Description
//
// The spinbox command creates a new window (given by the
// pathName argument) and makes it into a spinbox widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the spinbox such as its colors, font,
// and relief.  The spinbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
//
// A spinbox is an extended entry widget that allows he user
// to move, or spin, through a fixed set of ascending or descending values
// such as times or dates in addition to editing the value as in an
// entry.  When first created, a spinbox's string is empty.
// A portion of the spinbox may be selected as described below.
// If a spinbox is exporting its selection (see the -exportselection
// option), then it will observe the standard protocols for handling the
// selection;  spinbox selections are available as type STRING.
// Spinboxes also observe the standard Tk rules for dealing with the
// input focus.  When a spinbox has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
//
// Spinboxes are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed; commands described below
// may be used to change the view in the window.  Spinboxes use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
//
// Additional information might be available at the [Tcl/Tk spinbox] page.
//
// [Tcl/Tk spinbox]: https://www.tcl.tk/man/tcl9.0/TkCmd/spinbox.html
func Spinbox(options ...option) *Window {
	return App.Spinbox(options...)
}

// text, tk_textCopy, tk_textCut, tk_textPaste - Create and manipulate 'text' hypertext editing widgets
//
// # Text(Autoseparators(...))
//
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
//
// # Text(Blockcursor(...))
//
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
//
// # Text(Endline(...))
//
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
//
// # Text(Height(...))
//
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
//
// # Text(Inactiveselectbackground(...))
//
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
//
// # Text(Insertunfocussed(...))
//
//	8.6
//
// # Text(Maxundo(...))
//
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
//
// # Text(Spacing1(...))
//
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
//
// # Text(Spacing2(...))
//
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
//
// # Text(Spacing3(...))
//
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
//
// # Text(Startline(...))
//
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
//
// # Text(State(...))
//
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
//
// # Text(Tabs(...))
//
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
//
// # Text(Tabstyle(...))
//
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n”th tab
// character in the line's text will be associated with the 'n”th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n”th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
//
// # Text(Undo(...))
//
// Specifies a boolean that says whether the undo mechanism is active or not.
//
// # Text(Width(...))
//
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
//
// # Text(Wrap(...))
//
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
//
// # Text(Background(...))
//
// Color specifies the background color to use for characters associated
// with the tag. It may have any of the forms accepted by Tk_GetColor.
//
// # Text(Bgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern for the
// background. It may have any of the forms accepted by Tk_GetBitmap. If
// bitmap has not been specified, or if it is specified as an empty string,
// then a solid fill will be used for the background.
//
// # Text(Borderwidth(...))
//
// Pixels specifies the width of a border to draw around the tag using any
// of the forms accepted by Tk_GetPixels. This option should be used in
// conjunction with the -relief option to provide the desired border.
//
// # Text(Elide(...))
//
// Elide specifies whether the data should be elided. Elided data
// (characters, images, embedded windows, etc.) is not displayed and takes no
// space on screen, but further on behaves just as normal data.
//
// # Text(Fgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern when drawing
// text and other foreground information such as underlines. It may have any of
// the forms accepted by Tk_GetBitmap. If bitmap has not been
// specified, or if it is specified as an empty string, then a solid fill will be
// used.
//
// # Text(Font(...))
//
// FontName is the name of a font to use for drawing characters. It may
// have any of the forms accepted by Tk_GetFont.
//
// # Text(Foreground(...))
//
// Color specifies the color to use when drawing text and other foreground
// information such as underlines. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Text(Justify(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then justify determines how to justify the
// line. It must be one of left, right, or center. If a line
// wraps, then the justification for each line on the display is determined by
// the first non-elided character of that display line.
//
// # Text(Lmargin1(...))
//
// If the first non-elided character of a text line has a tag for which this
// option has been specified, then pixels specifies how much the line
// should be indented from the left edge of the window. Pixels may have any
// of the standard forms for screen distances. If a line of text wraps, this
// option only applies to the first line on the display; the -lmargin2
// option controls the indentation for subsequent lines.
//
// # Text(Lmargin2(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, and if the display line is not the first for its
// text line (i.e., the text line has wrapped), then pixels specifies how
// much the line should be indented from the left edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled, and it only applies to the
// second and later display lines for a text line.
//
// # Text(Lmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -lmargin1 or
// -lmargin2. It may have any of the forms accepted by
// Tk_GetColor. If color has not been specified, or if it is
// specified as an empty string, then the color used is specified by the
// -background tag option (or, if this is also unspecified, by the
// -background widget option).
//
// # Text(Offset(...))
//
// Pixels specifies an amount by which the text's baseline should be offset
// vertically from the baseline of the overall line, in pixels. For example, a
// positive offset can be used for superscripts and a negative offset can be used
// for subscripts. Pixels may have any of the standard forms for screen
// distances.
//
// # Text(Overstrike(...))
//
// Specifies whether or not to draw a horizontal rule through the middle of
// characters. Boolean may have any of the forms accepted by
// Tcl_GetBoolean.
//
// # Text(Overstrikefg(...))
//
// Color specifies the color to use when displaying the overstrike. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
//
// # Text(Relief(...))
//
// Relief specifies the relief style to use for drawing the border, in any
// of the forms accepted by Tk_GetRelief. This option is used in
// conjunction with the -borderwidth option to enable to the desired
// border appearance.
//
// # Text(Rmargin(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then pixels specifies how wide a margin to
// leave between the end of the line and the right edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled. If a text line wraps, the right
// margin for each line on the display is determined by the first non-elided
// character of that display line.
//
// # Text(Rmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -rmargin. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// used is specified by the -background tag option (or, if this is also
// unspecified, by the -background widget option).
//
// # Text(Selectbackground(...))
//
// Color specifies the background color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -background tag option is
// used.
//
// # Text(Selectforeground(...))
//
// Color specifies the foreground color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -foreground tag option is
// used.
//
// # Text(Spacing1(...))
//
// Pixels specifies how much additional space should be left above each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the first line on the display.
//
// # Text(Spacing2(...))
//
// For lines that wrap, this option specifies how much additional space to leave
// between the display lines for a single text line. Pixels may have any of
// the standard forms for screen distances.
//
// # Text(Spacing3(...))
//
// Pixels specifies how much additional space should be left below each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the last line on the display.
//
// # Text(Tabs(...))
//
// TabList specifies a set of tab stops in the same form as for the
// -tabs option for the text widget. This option only applies to a display
// line if it applies to the first non-elided character on that display line. If
// this option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default). If the option is specified as a
// non-empty string that is an empty list, such as -tags\0{\0}, then it
// requests default 8-character tabs as described for the -tags widget
// option.
//
// # Text(Tabstyle(...))
//
// Style specifies either the tabular or wordprocessor style of
// tabbing to use for the text widget. This option only applies to a display line
// if it applies to the first non-elided character on that display line. If this
// option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default).
//
// # Text(Underline(...))
//
// Boolean specifies whether or not to draw an underline underneath
// characters. It may have any of the forms accepted by Tcl_GetBoolean.
//
// # Text(Underlinefg(...))
//
// Color specifies the color to use when displaying the underline. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
//
// # Text(Wrap(...))
//
// Mode specifies how to handle lines that are wider than the text's
// window. This option only applies to a display line if it applies to the
// first non-elided character on that display line. It has the same legal
// values as the -wrap option for the text widget: none,
// char, or word. If this tag option is specified, it
// overrides the -wrap option for the text widget.
//
// # Text(Align(...))
//
// If the window is not as tall as the line in which it is displayed, this option
// determines where the window is displayed in the line. Where must have
// one of the values top (align the top of the window with the top of the
// line), center (center the window within the range of the line),
// bottom (align the bottom of the window with the bottom of the line's
// area), or baseline (align the bottom of the window with the baseline of
// the line).
//
// # Text(Create(...))
//
// Specifies a Tcl script that may be evaluated to create the window for the
// annotation. If no -window option has been specified for the annotation
// this script will be evaluated when the annotation is about to be displayed on
// the screen. Script must create a window for the annotation and return
// the name of that window as its result. Two substitutions will be performed in
// script before evaluation. %W will be substituted by the name of
// the parent text widget, and %% will be substituted by a single %.
// If the annotation's window should ever be deleted, script will be
// evaluated again the next time the annotation is displayed.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded window. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded window. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(Stretch(...))
//
// If the requested height of the embedded window is less than the height of the
// line in which it is displayed, this option can be used to specify whether the
// window should be stretched vertically to fill its line. If the -pady
// option has been specified as well, then the requested padding will be retained
// even if the window is stretched.
//
// # Text(Window(...))
//
// Specifies the name of a window to display in the annotation. Note that if a
// pathName has been set, then later configuring a window to the empty
// string will not delete the widget corresponding to the old pathName.
// Rather it will remove the association between the old pathName and the
// text widget. If multiple peer widgets are in use, it is usually simpler to use
// the -create option if embedded windows are desired in each peer.
//
// # Text(Align(...))
//
// If the image is not as tall as the line in which it is displayed, this option
// determines where the image is displayed in the line. Where must have one
// of the values top (align the top of the image with the top of the line),
// center (center the image within the range of the line), bottom
// (align the bottom of the image with the bottom of the line's area), or
// baseline (align the bottom of the image with the baseline of the line).
//
// # Text(Image(...))
//
// Specifies the name of the Tk image to display in the annotation. If
// image is not a valid Tk image, then an error is returned.
//
// # Text(Name(...))
//
// Specifies the name by which this image instance may be referenced in the text
// widget. If ImageName is not supplied, then the name of the Tk image is
// used instead. If the imageName is already in use, #nn is appended
// to the end of the name as described above.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded image. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded image. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(All(...))
//
// Return information about all elements: text, marks, tags, images and windows.
// This is the default.
//
// # Text(Command(...))
//
// Instead of returning the information as the result of the dump operation,
// invoke the command on each element of the text widget within the range.
// The command has three arguments appended to it before it is evaluated: the
// key, value, and index.
//
// # Text(Image(...))
//
// Include information about images in the dump results.
//
// # Text(Mark(...))
//
// Include information about marks in the dump results.
//
// # Text(Tag(...))
//
// Include information about tag transitions in the dump results. Tag information
// is returned as tagon and tagoff elements that indicate the begin
// and end of each range of each tag, respectively.
//
// # Text(Text(...))
//
// Include information about text in the dump results. The value is the text up
// to the next element or the end of range indicated by index2. A text
// element does not span newlines. A multi-line block of text that contains no
// marks or tag transitions will still be dumped as a set of text segments that
// each end with a newline. The newline is part of the value.
//
// # Text(Window(...))
//
// Include information about embedded windows in the dump results. The value of a
// window is its Tk pathname, unless the window has not been created yet. (It
// must have a create script.) In this case an empty string is returned, and you
// must query the window by its index position to get more information.
//
// # Text(Forwards(...))
//
// The search will proceed forward through the text, finding the first matching
// range starting at or after the position given by index. This is the
// default.
//
// # Text(Backwards(...))
//
// The search will proceed backward through the text, finding the matching range
// closest to index whose first character is before index (it is not
// allowed to be at index). Note that, for a variety of reasons, backwards
// searches can be substantially slower than forwards searches (particularly when
// using -regexp), so it is recommended that performance-critical code use
// forward searches.
//
// # Text(Exact(...))
//
// Use exact matching: the characters in the matching range must be identical to
// those in pattern. This is the default.
//
// # Text(Regexp(...))
//
// Treat pattern as a regular expression and match it against the text
// using the rules for regular expressions (see the regexp command
// and the re_syntax page for
// details). The default matching automatically passes both the
// -lineanchor and -linestop options to the regexp engine (unless
// -nolinestop is used), so that ^$ match beginning and end of line,
// and ., [^ sequences will never match the newline character
// \en.
//
// # Text(Nolinestop(...))
//
// This allows . and [^ sequences to match the newline character
// \en, which they will otherwise not do (see the regexp command for
// details). This option is only meaningful if -regexp is also given, and
// an error will be thrown otherwise. For example, to match the entire text, use
//
// # Text(Nocase(...))
//
// Ignore case differences between the pattern and the text.
//
// # Text(Count(...))
//
// The argument following -count gives the name of a variable; if a match
// is found, the number of index positions between beginning and end of the
// matching range will be stored in the variable. If there are no embedded images
// or windows in the matching range (and there are no elided characters if
// -elide is not given), this is equivalent to the number of characters
// matched. In either case, the range matchIdx to matchIdx + $count
// chars will return the entire matched text.
//
// # Text(All(...))
//
// Find all matches in the given range and return a list of the indices of the
// first character of each match. If a -count varName switch is given,
// then varName is also set to a list containing one element for each
// successful match. Note that, even for exact searches, the elements of this
// list may be different, if there are embedded images, windows or hidden text.
// Searches with -all behave very similarly to the Tcl command regexp
// -all, in that overlapping matches are not normally returned. For example,
// applying an -all search of the pattern
//
// # Text(Overlap(...))
//
// When performing -all searches, the normal behaviour is that matches
// which overlap an already-found match will not be returned. This switch changes
// that behaviour so that all matches which are not totally enclosed within
// another match are returned. For example, applying an -overlap search of
// the pattern
//
// # Text(Strictlimits(...))
//
// When performing any search, the normal behaviour is that the start and stop
// limits are checked with respect to the start of the matching text. With the
// -strictlimits flag, the entire matching range must lie inside the start
// and stop limits specified for the match to be valid.
//
// # Text(Elide(...))
//
// Find elided (hidden) text as well. By default only displayed text is searched.
//
// # Text(-(...))
//
// This switch has no effect except to terminate the list of switches: the next
// argument will be treated as pattern even if it starts with -.
//
// # Description
//
// The text command creates a new window (given by the pathName
// argument) and makes it into a text widget. Additional options, described
// above, may be specified on the command line or in the option database to
// configure aspects of the text such as its default background color and relief.
// The text command returns the path name of the new window.
//
// A text widget displays one or more lines of text and allows that text to be
// edited. Text widgets support four different kinds of annotations on the text,
// called tags, marks, embedded windows or embedded images. Tags allow different
// portions of the text to be displayed with different fonts and colors. In
// addition, Tcl commands can be associated with tags so that scripts are invoked
// when particular actions such as keystrokes and mouse button presses occur in
// particular ranges of the text. See TAGS below for more details.
//
// # The second form of annotation consists of floating markers in the text called
//
// Marks are used to keep track of various interesting positions in the text as
// it is edited. See MARKS below for more details.
//
// The third form of annotation allows arbitrary windows to be embedded in a text
// widget. See EMBEDDED WINDOWS below for more details.
//
// The fourth form of annotation allows Tk images to be embedded in a text
// widget. See EMBEDDED IMAGES below for more details.
//
// The text widget also has a built-in undo/redo mechanism. See
// THE UNDO MECHANISM below for more details.
//
// The text widget allows for the creation of peer widgets. These are other text
// widgets which share the same underlying data (text, marks, tags, images, etc).
// See PEER WIDGETS below for more details.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk text] page.
//
// [Tcl/Tk text]: https://www.tcl.tk/man/tcl9.0/TkCmd/text.html
func (w *Window) Text(options ...option) *Window {
	return w.newChild("text", options...)
}

// text, tk_textCopy, tk_textCut, tk_textPaste - Create and manipulate 'text' hypertext editing widgets
//
// # Text(Autoseparators(...))
//
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
//
// # Text(Blockcursor(...))
//
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
//
// # Text(Endline(...))
//
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
//
// # Text(Height(...))
//
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
//
// # Text(Inactiveselectbackground(...))
//
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
//
// # Text(Insertunfocussed(...))
//
//	8.6
//
// # Text(Maxundo(...))
//
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
//
// # Text(Spacing1(...))
//
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
//
// # Text(Spacing2(...))
//
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
//
// # Text(Spacing3(...))
//
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
//
// # Text(Startline(...))
//
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
//
// # Text(State(...))
//
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
//
// # Text(Tabs(...))
//
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
//
// # Text(Tabstyle(...))
//
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n”th tab
// character in the line's text will be associated with the 'n”th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n”th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
//
// # Text(Undo(...))
//
// Specifies a boolean that says whether the undo mechanism is active or not.
//
// # Text(Width(...))
//
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
//
// # Text(Wrap(...))
//
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
//
// # Text(Background(...))
//
// Color specifies the background color to use for characters associated
// with the tag. It may have any of the forms accepted by Tk_GetColor.
//
// # Text(Bgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern for the
// background. It may have any of the forms accepted by Tk_GetBitmap. If
// bitmap has not been specified, or if it is specified as an empty string,
// then a solid fill will be used for the background.
//
// # Text(Borderwidth(...))
//
// Pixels specifies the width of a border to draw around the tag using any
// of the forms accepted by Tk_GetPixels. This option should be used in
// conjunction with the -relief option to provide the desired border.
//
// # Text(Elide(...))
//
// Elide specifies whether the data should be elided. Elided data
// (characters, images, embedded windows, etc.) is not displayed and takes no
// space on screen, but further on behaves just as normal data.
//
// # Text(Fgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern when drawing
// text and other foreground information such as underlines. It may have any of
// the forms accepted by Tk_GetBitmap. If bitmap has not been
// specified, or if it is specified as an empty string, then a solid fill will be
// used.
//
// # Text(Font(...))
//
// FontName is the name of a font to use for drawing characters. It may
// have any of the forms accepted by Tk_GetFont.
//
// # Text(Foreground(...))
//
// Color specifies the color to use when drawing text and other foreground
// information such as underlines. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Text(Justify(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then justify determines how to justify the
// line. It must be one of left, right, or center. If a line
// wraps, then the justification for each line on the display is determined by
// the first non-elided character of that display line.
//
// # Text(Lmargin1(...))
//
// If the first non-elided character of a text line has a tag for which this
// option has been specified, then pixels specifies how much the line
// should be indented from the left edge of the window. Pixels may have any
// of the standard forms for screen distances. If a line of text wraps, this
// option only applies to the first line on the display; the -lmargin2
// option controls the indentation for subsequent lines.
//
// # Text(Lmargin2(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, and if the display line is not the first for its
// text line (i.e., the text line has wrapped), then pixels specifies how
// much the line should be indented from the left edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled, and it only applies to the
// second and later display lines for a text line.
//
// # Text(Lmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -lmargin1 or
// -lmargin2. It may have any of the forms accepted by
// Tk_GetColor. If color has not been specified, or if it is
// specified as an empty string, then the color used is specified by the
// -background tag option (or, if this is also unspecified, by the
// -background widget option).
//
// # Text(Offset(...))
//
// Pixels specifies an amount by which the text's baseline should be offset
// vertically from the baseline of the overall line, in pixels. For example, a
// positive offset can be used for superscripts and a negative offset can be used
// for subscripts. Pixels may have any of the standard forms for screen
// distances.
//
// # Text(Overstrike(...))
//
// Specifies whether or not to draw a horizontal rule through the middle of
// characters. Boolean may have any of the forms accepted by
// Tcl_GetBoolean.
//
// # Text(Overstrikefg(...))
//
// Color specifies the color to use when displaying the overstrike. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
//
// # Text(Relief(...))
//
// Relief specifies the relief style to use for drawing the border, in any
// of the forms accepted by Tk_GetRelief. This option is used in
// conjunction with the -borderwidth option to enable to the desired
// border appearance.
//
// # Text(Rmargin(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then pixels specifies how wide a margin to
// leave between the end of the line and the right edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled. If a text line wraps, the right
// margin for each line on the display is determined by the first non-elided
// character of that display line.
//
// # Text(Rmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -rmargin. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// used is specified by the -background tag option (or, if this is also
// unspecified, by the -background widget option).
//
// # Text(Selectbackground(...))
//
// Color specifies the background color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -background tag option is
// used.
//
// # Text(Selectforeground(...))
//
// Color specifies the foreground color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -foreground tag option is
// used.
//
// # Text(Spacing1(...))
//
// Pixels specifies how much additional space should be left above each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the first line on the display.
//
// # Text(Spacing2(...))
//
// For lines that wrap, this option specifies how much additional space to leave
// between the display lines for a single text line. Pixels may have any of
// the standard forms for screen distances.
//
// # Text(Spacing3(...))
//
// Pixels specifies how much additional space should be left below each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the last line on the display.
//
// # Text(Tabs(...))
//
// TabList specifies a set of tab stops in the same form as for the
// -tabs option for the text widget. This option only applies to a display
// line if it applies to the first non-elided character on that display line. If
// this option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default). If the option is specified as a
// non-empty string that is an empty list, such as -tags\0{\0}, then it
// requests default 8-character tabs as described for the -tags widget
// option.
//
// # Text(Tabstyle(...))
//
// Style specifies either the tabular or wordprocessor style of
// tabbing to use for the text widget. This option only applies to a display line
// if it applies to the first non-elided character on that display line. If this
// option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default).
//
// # Text(Underline(...))
//
// Boolean specifies whether or not to draw an underline underneath
// characters. It may have any of the forms accepted by Tcl_GetBoolean.
//
// # Text(Underlinefg(...))
//
// Color specifies the color to use when displaying the underline. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
//
// # Text(Wrap(...))
//
// Mode specifies how to handle lines that are wider than the text's
// window. This option only applies to a display line if it applies to the
// first non-elided character on that display line. It has the same legal
// values as the -wrap option for the text widget: none,
// char, or word. If this tag option is specified, it
// overrides the -wrap option for the text widget.
//
// # Text(Align(...))
//
// If the window is not as tall as the line in which it is displayed, this option
// determines where the window is displayed in the line. Where must have
// one of the values top (align the top of the window with the top of the
// line), center (center the window within the range of the line),
// bottom (align the bottom of the window with the bottom of the line's
// area), or baseline (align the bottom of the window with the baseline of
// the line).
//
// # Text(Create(...))
//
// Specifies a Tcl script that may be evaluated to create the window for the
// annotation. If no -window option has been specified for the annotation
// this script will be evaluated when the annotation is about to be displayed on
// the screen. Script must create a window for the annotation and return
// the name of that window as its result. Two substitutions will be performed in
// script before evaluation. %W will be substituted by the name of
// the parent text widget, and %% will be substituted by a single %.
// If the annotation's window should ever be deleted, script will be
// evaluated again the next time the annotation is displayed.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded window. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded window. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(Stretch(...))
//
// If the requested height of the embedded window is less than the height of the
// line in which it is displayed, this option can be used to specify whether the
// window should be stretched vertically to fill its line. If the -pady
// option has been specified as well, then the requested padding will be retained
// even if the window is stretched.
//
// # Text(Window(...))
//
// Specifies the name of a window to display in the annotation. Note that if a
// pathName has been set, then later configuring a window to the empty
// string will not delete the widget corresponding to the old pathName.
// Rather it will remove the association between the old pathName and the
// text widget. If multiple peer widgets are in use, it is usually simpler to use
// the -create option if embedded windows are desired in each peer.
//
// # Text(Align(...))
//
// If the image is not as tall as the line in which it is displayed, this option
// determines where the image is displayed in the line. Where must have one
// of the values top (align the top of the image with the top of the line),
// center (center the image within the range of the line), bottom
// (align the bottom of the image with the bottom of the line's area), or
// baseline (align the bottom of the image with the baseline of the line).
//
// # Text(Image(...))
//
// Specifies the name of the Tk image to display in the annotation. If
// image is not a valid Tk image, then an error is returned.
//
// # Text(Name(...))
//
// Specifies the name by which this image instance may be referenced in the text
// widget. If ImageName is not supplied, then the name of the Tk image is
// used instead. If the imageName is already in use, #nn is appended
// to the end of the name as described above.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded image. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded image. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(All(...))
//
// Return information about all elements: text, marks, tags, images and windows.
// This is the default.
//
// # Text(Command(...))
//
// Instead of returning the information as the result of the dump operation,
// invoke the command on each element of the text widget within the range.
// The command has three arguments appended to it before it is evaluated: the
// key, value, and index.
//
// # Text(Image(...))
//
// Include information about images in the dump results.
//
// # Text(Mark(...))
//
// Include information about marks in the dump results.
//
// # Text(Tag(...))
//
// Include information about tag transitions in the dump results. Tag information
// is returned as tagon and tagoff elements that indicate the begin
// and end of each range of each tag, respectively.
//
// # Text(Text(...))
//
// Include information about text in the dump results. The value is the text up
// to the next element or the end of range indicated by index2. A text
// element does not span newlines. A multi-line block of text that contains no
// marks or tag transitions will still be dumped as a set of text segments that
// each end with a newline. The newline is part of the value.
//
// # Text(Window(...))
//
// Include information about embedded windows in the dump results. The value of a
// window is its Tk pathname, unless the window has not been created yet. (It
// must have a create script.) In this case an empty string is returned, and you
// must query the window by its index position to get more information.
//
// # Text(Forwards(...))
//
// The search will proceed forward through the text, finding the first matching
// range starting at or after the position given by index. This is the
// default.
//
// # Text(Backwards(...))
//
// The search will proceed backward through the text, finding the matching range
// closest to index whose first character is before index (it is not
// allowed to be at index). Note that, for a variety of reasons, backwards
// searches can be substantially slower than forwards searches (particularly when
// using -regexp), so it is recommended that performance-critical code use
// forward searches.
//
// # Text(Exact(...))
//
// Use exact matching: the characters in the matching range must be identical to
// those in pattern. This is the default.
//
// # Text(Regexp(...))
//
// Treat pattern as a regular expression and match it against the text
// using the rules for regular expressions (see the regexp command
// and the re_syntax page for
// details). The default matching automatically passes both the
// -lineanchor and -linestop options to the regexp engine (unless
// -nolinestop is used), so that ^$ match beginning and end of line,
// and ., [^ sequences will never match the newline character
// \en.
//
// # Text(Nolinestop(...))
//
// This allows . and [^ sequences to match the newline character
// \en, which they will otherwise not do (see the regexp command for
// details). This option is only meaningful if -regexp is also given, and
// an error will be thrown otherwise. For example, to match the entire text, use
//
// # Text(Nocase(...))
//
// Ignore case differences between the pattern and the text.
//
// # Text(Count(...))
//
// The argument following -count gives the name of a variable; if a match
// is found, the number of index positions between beginning and end of the
// matching range will be stored in the variable. If there are no embedded images
// or windows in the matching range (and there are no elided characters if
// -elide is not given), this is equivalent to the number of characters
// matched. In either case, the range matchIdx to matchIdx + $count
// chars will return the entire matched text.
//
// # Text(All(...))
//
// Find all matches in the given range and return a list of the indices of the
// first character of each match. If a -count varName switch is given,
// then varName is also set to a list containing one element for each
// successful match. Note that, even for exact searches, the elements of this
// list may be different, if there are embedded images, windows or hidden text.
// Searches with -all behave very similarly to the Tcl command regexp
// -all, in that overlapping matches are not normally returned. For example,
// applying an -all search of the pattern
//
// # Text(Overlap(...))
//
// When performing -all searches, the normal behaviour is that matches
// which overlap an already-found match will not be returned. This switch changes
// that behaviour so that all matches which are not totally enclosed within
// another match are returned. For example, applying an -overlap search of
// the pattern
//
// # Text(Strictlimits(...))
//
// When performing any search, the normal behaviour is that the start and stop
// limits are checked with respect to the start of the matching text. With the
// -strictlimits flag, the entire matching range must lie inside the start
// and stop limits specified for the match to be valid.
//
// # Text(Elide(...))
//
// Find elided (hidden) text as well. By default only displayed text is searched.
//
// # Text(-(...))
//
// This switch has no effect except to terminate the list of switches: the next
// argument will be treated as pattern even if it starts with -.
//
// # Description
//
// The text command creates a new window (given by the pathName
// argument) and makes it into a text widget. Additional options, described
// above, may be specified on the command line or in the option database to
// configure aspects of the text such as its default background color and relief.
// The text command returns the path name of the new window.
//
// A text widget displays one or more lines of text and allows that text to be
// edited. Text widgets support four different kinds of annotations on the text,
// called tags, marks, embedded windows or embedded images. Tags allow different
// portions of the text to be displayed with different fonts and colors. In
// addition, Tcl commands can be associated with tags so that scripts are invoked
// when particular actions such as keystrokes and mouse button presses occur in
// particular ranges of the text. See TAGS below for more details.
//
// # The second form of annotation consists of floating markers in the text called
//
// Marks are used to keep track of various interesting positions in the text as
// it is edited. See MARKS below for more details.
//
// The third form of annotation allows arbitrary windows to be embedded in a text
// widget. See EMBEDDED WINDOWS below for more details.
//
// The fourth form of annotation allows Tk images to be embedded in a text
// widget. See EMBEDDED IMAGES below for more details.
//
// The text widget also has a built-in undo/redo mechanism. See
// THE UNDO MECHANISM below for more details.
//
// The text widget allows for the creation of peer widgets. These are other text
// widgets which share the same underlying data (text, marks, tags, images, etc).
// See PEER WIDGETS below for more details.
//
// Additional information might be available at the [Tcl/Tk text] page.
//
// [Tcl/Tk text]: https://www.tcl.tk/man/tcl9.0/TkCmd/text.html
func Text(options ...option) *Window {
	return App.Text(options...)
}

// toplevel - Create and manipulate 'toplevel' main and popup window widgets
//
// # Toplevel(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Toplevel(Backgroundimage(...))
//
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
//
// # Toplevel(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Toplevel(Menu(...))
//
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
//
// # Toplevel(Screen(...))
//
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Tile(...))
//
//	"8.7, TIP262"
//
// # Toplevel(Use(...))
//
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Description
//
// The toplevel command creates a new toplevel widget (given
// by the pathName argument).  Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the toplevel such as its background color
// and relief.  The toplevel command returns the
// path name of the new window.
//
// A toplevel is similar to a frame except that it is created as a
// top-level window:  its X parent is the root window of a screen
// rather than the logical parent from its Tk path name.  The primary
// purpose of a toplevel is to serve as a container for dialog boxes
// and other collections of widgets.  The only visible features
// of a toplevel are its background and an optional 3-D border
// to make the toplevel appear raised or sunken.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk toplevel] page.
//
// [Tcl/Tk toplevel]: https://www.tcl.tk/man/tcl9.0/TkCmd/toplevel.html
func (w *Window) Toplevel(options ...option) *Window {
	return w.newChild("toplevel", options...)
}

// toplevel - Create and manipulate 'toplevel' main and popup window widgets
//
// # Toplevel(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Toplevel(Backgroundimage(...))
//
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
//
// # Toplevel(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Toplevel(Menu(...))
//
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
//
// # Toplevel(Screen(...))
//
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Tile(...))
//
//	"8.7, TIP262"
//
// # Toplevel(Use(...))
//
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Description
//
// The toplevel command creates a new toplevel widget (given
// by the pathName argument).  Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the toplevel such as its background color
// and relief.  The toplevel command returns the
// path name of the new window.
//
// A toplevel is similar to a frame except that it is created as a
// top-level window:  its X parent is the root window of a screen
// rather than the logical parent from its Tk path name.  The primary
// purpose of a toplevel is to serve as a container for dialog boxes
// and other collections of widgets.  The only visible features
// of a toplevel are its background and an optional 3-D border
// to make the toplevel appear raised or sunken.
//
// Additional information might be available at the [Tcl/Tk toplevel] page.
//
// [Tcl/Tk toplevel]: https://www.tcl.tk/man/tcl9.0/TkCmd/toplevel.html
func Toplevel(options ...option) *Window {
	return App.Toplevel(options...)
}

// ttk::button - Widget that issues a command when pressed
//
// # TButton(Command(...))
//
// A script to evaluate when the widget is invoked.
//
// # TButton(Default(...))
//
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
//
// # Description
//
// A ttk::button widget displays a textual label and/or image,
// and evaluates a command when pressed.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_button] page.
//
// [Tcl/Tk ttk_button]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_button.html
func (w *Window) TButton(options ...option) *Window {
	return w.newChild("ttk_button", options...)
}

// ttk::button - Widget that issues a command when pressed
//
// # TButton(Command(...))
//
// A script to evaluate when the widget is invoked.
//
// # TButton(Default(...))
//
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
//
// # Description
//
// A ttk::button widget displays a textual label and/or image,
// and evaluates a command when pressed.
//
// Additional information might be available at the [Tcl/Tk ttk_button] page.
//
// [Tcl/Tk ttk_button]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_button.html
func TButton(options ...option) *Window {
	return App.TButton(options...)
}

// ttk::checkbutton - On/off widget
//
// # TCheckbutton(Command(...))
//
// A Tcl script to execute whenever the widget is invoked.
//
// # TCheckbutton(Offvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
//
// # TCheckbutton(Onvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
//
// # TCheckbutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
//
// # Description
//
// A ttk::checkbutton widget is used to show or change a setting.
// It has two states, selected and deselected.
// The state of the checkbutton may be linked to a Tcl variable.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_checkbutton] page.
//
// [Tcl/Tk ttk_checkbutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_checkbutton.html
func (w *Window) TCheckbutton(options ...option) *Window {
	return w.newChild("ttk_checkbutton", options...)
}

// ttk::checkbutton - On/off widget
//
// # TCheckbutton(Command(...))
//
// A Tcl script to execute whenever the widget is invoked.
//
// # TCheckbutton(Offvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
//
// # TCheckbutton(Onvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
//
// # TCheckbutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
//
// # Description
//
// A ttk::checkbutton widget is used to show or change a setting.
// It has two states, selected and deselected.
// The state of the checkbutton may be linked to a Tcl variable.
//
// Additional information might be available at the [Tcl/Tk ttk_checkbutton] page.
//
// [Tcl/Tk ttk_checkbutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_checkbutton.html
func TCheckbutton(options ...option) *Window {
	return App.TCheckbutton(options...)
}

// ttk::combobox - text field with popdown selection list
//
// # TCombobox(Exportselection(...))
//
// Boolean value.
// If set, the widget selection is linked to the X selection.
//
// # TCombobox(Justify(...))
//
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
//
// # TCombobox(Height(...))
//
// Specifies the height of the pop-down listbox, in rows.
//
// # TCombobox(Postcommand(...))
//
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
//
// # TCombobox(State(...))
//
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
//
// # TCombobox(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
//
// # TCombobox(Values(...))
//
// Specifies the list of values to display in the drop-down listbox.
//
// # TCombobox(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # Description
//
// A ttk::combobox combines a text field with a pop-down list of values;
// the user may select the value of the text field from among the
// values in the list.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_combobox] page.
//
// [Tcl/Tk ttk_combobox]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_combobox.html
func (w *Window) TCombobox(options ...option) *Window {
	return w.newChild("ttk_combobox", options...)
}

// ttk::combobox - text field with popdown selection list
//
// # TCombobox(Exportselection(...))
//
// Boolean value.
// If set, the widget selection is linked to the X selection.
//
// # TCombobox(Justify(...))
//
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
//
// # TCombobox(Height(...))
//
// Specifies the height of the pop-down listbox, in rows.
//
// # TCombobox(Postcommand(...))
//
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
//
// # TCombobox(State(...))
//
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
//
// # TCombobox(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
//
// # TCombobox(Values(...))
//
// Specifies the list of values to display in the drop-down listbox.
//
// # TCombobox(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # Description
//
// A ttk::combobox combines a text field with a pop-down list of values;
// the user may select the value of the text field from among the
// values in the list.
//
// Additional information might be available at the [Tcl/Tk ttk_combobox] page.
//
// [Tcl/Tk ttk_combobox]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_combobox.html
func TCombobox(options ...option) *Window {
	return App.TCombobox(options...)
}

// ttk::entry - Editable text field widget
//
// # TEntry(Exportselection(...))
//
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
//
// # TEntry(Invalidcommand(...))
//
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
//
// # TEntry(Justify(...))
//
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
//
// # TEntry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TEntry(State(...))
//
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
//
// # TEntry(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
//
// # TEntry(Validate(...))
//
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
//
// # TEntry(Validatecommand(...))
//
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
//
// # TEntry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # Description
//
// An ttk::entry widget displays a one-line text string and
// allows that string to be edited by the user.
// The value of the string may be linked to a Tcl variable
// with the -textvariable option.
// Entry widgets support horizontal scrolling with the
// standard -xscrollcommand option and xview widget command.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_entry] page.
//
// [Tcl/Tk ttk_entry]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_entry.html
func (w *Window) TEntry(options ...option) *Window {
	return w.newChild("ttk_entry", options...)
}

// ttk::entry - Editable text field widget
//
// # TEntry(Exportselection(...))
//
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
//
// # TEntry(Invalidcommand(...))
//
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
//
// # TEntry(Justify(...))
//
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
//
// # TEntry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TEntry(State(...))
//
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
//
// # TEntry(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
//
// # TEntry(Validate(...))
//
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
//
// # TEntry(Validatecommand(...))
//
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
//
// # TEntry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # Description
//
// An ttk::entry widget displays a one-line text string and
// allows that string to be edited by the user.
// The value of the string may be linked to a Tcl variable
// with the -textvariable option.
// Entry widgets support horizontal scrolling with the
// standard -xscrollcommand option and xview widget command.
//
// Additional information might be available at the [Tcl/Tk ttk_entry] page.
//
// [Tcl/Tk ttk_entry]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_entry.html
func TEntry(options ...option) *Window {
	return App.TEntry(options...)
}

// ttk::frame - Simple container widget
//
// # TFrame(Borderwidth(...))
//
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
//
// # TFrame(Relief(...))
//
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
//
// # TFrame(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TFrame(Height(...))
//
// If specified, the widget's requested height in pixels.
//
// # Description
//
// A ttk::frame widget is a container, used to group other widgets
// together.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_frame] page.
//
// [Tcl/Tk ttk_frame]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_frame.html
func (w *Window) TFrame(options ...option) *Window {
	return w.newChild("ttk_frame", options...)
}

// ttk::frame - Simple container widget
//
// # TFrame(Borderwidth(...))
//
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
//
// # TFrame(Relief(...))
//
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
//
// # TFrame(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TFrame(Height(...))
//
// If specified, the widget's requested height in pixels.
//
// # Description
//
// A ttk::frame widget is a container, used to group other widgets
// together.
//
// Additional information might be available at the [Tcl/Tk ttk_frame] page.
//
// [Tcl/Tk ttk_frame]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_frame.html
func TFrame(options ...option) *Window {
	return App.TFrame(options...)
}

// ttk::label - Display a text string and/or image
//
// # TLabel(Background(...))
//
// The widget's background color.
// If unspecified, the theme default is used.
//
// # TLabel(Relief(...))
//
// \" Rewrite this:
//
// # TLabel(Wraplength(...))
//
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
//
// # Description
//
// A ttk::label widget displays a textual label and/or image.
// The label may be linked to a Tcl variable
// to automatically change the displayed text.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_label] page.
//
// [Tcl/Tk ttk_label]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_label.html
func (w *Window) TLabel(options ...option) *Window {
	return w.newChild("ttk_label", options...)
}

// ttk::label - Display a text string and/or image
//
// # TLabel(Background(...))
//
// The widget's background color.
// If unspecified, the theme default is used.
//
// # TLabel(Relief(...))
//
// \" Rewrite this:
//
// # TLabel(Wraplength(...))
//
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
//
// # Description
//
// A ttk::label widget displays a textual label and/or image.
// The label may be linked to a Tcl variable
// to automatically change the displayed text.
//
// Additional information might be available at the [Tcl/Tk ttk_label] page.
//
// [Tcl/Tk ttk_label]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_label.html
func TLabel(options ...option) *Window {
	return App.TLabel(options...)
}

// ttk::labelframe - Container widget with optional label
//
// # TLabelframe(Height(...))
//
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
//
// # TLabelframe(Labelanchor(...))
//
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
//
// # TLabelframe(Labelwidget(...))
//
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe”s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
//
// # TLabelframe(Text(...))
//
// Specifies the text of the label.
//
// # TLabelframe(Underline(...))
//
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
//
// # TLabelframe(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # Description
//
// A ttk::labelframe widget is a container used to group other widgets
// together.  It has an optional label, which may be a plain text string or
// another widget.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_labelframe] page.
//
// [Tcl/Tk ttk_labelframe]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_labelframe.html
func (w *Window) TLabelframe(options ...option) *Window {
	return w.newChild("ttk_labelframe", options...)
}

// ttk::labelframe - Container widget with optional label
//
// # TLabelframe(Height(...))
//
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
//
// # TLabelframe(Labelanchor(...))
//
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
//
// # TLabelframe(Labelwidget(...))
//
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe”s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
//
// # TLabelframe(Text(...))
//
// Specifies the text of the label.
//
// # TLabelframe(Underline(...))
//
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
//
// # TLabelframe(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # Description
//
// A ttk::labelframe widget is a container used to group other widgets
// together.  It has an optional label, which may be a plain text string or
// another widget.
//
// Additional information might be available at the [Tcl/Tk ttk_labelframe] page.
//
// [Tcl/Tk ttk_labelframe]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_labelframe.html
func TLabelframe(options ...option) *Window {
	return App.TLabelframe(options...)
}

// ttk::menubutton - Widget that pops down a menu when pressed
//
// # TMenubutton(Direction(...))
//
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
//
// # TMenubutton(Menu(...))
//
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
//
// # Description
//
// A ttk::menubutton widget displays a textual label and/or image,
// and displays a menu when pressed.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_menubutton] page.
//
// [Tcl/Tk ttk_menubutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_menubutton.html
func (w *Window) TMenubutton(options ...option) *Window {
	return w.newChild("ttk_menubutton", options...)
}

// ttk::menubutton - Widget that pops down a menu when pressed
//
// # TMenubutton(Direction(...))
//
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
//
// # TMenubutton(Menu(...))
//
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
//
// # Description
//
// A ttk::menubutton widget displays a textual label and/or image,
// and displays a menu when pressed.
//
// Additional information might be available at the [Tcl/Tk ttk_menubutton] page.
//
// [Tcl/Tk ttk_menubutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_menubutton.html
func TMenubutton(options ...option) *Window {
	return App.TMenubutton(options...)
}

// ttk::notebook - Multi-paned container widget
//
// # TNotebook(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
//
// # TNotebook(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
//
// # TNotebook(State(...))
//
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
//
// # TNotebook(Sticky(...))
//
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
//
// # TNotebook(Text(...))
//
// Specifies a string to be displayed in the tab.
//
// # TNotebook(Image(...))
//
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
//
// # TNotebook(Compound(...))
//
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
//
// # TNotebook(Underline(...))
//
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
//
// # Description
//
// A ttk::notebook widget manages a collection of windows
// and displays a single one at a time.
// Each content window is associated with a tab,
// which the user may select to change the currently-displayed window.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_notebook] page.
//
// [Tcl/Tk ttk_notebook]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_notebook.html
func (w *Window) TNotebook(options ...option) *Window {
	return w.newChild("ttk_notebook", options...)
}

// ttk::notebook - Multi-paned container widget
//
// # TNotebook(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
//
// # TNotebook(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
//
// # TNotebook(State(...))
//
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
//
// # TNotebook(Sticky(...))
//
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
//
// # TNotebook(Text(...))
//
// Specifies a string to be displayed in the tab.
//
// # TNotebook(Image(...))
//
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
//
// # TNotebook(Compound(...))
//
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
//
// # TNotebook(Underline(...))
//
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
//
// # Description
//
// A ttk::notebook widget manages a collection of windows
// and displays a single one at a time.
// Each content window is associated with a tab,
// which the user may select to change the currently-displayed window.
//
// Additional information might be available at the [Tcl/Tk ttk_notebook] page.
//
// [Tcl/Tk ttk_notebook]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_notebook.html
func TNotebook(options ...option) *Window {
	return App.TNotebook(options...)
}

// ttk::panedwindow - Multi-pane container window
//
// # TPanedwindow(Orient(...))
//
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
//
// # TPanedwindow(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
//
// # TPanedwindow(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
//
// # TPanedwindow(Weight(...))
//
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
//
// # Description
//
// A ttk::panedwindow widget displays a number of subwindows,
// stacked either vertically or horizontally.
// The user may adjust the relative sizes of the subwindows
// by dragging the sash between panes.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_panedwindow] page.
//
// [Tcl/Tk ttk_panedwindow]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_panedwindow.html
func (w *Window) TPanedwindow(options ...option) *Window {
	return w.newChild("ttk_panedwindow", options...)
}

// ttk::panedwindow - Multi-pane container window
//
// # TPanedwindow(Orient(...))
//
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
//
// # TPanedwindow(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
//
// # TPanedwindow(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
//
// # TPanedwindow(Weight(...))
//
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
//
// # Description
//
// A ttk::panedwindow widget displays a number of subwindows,
// stacked either vertically or horizontally.
// The user may adjust the relative sizes of the subwindows
// by dragging the sash between panes.
//
// Additional information might be available at the [Tcl/Tk ttk_panedwindow] page.
//
// [Tcl/Tk ttk_panedwindow]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_panedwindow.html
func TPanedwindow(options ...option) *Window {
	return App.TPanedwindow(options...)
}

// ttk::progressbar - Provide progress feedback
//
// # TProgressbar(Length(...))
//
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
//
// # TProgressbar(Maximum(...))
//
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
//
// # TProgressbar(Mode(...))
//
// One of 'determinate' or 'indeterminate'.
//
// # TProgressbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
//
// # TProgressbar(Phase(...))
//
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
//
// # TProgressbar(Value(...))
//
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
//
// # TProgressbar(Variable(...))
//
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
//
// # Description
//
// A ttk::progressbar widget shows the status of a long-running
// operation.  They can operate in two modes: determinate mode shows the
// amount completed relative to the total amount of work to be done, and
// indeterminate mode provides an animated display to let the user know
// that something is happening.
//
// If the value of -orient is horizontal a text string can be
// displayed inside the progressbar. This string can be configured using
// the -anchor, -font, -foreground, -justify,
// -text and -wraplength options. If the value of -orient
// is vertical then these options are ignored.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_progressbar] page.
//
// [Tcl/Tk ttk_progressbar]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_progressbar.html
func (w *Window) TProgressbar(options ...option) *Window {
	return w.newChild("ttk_progressbar", options...)
}

// ttk::progressbar - Provide progress feedback
//
// # TProgressbar(Length(...))
//
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
//
// # TProgressbar(Maximum(...))
//
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
//
// # TProgressbar(Mode(...))
//
// One of 'determinate' or 'indeterminate'.
//
// # TProgressbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
//
// # TProgressbar(Phase(...))
//
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
//
// # TProgressbar(Value(...))
//
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
//
// # TProgressbar(Variable(...))
//
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
//
// # Description
//
// A ttk::progressbar widget shows the status of a long-running
// operation.  They can operate in two modes: determinate mode shows the
// amount completed relative to the total amount of work to be done, and
// indeterminate mode provides an animated display to let the user know
// that something is happening.
//
// If the value of -orient is horizontal a text string can be
// displayed inside the progressbar. This string can be configured using
// the -anchor, -font, -foreground, -justify,
// -text and -wraplength options. If the value of -orient
// is vertical then these options are ignored.
//
// Additional information might be available at the [Tcl/Tk ttk_progressbar] page.
//
// [Tcl/Tk ttk_progressbar]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_progressbar.html
func TProgressbar(options ...option) *Window {
	return App.TProgressbar(options...)
}

// ttk::radiobutton - Mutually exclusive option widget
//
// # TRadiobutton(Command(...))
//
// A Tcl script to evaluate whenever the widget is invoked.
//
// # TRadiobutton(Value(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.
//
// # TRadiobutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
//
// # Description
//
// ttk::radiobutton widgets are used in groups to show or change
// a set of mutually-exclusive options.
// Radiobuttons are linked to a Tcl variable,
// and have an associated value; when a radiobutton is clicked,
// it sets the variable to its associated value.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_radiobutton] page.
//
// [Tcl/Tk ttk_radiobutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_radiobutton.html
func (w *Window) TRadiobutton(options ...option) *Window {
	return w.newChild("ttk_radiobutton", options...)
}

// ttk::radiobutton - Mutually exclusive option widget
//
// # TRadiobutton(Command(...))
//
// A Tcl script to evaluate whenever the widget is invoked.
//
// # TRadiobutton(Value(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.
//
// # TRadiobutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
//
// # Description
//
// ttk::radiobutton widgets are used in groups to show or change
// a set of mutually-exclusive options.
// Radiobuttons are linked to a Tcl variable,
// and have an associated value; when a radiobutton is clicked,
// it sets the variable to its associated value.
//
// Additional information might be available at the [Tcl/Tk ttk_radiobutton] page.
//
// [Tcl/Tk ttk_radiobutton]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_radiobutton.html
func TRadiobutton(options ...option) *Window {
	return App.TRadiobutton(options...)
}

// ttk::scale - Create and manipulate a scale widget
//
// # TScale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
//
// # TScale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # TScale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
//
// # TScale(Orient(...))
//
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
//
// # TScale(To(...))
//
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # TScale(Value(...))
//
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
//
// # TScale(Variable(...))
//
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
//
// # Description
//
// A ttk::scale widget is typically used to control the numeric value of a
// linked variable that varies uniformly over some range. A scale displays a
// slider that can be moved along over a trough, with the relative
// position of the slider over the trough indicating the value of the variable.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_scale] page.
//
// [Tcl/Tk ttk_scale]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_scale.html
func (w *Window) TScale(options ...option) *Window {
	return w.newChild("ttk_scale", options...)
}

// ttk::scale - Create and manipulate a scale widget
//
// # TScale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
//
// # TScale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # TScale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
//
// # TScale(Orient(...))
//
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
//
// # TScale(To(...))
//
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # TScale(Value(...))
//
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
//
// # TScale(Variable(...))
//
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
//
// # Description
//
// A ttk::scale widget is typically used to control the numeric value of a
// linked variable that varies uniformly over some range. A scale displays a
// slider that can be moved along over a trough, with the relative
// position of the slider over the trough indicating the value of the variable.
//
// Additional information might be available at the [Tcl/Tk ttk_scale] page.
//
// [Tcl/Tk ttk_scale]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_scale.html
func TScale(options ...option) *Window {
	return App.TScale(options...)
}

// ttk::scrollbar - Control the viewport of a scrollable widget
//
// # TScrollbar(Command(...))
//
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
//
// # TScrollbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
//
// # Description
//
// ttk::scrollbar widgets are typically linked to an associated window
// that displays a document of some sort, such as a file being edited or a
// drawing.
// A scrollbar displays a thumb in the middle portion of the scrollbar,
// whose position and size provides information about the portion of the
// document visible in the associated window.
// The thumb may be dragged by the user to control the visible region.
// Depending on the theme, two or more arrow buttons may also be present;
// these are used to scroll the visible region in discrete units.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_scrollbar] page.
//
// [Tcl/Tk ttk_scrollbar]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_scrollbar.html
func (w *Window) TScrollbar(options ...option) *Window {
	return w.newChild("ttk_scrollbar", options...)
}

// ttk::scrollbar - Control the viewport of a scrollable widget
//
// # TScrollbar(Command(...))
//
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
//
// # TScrollbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
//
// # Description
//
// ttk::scrollbar widgets are typically linked to an associated window
// that displays a document of some sort, such as a file being edited or a
// drawing.
// A scrollbar displays a thumb in the middle portion of the scrollbar,
// whose position and size provides information about the portion of the
// document visible in the associated window.
// The thumb may be dragged by the user to control the visible region.
// Depending on the theme, two or more arrow buttons may also be present;
// these are used to scroll the visible region in discrete units.
//
// Additional information might be available at the [Tcl/Tk ttk_scrollbar] page.
//
// [Tcl/Tk ttk_scrollbar]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_scrollbar.html
func TScrollbar(options ...option) *Window {
	return App.TScrollbar(options...)
}

// ttk::separator - Separator bar
//
// # TSeparator(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
//
// # Description
//
// A ttk::separator widget displays a horizontal or vertical separator
// bar.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_separator] page.
//
// [Tcl/Tk ttk_separator]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_separator.html
func (w *Window) TSeparator(options ...option) *Window {
	return w.newChild("ttk_separator", options...)
}

// ttk::separator - Separator bar
//
// # TSeparator(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
//
// # Description
//
// A ttk::separator widget displays a horizontal or vertical separator
// bar.
//
// Additional information might be available at the [Tcl/Tk ttk_separator] page.
//
// [Tcl/Tk ttk_separator]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_separator.html
func TSeparator(options ...option) *Window {
	return App.TSeparator(options...)
}

// ttk::sizegrip - Bottom-right corner resize widget
//
// A ttk::sizegrip widget (also known as a grow box)
// allows the user to resize the containing toplevel window
// by pressing and dragging the grip.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_sizegrip] page.
//
// [Tcl/Tk ttk_sizegrip]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_sizegrip.html
func (w *Window) TSizegrip(options ...option) *Window {
	return w.newChild("ttk_sizegrip", options...)
}

// ttk::sizegrip - Bottom-right corner resize widget
//
// A ttk::sizegrip widget (also known as a grow box)
// allows the user to resize the containing toplevel window
// by pressing and dragging the grip.
//
// Additional information might be available at the [Tcl/Tk ttk_sizegrip] page.
//
// [Tcl/Tk ttk_sizegrip]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_sizegrip.html
func TSizegrip(options ...option) *Window {
	return App.TSizegrip(options...)
}

// ttk::spinbox - Selecting text field widget
//
// # TSpinbox(Command(...))
//
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
//
// # TSpinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # TSpinbox(From(...))
//
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
//
// # TSpinbox(Increment(...))
//
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
//
// # TSpinbox(To(...))
//
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
//
// # TSpinbox(Values(...))
//
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
//
// # TSpinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Description
//
// A ttk::spinbox widget is a ttk::entry widget with built-in
// up and down buttons that are used to either modify a numeric value or
// to select among a set of values. The widget implements all the features
// of the ttk::entry widget including support of the
// -textvariable option to link the value displayed by the widget
// to a Tcl variable.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_spinbox] page.
//
// [Tcl/Tk ttk_spinbox]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_spinbox.html
func (w *Window) TSpinbox(options ...option) *Window {
	return w.newChild("ttk_spinbox", options...)
}

// ttk::spinbox - Selecting text field widget
//
// # TSpinbox(Command(...))
//
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
//
// # TSpinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # TSpinbox(From(...))
//
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
//
// # TSpinbox(Increment(...))
//
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
//
// # TSpinbox(To(...))
//
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
//
// # TSpinbox(Values(...))
//
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
//
// # TSpinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Description
//
// A ttk::spinbox widget is a ttk::entry widget with built-in
// up and down buttons that are used to either modify a numeric value or
// to select among a set of values. The widget implements all the features
// of the ttk::entry widget including support of the
// -textvariable option to link the value displayed by the widget
// to a Tcl variable.
//
// Additional information might be available at the [Tcl/Tk ttk_spinbox] page.
//
// [Tcl/Tk ttk_spinbox]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_spinbox.html
func TSpinbox(options ...option) *Window {
	return App.TSpinbox(options...)
}

// ttk::treeview - hierarchical multicolumn data display widget
//
// # TTreeview(Columns(...))
//
// A list of column identifiers,
// specifying the number of columns and their names.
//
// # TTreeview(Displaycolumns(...))
//
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
//
// # TTreeview(Height(...))
//
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
//
// # TTreeview(Selectmode(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
//
// # TTreeview(Selecttype(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
//
// # TTreeview(Show(...))
//
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
//
// # TTreeview(Striped(...))
//
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
//
// # TTreeview(Titlecolumns(...))
//
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
//
// # TTreeview(Titleitems(...))
//
// Number of items at the top that should not be vertically scrolled. Default is 0.
//
// # TTreeview(Id(...))
//
// The column name.  This is a read-only option.
// For example, [$pathname column #n -id]
// returns the data column associated with display column n.
// The tree column has -id #0.
//
// # TTreeview(Anchor(...))
//
// Specifies how the text in this column should be aligned
// with respect to the cell. Anchor is one of
// n, ne, e, se,
// s, sw, w, nw, or center.
//
// # TTreeview(Minwidth(...))
//
// The minimum width of the column in pixels.
// The treeview widget will not make the column any smaller than
// -minwidth when the widget is resized or the user drags a
// heading column separator.  Default is 20 pixels.
//
// # TTreeview(Separator(...))
//
// Specifies whether or not a column separator should be drawn to the right
// of the column.  Default is false.
//
// # TTreeview(Stretch(...))
//
// Specifies whether or not the column width should be adjusted
// when the widget is resized or the user drags a heading column separator.
// Boolean may have any of the forms accepted by Tcl_GetBoolean.
// By default columns are stretchable.
//
// # TTreeview(Width(...))
//
// The width of the column in pixels.  Default is 200 pixels. The specified
// column width may be changed by Tk in order to honor -stretch
// and/or -minwidth, or when the widget is resized or the user drags a
// heading column separator.
//
// # TTreeview(Text(...))
//
// The text to display in the column heading.
//
// # TTreeview(Image(...))
//
// Specifies an image to display to the right of the column heading.
//
// # TTreeview(Anchor(...))
//
// Specifies how the heading text should be aligned.
// One of the standard Tk anchor values.
//
// # TTreeview(Command(...))
//
// A script to evaluate when the heading label is pressed.
//
// # Description
//
// The ttk::treeview widget displays a hierarchical collection of items.
// Each item has a textual label, an optional image,
// and an optional list of data values.
// The data values are displayed in successive columns after
// the tree label.
//
// The order in which data values are displayed may be controlled
// by setting the -displaycolumns widget option.
// The tree widget can also display column headings.
// Columns may be accessed by number or by symbolic names
// listed in the -columns widget option;
// see COLUMN IDENTIFIERS.
//
// Each item is identified by a unique name.
// The widget will generate item IDs if they are not supplied by the caller.
// There is a distinguished root item, named {}.
// The root item itself is not displayed;
// its children appear at the top level of the hierarchy.
//
// Each item also has a list of tags,
// which can be used to associate event bindings with individual items
// and control the appearance of the item.
//
// Treeview widgets support horizontal and vertical scrolling with the
// standard -[xy]scrollcommand options
// and [xy]view widget commands.
//
// The resulting Window is a child of 'w'.
//
// Additional information might be available at the [Tcl/Tk ttk_treeview] page.
//
// [Tcl/Tk ttk_treeview]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_treeview.html
func (w *Window) TTreeview(options ...option) *Window {
	return w.newChild("ttk_treeview", options...)
}

// ttk::treeview - hierarchical multicolumn data display widget
//
// # TTreeview(Columns(...))
//
// A list of column identifiers,
// specifying the number of columns and their names.
//
// # TTreeview(Displaycolumns(...))
//
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
//
// # TTreeview(Height(...))
//
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
//
// # TTreeview(Selectmode(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
//
// # TTreeview(Selecttype(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
//
// # TTreeview(Show(...))
//
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
//
// # TTreeview(Striped(...))
//
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
//
// # TTreeview(Titlecolumns(...))
//
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
//
// # TTreeview(Titleitems(...))
//
// Number of items at the top that should not be vertically scrolled. Default is 0.
//
// # TTreeview(Id(...))
//
// The column name.  This is a read-only option.
// For example, [$pathname column #n -id]
// returns the data column associated with display column n.
// The tree column has -id #0.
//
// # TTreeview(Anchor(...))
//
// Specifies how the text in this column should be aligned
// with respect to the cell. Anchor is one of
// n, ne, e, se,
// s, sw, w, nw, or center.
//
// # TTreeview(Minwidth(...))
//
// The minimum width of the column in pixels.
// The treeview widget will not make the column any smaller than
// -minwidth when the widget is resized or the user drags a
// heading column separator.  Default is 20 pixels.
//
// # TTreeview(Separator(...))
//
// Specifies whether or not a column separator should be drawn to the right
// of the column.  Default is false.
//
// # TTreeview(Stretch(...))
//
// Specifies whether or not the column width should be adjusted
// when the widget is resized or the user drags a heading column separator.
// Boolean may have any of the forms accepted by Tcl_GetBoolean.
// By default columns are stretchable.
//
// # TTreeview(Width(...))
//
// The width of the column in pixels.  Default is 200 pixels. The specified
// column width may be changed by Tk in order to honor -stretch
// and/or -minwidth, or when the widget is resized or the user drags a
// heading column separator.
//
// # TTreeview(Text(...))
//
// The text to display in the column heading.
//
// # TTreeview(Image(...))
//
// Specifies an image to display to the right of the column heading.
//
// # TTreeview(Anchor(...))
//
// Specifies how the heading text should be aligned.
// One of the standard Tk anchor values.
//
// # TTreeview(Command(...))
//
// A script to evaluate when the heading label is pressed.
//
// # Description
//
// The ttk::treeview widget displays a hierarchical collection of items.
// Each item has a textual label, an optional image,
// and an optional list of data values.
// The data values are displayed in successive columns after
// the tree label.
//
// The order in which data values are displayed may be controlled
// by setting the -displaycolumns widget option.
// The tree widget can also display column headings.
// Columns may be accessed by number or by symbolic names
// listed in the -columns widget option;
// see COLUMN IDENTIFIERS.
//
// Each item is identified by a unique name.
// The widget will generate item IDs if they are not supplied by the caller.
// There is a distinguished root item, named {}.
// The root item itself is not displayed;
// its children appear at the top level of the hierarchy.
//
// Each item also has a list of tags,
// which can be used to associate event bindings with individual items
// and control the appearance of the item.
//
// Treeview widgets support horizontal and vertical scrolling with the
// standard -[xy]scrollcommand options
// and [xy]view widget commands.
//
// Additional information might be available at the [Tcl/Tk ttk_treeview] page.
//
// [Tcl/Tk ttk_treeview]: https://www.tcl.tk/man/tcl9.0/TkCmd/ttk_treeview.html
func TTreeview(options ...option) *Window {
	return App.TTreeview(options...)
}

type aboveOption struct{ v any }

func (o aboveOption) optionString(w *Window) string {
	return fmt.Sprintf(`-above %s`, optionString(o.v))
}

// # Event(Above(...))
//
// Window specifies the above field for the event,
// either as a window path name or as an integer window id.
// Valid for Configure events.
// Corresponds to the %a substitution for binding scripts.
func Above(value any) option {
	return aboveOption{value}
}

type acceleratorOption struct{ v any }

func (o acceleratorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-accelerator %s`, optionString(o.v))
}

// # Menu(Accelerator(...))
//
// Specifies a string to display at the right side of the menu entry.
// Normally describes an accelerator keystroke sequence that may be
// used to invoke the same function as the menu entry. This is a display
// option, it does not actually set the corresponding binding (which can
// be achieved using the bind command). This option is not available
// for separator or tear-off entries.
//
// # Menu(Accelerator(...))
//
// Specifies a string to display at the right side of the menu entry.
// Normally describes an accelerator keystroke sequence that may be
// used to invoke the same function as the menu entry. This is a display
// option, it does not actually set the corresponding binding (which can
// be achieved using the bind command). This option is not available
// for separator or tear-off entries.
func Accelerator(value any) option {
	return acceleratorOption{value}
}

type activebackgroundOption struct{ v any }

func (o activebackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activebackground %s`, optionString(o.v))
}

// Specifies background color to use when drawing active elements.
// An element (a widget or portion of a widget) is active if the
// mouse cursor is positioned over the element and pressing a mouse button
// will cause some action to occur.
// If strict Motif compliance has been requested by setting the
// 'tk_strictMotif' variable, this option will normally be
// ignored;  the normal background color will be used instead.
// For some elements on Windows and Macintosh systems, the active color
// will only be used while mouse button 1 is pressed over the element.
//
// # Canvas(Activebackground(...))
//
// # Canvas(Activebackground(...))
//
// # Menu(Activebackground(...))
//
// Specifies a background color to use for displaying this entry when it
// is active. This option is ignored on Aqua/MacOS.
// If it is specified as an empty string (the default), then the
// -activebackground option for the overall menu is used.
// If the tk_strictMotif variable has been set to request strict
// Motif compliance, then this option is ignored and the -background
// option is used in its place.
// This option is not available for separator or tear-off entries.
//
// # Menu(Activebackground(...))
//
// Specifies a background color to use for displaying this entry when it
// is active. This option is ignored on Aqua/MacOS.
// If it is specified as an empty string (the default), then the
// -activebackground option for the overall menu is used.
// If the tk_strictMotif variable has been set to request strict
// Motif compliance, then this option is ignored and the -background
// option is used in its place.
// This option is not available for separator or tear-off entries.
func Activebackground(value any) option {
	return activebackgroundOption{value}
}

type activebitmapOption struct{ v any }

func (o activebitmapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activebitmap %s`, optionString(o.v))
}

// # Canvas(Activebitmap(...))
//
// # Canvas(Activebitmap(...))
func Activebitmap(value any) option {
	return activebitmapOption{value}
}

type activeborderwidthOption struct{ v any }

func (o activeborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeborderwidth %s`, optionString(o.v))
}

// Specifies a non-negative value indicating
// the width of the 3-D border drawn around active elements.  See above for
// definition of active elements.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// This option is typically only available in widgets displaying more
// than one element at a time (e.g. menus but not buttons).
func Activeborderwidth(value any) option {
	return activeborderwidthOption{value}
}

type activedashOption struct{ v any }

func (o activedashOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activedash %s`, optionString(o.v))
}

// # Canvas(Activedash(...))
//
// # Canvas(Activedash(...))
func Activedash(value any) option {
	return activedashOption{value}
}

type activefillOption struct{ v any }

func (o activefillOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activefill %s`, optionString(o.v))
}

// # Canvas(Activefill(...))
//
// # Canvas(Activefill(...))
func Activefill(value any) option {
	return activefillOption{value}
}

type activeforegroundOption struct{ v any }

func (o activeforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeforeground %s`, optionString(o.v))
}

// Specifies foreground color to use when drawing active elements.
// See above for definition of active elements.
//
// # Canvas(Activeforeground(...))
//
// # Canvas(Activeforeground(...))
//
// # Menu(Activeforeground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is active.   This option is ignored on Aqua/macOS.
// If this option is specified as an empty string (the default), then the
// -activeforeground option for the overall menu is used.
//
// # Menu(Activeforeground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is active.   This option is ignored on Aqua/macOS.
// If this option is specified as an empty string (the default), then the
// -activeforeground option for the overall menu is used.
func Activeforeground(value any) option {
	return activeforegroundOption{value}
}

type activeimageOption struct{ v any }

func (o activeimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeimage %s`, optionString(o.v))
}

// # Canvas(Activeimage(...))
//
// # Canvas(Activeimage(...))
func Activeimage(value any) option {
	return activeimageOption{value}
}

type activeoutlineOption struct{ v any }

func (o activeoutlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeoutline %s`, optionString(o.v))
}

// # Canvas(Activeoutline(...))
//
// # Canvas(Activeoutline(...))
func Activeoutline(value any) option {
	return activeoutlineOption{value}
}

type activeoutlinestippleOption struct{ v any }

func (o activeoutlinestippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeoutlinestipple %s`, optionString(o.v))
}

// # Canvas(Activeoutlinestipple(...))
//
// # Canvas(Activeoutlinestipple(...))
func Activeoutlinestipple(value any) option {
	return activeoutlinestippleOption{value}
}

type activereliefOption struct{ v any }

func (o activereliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activerelief %s`, optionString(o.v))
}

// Specifies the 3-D effect desired for the active item of the widget.
// See the '-relief' option for details.
//
// # Scrollbar(Activerelief(...))
//
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
//
// # Scrollbar(Activerelief(...))
//
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
func Activerelief(value any) option {
	return activereliefOption{value}
}

type activestippleOption struct{ v any }

func (o activestippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activestipple %s`, optionString(o.v))
}

// # Canvas(Activestipple(...))
//
// # Canvas(Activestipple(...))
func Activestipple(value any) option {
	return activestippleOption{value}
}

type activestyleOption struct{ v any }

func (o activestyleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activestyle %s`, optionString(o.v))
}

// # Listbox(Activestyle(...))
//
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
//
// # Listbox(Activestyle(...))
//
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
func Activestyle(value any) option {
	return activestyleOption{value}
}

type activewidthOption struct{ v any }

func (o activewidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activewidth %s`, optionString(o.v))
}

// # Canvas(Activewidth(...))
//
// # Canvas(Activewidth(...))
func Activewidth(value any) option {
	return activewidthOption{value}
}

type afterOption struct{ v any }

func (o afterOption) optionString(w *Window) string {
	return fmt.Sprintf(`-after %s`, optionString(o.v))
}

// # Pack(After(...))
//
// Other must the name of another window.
// Use its container as the container for the content, and insert
// the content just after other in the packing order.
//
// # Panedwindow(After(...))
//
// Insert the window after the window specified.  window should be the
// name of a window already managed by pathName.
//
// # Panedwindow(After(...))
//
// Insert the window after the window specified.  window should be the
// name of a window already managed by pathName.
func After(value any) option {
	return afterOption{value}
}

type alignOption struct{ v any }

func (o alignOption) optionString(w *Window) string {
	return fmt.Sprintf(`-align %s`, optionString(o.v))
}

// # Text(Align(...))
//
// If the window is not as tall as the line in which it is displayed, this option
// determines where the window is displayed in the line. Where must have
// one of the values top (align the top of the window with the top of the
// line), center (center the window within the range of the line),
// bottom (align the bottom of the window with the bottom of the line's
// area), or baseline (align the bottom of the window with the baseline of
// the line).
//
// # Text(Align(...))
//
// If the image is not as tall as the line in which it is displayed, this option
// determines where the image is displayed in the line. Where must have one
// of the values top (align the top of the image with the top of the line),
// center (center the image within the range of the line), bottom
// (align the bottom of the image with the bottom of the line's area), or
// baseline (align the bottom of the image with the baseline of the line).
//
// # Text(Align(...))
//
// If the window is not as tall as the line in which it is displayed, this option
// determines where the window is displayed in the line. Where must have
// one of the values top (align the top of the window with the top of the
// line), center (center the window within the range of the line),
// bottom (align the bottom of the window with the bottom of the line's
// area), or baseline (align the bottom of the window with the baseline of
// the line).
//
// # Text(Align(...))
//
// If the image is not as tall as the line in which it is displayed, this option
// determines where the image is displayed in the line. Where must have one
// of the values top (align the top of the image with the top of the line),
// center (center the image within the range of the line), bottom
// (align the bottom of the image with the bottom of the line's area), or
// baseline (align the bottom of the image with the baseline of the line).
func Align(value any) option {
	return alignOption{value}
}

type allOption struct{ v any }

func (o allOption) optionString(w *Window) string {
	return fmt.Sprintf(`-all %s`, optionString(o.v))
}

// # Text(All(...))
//
// Return information about all elements: text, marks, tags, images and windows.
// This is the default.
//
// # Text(All(...))
//
// Find all matches in the given range and return a list of the indices of the
// first character of each match. If a -count varName switch is given,
// then varName is also set to a list containing one element for each
// successful match. Note that, even for exact searches, the elements of this
// list may be different, if there are embedded images, windows or hidden text.
// Searches with -all behave very similarly to the Tcl command regexp
// -all, in that overlapping matches are not normally returned. For example,
// applying an -all search of the pattern
//
// # Text(All(...))
//
// Return information about all elements: text, marks, tags, images and windows.
// This is the default.
//
// # Text(All(...))
//
// Find all matches in the given range and return a list of the indices of the
// first character of each match. If a -count varName switch is given,
// then varName is also set to a list containing one element for each
// successful match. Note that, even for exact searches, the elements of this
// list may be different, if there are embedded images, windows or hidden text.
// Searches with -all behave very similarly to the Tcl command regexp
// -all, in that overlapping matches are not normally returned. For example,
// applying an -all search of the pattern
func All(value any) option {
	return allOption{value}
}

type alphaOption struct{ v any }

func (o alphaOption) optionString(w *Window) string {
	return fmt.Sprintf(`-alpha %s`, optionString(o.v))
}

// # Nsimage(Alpha(...))
//
// # Wm(Alpha(...))
//
// Specifies the alpha transparency level of the toplevel. It accepts a value
// from 0.0 (fully transparent) to 1.0 (opaque).  Values outside that
// range will be constrained.  Where not supported, the -alpha value
// remains at 1.0.
func Alpha(value any) option {
	return alphaOption{value}
}

type anchorOption struct{ v any }

func (o anchorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-anchor %s`, optionString(o.v))
}

// Specifies how the information in a widget (e.g. text or a bitmap)
// is to be displayed in the widget.
// Must be one of the values 'n', 'ne', 'e', 'se',
// 's', 'sw', 'w', 'nw', or 'center'.
// For example, 'nw' means display the information such that its
// top-left corner is at the top-left corner of the widget.
//
// # Canvas(Anchor(...))
//
// AnchorPos tells how to position the item relative to the
// positioning point for the item; it may have any of the forms
// accepted by Tk_GetAnchor. For example, if anchorPos
// is center then the item is centered on the point; if
// anchorPos is n then the item will be drawn so that
// its top center point is at the positioning point.
// This option defaults to center.
//
// # Canvas(Anchor(...))
//
// AnchorPos tells how to position the item relative to the
// positioning point for the item; it may have any of the forms
// accepted by Tk_GetAnchor. For example, if anchorPos
// is center then the item is centered on the point; if
// anchorPos is n then the item will be drawn so that
// its top center point is at the positioning point.
// This option defaults to center.
//
// # Pack(Anchor(...))
//
// Anchor must be a valid anchor position such as n
// or sw; it specifies where to position each content in its
// parcel.
// Defaults to center.
//
// # Place(Anchor(...))
//
// Where specifies which point of window is to be positioned
// at the (x,y) location selected by the -x, -y,
// -relx, and -rely options.
// The anchor point is in terms of the outer area of window
// including its border, if any.
// Thus if where is se then the lower-right corner of
// window's border will appear at the given (x,y) location
// in the container.
// The anchor position defaults to nw.
//
// # TTreeview(Anchor(...))
//
// Specifies how the text in this column should be aligned
// with respect to the cell. Anchor is one of
// n, ne, e, se,
// s, sw, w, nw, or center.
//
// # TTreeview(Anchor(...))
//
// Specifies how the heading text should be aligned.
// One of the standard Tk anchor values.
//
// # TTreeview(Anchor(...))
//
// Specifies how the text in this column should be aligned
// with respect to the cell. Anchor is one of
// n, ne, e, se,
// s, sw, w, nw, or center.
//
// # TTreeview(Anchor(...))
//
// Specifies how the heading text should be aligned.
// One of the standard Tk anchor values.
func Anchor(value any) option {
	return anchorOption{value}
}

type angleOption struct{ v any }

func (o angleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-angle %s`, optionString(o.v))
}

// # Canvas(Angle(...))
//
// RotationDegrees tells how many degrees to rotate the text anticlockwise
// about the positioning point for the text; it may have any floating-point value
// from 0.0 to 360.0. For example, if rotationDegrees is 90, then the
// text will be drawn vertically from bottom to top.
// This option defaults to 0.0.
//
// # Canvas(Angle(...))
//
// RotationDegrees tells how many degrees to rotate the text anticlockwise
// about the positioning point for the text; it may have any floating-point value
// from 0.0 to 360.0. For example, if rotationDegrees is 90, then the
// text will be drawn vertically from bottom to top.
// This option defaults to 0.0.
func Angle(value any) option {
	return angleOption{value}
}

type appearanceOption struct{ v any }

func (o appearanceOption) optionString(w *Window) string {
	return fmt.Sprintf(`-appearance %s`, optionString(o.v))
}

// # Wm(Appearance(...))
//
// Specifies whether the window is rendered in "dark mode".  Allowed
// values are auto, aqua and darkaqua.  If the setting
// is auto then the appearance of the window is controlled by the
// System Settings.
func Appearance(value any) option {
	return appearanceOption{value}
}

type arrowOption struct{ v any }

func (o arrowOption) optionString(w *Window) string {
	return fmt.Sprintf(`-arrow %s`, optionString(o.v))
}

// # Canvas(Arrow(...))
//
// Indicates whether or not arrowheads are to be drawn at one or both
// ends of the line.
// Where must have one of the values none (for no arrowheads),
// first (for an arrowhead at the first point of the line),
// last (for an arrowhead at the last point of the line), or
// both (for arrowheads at both ends).
// This option defaults to none.
// When requested to draw an arrowhead, Tk internally adjusts the corresponding
// line end point so that the rendered line ends at the neck of the arrowhead
// rather than at its tip so that the line doesn't extend past the edge of the
// arrowhead. This may trigger a Leave event if the mouse is hovering this
// line end. Conversely, when removing an arrowhead Tk adjusts the corresponding
// line point the other way round, which may trigger an Enter event.
//
// # Canvas(Arrow(...))
//
// Indicates whether or not arrowheads are to be drawn at one or both
// ends of the line.
// Where must have one of the values none (for no arrowheads),
// first (for an arrowhead at the first point of the line),
// last (for an arrowhead at the last point of the line), or
// both (for arrowheads at both ends).
// This option defaults to none.
// When requested to draw an arrowhead, Tk internally adjusts the corresponding
// line end point so that the rendered line ends at the neck of the arrowhead
// rather than at its tip so that the line doesn't extend past the edge of the
// arrowhead. This may trigger a Leave event if the mouse is hovering this
// line end. Conversely, when removing an arrowhead Tk adjusts the corresponding
// line point the other way round, which may trigger an Enter event.
func Arrow(value any) option {
	return arrowOption{value}
}

type arrowshapeOption struct{ v any }

func (o arrowshapeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-arrowshape %s`, optionString(o.v))
}

// # Canvas(Arrowshape(...))
//
// This option indicates how to draw arrowheads.
// The shape argument must be a list with three elements, each
// specifying a distance in any of the forms described in
// the COORDINATES section above.
// The first element of the list gives the distance along the line
// from the neck of the arrowhead to its tip.
// The second element gives the distance along the line from the
// trailing points of the arrowhead to the tip, and the third
// element gives the distance from the outside edge of the line to the
// trailing points.
// If this option is not specified then Tk picks a
//
// # Canvas(Arrowshape(...))
//
// This option indicates how to draw arrowheads.
// The shape argument must be a list with three elements, each
// specifying a distance in any of the forms described in
// the COORDINATES section above.
// The first element of the list gives the distance along the line
// from the neck of the arrowhead to its tip.
// The second element gives the distance along the line from the
// trailing points of the arrowhead to the tip, and the third
// element gives the distance from the outside edge of the line to the
// trailing points.
// If this option is not specified then Tk picks a
func Arrowshape(value any) option {
	return arrowshapeOption{value}
}

type asOption struct{ v any }

func (o asOption) optionString(w *Window) string {
	return fmt.Sprintf(`-as %s`, optionString(o.v))
}

// # Nsimage(As(...))
func As(value any) option {
	return asOption{value}
}

type ascentOption struct{ v any }

func (o ascentOption) optionString(w *Window) string {
	return fmt.Sprintf(`-ascent %s`, optionString(o.v))
}

// # Font(Ascent(...))
//
// The amount in pixels that the tallest letter sticks up above the baseline of
// the font, plus any extra blank space added by the designer of the font.
func Ascent(value any) option {
	return ascentOption{value}
}

type aspectOption struct{ v any }

func (o aspectOption) optionString(w *Window) string {
	return fmt.Sprintf(`-aspect %s`, optionString(o.v))
}

// # Message(Aspect(...))
//
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
//
// # Message(Aspect(...))
//
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
func Aspect(value any) option {
	return aspectOption{value}
}

type asyncOption struct{ v any }

func (o asyncOption) optionString(w *Window) string {
	return fmt.Sprintf(`-async %s`, optionString(o.v))
}

// # Send(Async(...))
//
// Requests asynchronous invocation.  In this case the send
// command will complete immediately without waiting for cmd
// to complete in the target application;  no result will be available
// and errors in the sent command will be ignored.
// If the target application is in the same process as the sending
// application then the -async option is ignored.
func Async(value any) option {
	return asyncOption{value}
}

type autoseparatorsOption struct{ v any }

func (o autoseparatorsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-autoseparators %s`, optionString(o.v))
}

// # Text(Autoseparators(...))
//
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
//
// # Text(Autoseparators(...))
//
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
func Autoseparators(value any) option {
	return autoseparatorsOption{value}
}

type backgroundOption struct{ v any }

func (o backgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-background %s`, optionString(o.v))
}

// Specifies the normal background color to use when displaying the
// widget.
//
// # Bitmap(Background(...))
//
// Specifies a background color for the image in any of the standard
// ways accepted by Tk.  If this option is set to an empty string
// then the background pixels will be transparent.  This effect
// is achieved by using the source bitmap as the mask bitmap, ignoring
// any -maskdata or -maskfile options.
//
// # Canvas(Background(...))
//
// # Canvas(Background(...))
//
// # Frame(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Frame(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Labelframe(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Labelframe(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Listbox(Background(...))
//
// Color specifies the background color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Listbox(Background(...))
//
// Color specifies the background color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Menu(Background(...))
//
// Specifies a background color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -background option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Background(...))
//
// Specifies a background color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -background option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Photo(Background(...))
//
// If the color is specified, the data will not contain any transparency
// information. In all transparent pixels the color will be replaced by
// the specified color.
//
// # Photo(Background(...))
//
// If the color is specified, the data will not contain any transparency
// information. In all transparent pixels the color will be replaced by
// the specified color.
//
// # Text(Background(...))
//
// Color specifies the background color to use for characters associated
// with the tag. It may have any of the forms accepted by Tk_GetColor.
//
// # Text(Background(...))
//
// Color specifies the background color to use for characters associated
// with the tag. It may have any of the forms accepted by Tk_GetColor.
//
// # Toplevel(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Toplevel(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # TLabel(Background(...))
//
// The widget's background color.
// If unspecified, the theme default is used.
//
// # TLabel(Background(...))
//
// The widget's background color.
// If unspecified, the theme default is used.
func Background(value any) option {
	return backgroundOption{value}
}

type backgroundimageOption struct{ v any }

func (o backgroundimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-backgroundimage %s`, optionString(o.v))
}

// # Frame(Backgroundimage(...))
//
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
//
// # Frame(Backgroundimage(...))
//
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
//
// # Toplevel(Backgroundimage(...))
//
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
//
// # Toplevel(Backgroundimage(...))
//
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
func Backgroundimage(value any) option {
	return backgroundimageOption{value}
}

type backwardsOption struct{ v any }

func (o backwardsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-backwards %s`, optionString(o.v))
}

// # Text(Backwards(...))
//
// The search will proceed backward through the text, finding the matching range
// closest to index whose first character is before index (it is not
// allowed to be at index). Note that, for a variety of reasons, backwards
// searches can be substantially slower than forwards searches (particularly when
// using -regexp), so it is recommended that performance-critical code use
// forward searches.
//
// # Text(Backwards(...))
//
// The search will proceed backward through the text, finding the matching range
// closest to index whose first character is before index (it is not
// allowed to be at index). Note that, for a variety of reasons, backwards
// searches can be substantially slower than forwards searches (particularly when
// using -regexp), so it is recommended that performance-critical code use
// forward searches.
func Backwards(value any) option {
	return backwardsOption{value}
}

type bdOption struct{ v any }

func (o bdOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bd %s`, optionString(o.v))
}

// Specifies a non-negative value indicating the width
// of the 3-D border to draw around the outside of the widget (if such a
// border is being drawn;  the '-relief' option typically determines
// this).  The value may also be used when drawing 3-D effects in the
// interior of the widget.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
func Bd(value any) option {
	return bdOption{value}
}

type beforeOption struct{ v any }

func (o beforeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-before %s`, optionString(o.v))
}

// # Pack(Before(...))
//
// Other must the name of another window.
// Use its container as the container for the content, and insert
// the content just before other in the packing order.
//
// # Panedwindow(Before(...))
//
// Insert the window before the window specified.  window should be
// the name of a window already managed by pathName.
//
// # Panedwindow(Before(...))
//
// Insert the window before the window specified.  window should be
// the name of a window already managed by pathName.
func Before(value any) option {
	return beforeOption{value}
}

type bgOption struct{ v any }

func (o bgOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bg %s`, optionString(o.v))
}

// Specifies the normal background color to use when displaying the
// widget.
func Bg(value any) option {
	return bgOption{value}
}

type bgstippleOption struct{ v any }

func (o bgstippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bgstipple %s`, optionString(o.v))
}

// # Text(Bgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern for the
// background. It may have any of the forms accepted by Tk_GetBitmap. If
// bitmap has not been specified, or if it is specified as an empty string,
// then a solid fill will be used for the background.
//
// # Text(Bgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern for the
// background. It may have any of the forms accepted by Tk_GetBitmap. If
// bitmap has not been specified, or if it is specified as an empty string,
// then a solid fill will be used for the background.
func Bgstipple(value any) option {
	return bgstippleOption{value}
}

type bigincrementOption struct{ v any }

func (o bigincrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bigincrement %s`, optionString(o.v))
}

// # Scale(Bigincrement(...))
//
// # Some interactions with the scale cause its value to change by
//
// # Scale(Bigincrement(...))
//
// Some interactions with the scale cause its value to change by
func Bigincrement(value any) option {
	return bigincrementOption{value}
}

type bitmapOption struct{ v any }

func (o bitmapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bitmap %s`, optionString(o.v))
}

// Specifies a bitmap to display in the widget, in any of the forms
// acceptable to 'Tk_GetBitmap'.
// The exact way in which the bitmap is displayed may be affected by
// other options such as '-anchor' or '-justify'.
// Typically, if this option is specified then it overrides other
// options that specify a textual value to display in the widget
// but this is controlled by the '-compound' option;
// the '-bitmap' option may be reset to an empty string to re-enable
// a text display.
// In widgets that support both '-bitmap' and '-image' options,
// '-image' will usually override '-bitmap'.
//
// # Canvas(Bitmap(...))
//
// # Canvas(Bitmap(...))
//
// # Menu(Bitmap(...))
//
// Specifies a bitmap to display in the menu instead of a textual
// label, in any of the forms accepted by Tk_GetBitmap.
// This option overrides the -label option
// (as controlled by the -compound option)
// but may be reset
// to an empty string to enable a textual label to be displayed.
// If a -image option has been specified, it overrides
// -bitmap.
// This option is not available for separator or tear-off entries.
//
// # Menu(Bitmap(...))
//
// Specifies a bitmap to display in the menu instead of a textual
// label, in any of the forms accepted by Tk_GetBitmap.
// This option overrides the -label option
// (as controlled by the -compound option)
// but may be reset
// to an empty string to enable a textual label to be displayed.
// If a -image option has been specified, it overrides
// -bitmap.
// This option is not available for separator or tear-off entries.
func Bitmap(value any) option {
	return bitmapOption{value}
}

type blockcursorOption struct{ v any }

func (o blockcursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-blockcursor %s`, optionString(o.v))
}

// # Text(Blockcursor(...))
//
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
//
// # Text(Blockcursor(...))
//
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
func Blockcursor(value any) option {
	return blockcursorOption{value}
}

type borderOption struct{ v any }

func (o borderOption) optionString(w *Window) string {
	return fmt.Sprintf(`-border %s`, optionString(o.v))
}

// # TImage(Border(...))
//
// padding is a list of up to four integers, specifying
// the left, top, right, and bottom borders, respectively.
// If fewer than four elements are specified,
// bottom defaults to top,
// right defaults to left, and
// top defaults to left.
// In other words, a list of three numbers specify the left, vertical, and right
// border; a list of two numbers specify the horizontal and the vertical border;
// a single number specifies the same border all the way around the element.
// See IMAGE STRETCHING, below.
func Border(value any) option {
	return borderOption{value}
}

type bordermodeOption struct{ v any }

func (o bordermodeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bordermode %s`, optionString(o.v))
}

// # Place(Bordermode(...))
//
// Mode determines the degree to which borders within the
// container are used in determining the placement of the content.
// The default and most common value is inside.
// In this case the placer considers the area of the container to
// be the innermost area of the container, inside any border:
// an option of -x 0 corresponds to an x-coordinate just
// inside the border and an option of -relwidth 1.0
// means window will fill the area inside the container's
// border.
func Bordermode(value any) option {
	return bordermodeOption{value}
}

type borderwidthOption struct{ v any }

func (o borderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-borderwidth %s`, optionString(o.v))
}

// Specifies a non-negative value indicating the width
// of the 3-D border to draw around the outside of the widget (if such a
// border is being drawn;  the '-relief' option typically determines
// this).  The value may also be used when drawing 3-D effects in the
// interior of the widget.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # Event(Borderwidth(...))
//
// Size must be a screen distance;  it specifies the
// border_width field for the event.
// Valid for Configure events.
// Corresponds to the %B substitution for binding scripts.
//
// # Text(Borderwidth(...))
//
// Pixels specifies the width of a border to draw around the tag using any
// of the forms accepted by Tk_GetPixels. This option should be used in
// conjunction with the -relief option to provide the desired border.
//
// # Text(Borderwidth(...))
//
// Pixels specifies the width of a border to draw around the tag using any
// of the forms accepted by Tk_GetPixels. This option should be used in
// conjunction with the -relief option to provide the desired border.
//
// # TFrame(Borderwidth(...))
//
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
//
// # TFrame(Borderwidth(...))
//
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
func Borderwidth(value any) option {
	return borderwidthOption{value}
}

type buttonOption struct{ v any }

func (o buttonOption) optionString(w *Window) string {
	return fmt.Sprintf(`-button %s`, optionString(o.v))
}

// # Event(Btn(...))
//
// Number must be an integer;  it specifies the detail field
// for a Button or ButtonRelease event, overriding
// any button  number provided in the base event argument.
// Corresponds to the %b substitution for binding scripts.
func Btn(value any) option {
	return buttonOption{value}
}

type buttonbackgroundOption struct{ v any }

func (o buttonbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttonbackground %s`, optionString(o.v))
}

// # Spinbox(Buttonbackground(...))
//
// The background color to be used for the spin buttons.
//
// # Spinbox(Buttonbackground(...))
//
// The background color to be used for the spin buttons.
func Buttonbackground(value any) option {
	return buttonbackgroundOption{value}
}

type buttoncursorOption struct{ v any }

func (o buttoncursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttoncursor %s`, optionString(o.v))
}

// # Spinbox(Buttoncursor(...))
//
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
//
// # Spinbox(Buttoncursor(...))
//
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
func Buttoncursor(value any) option {
	return buttoncursorOption{value}
}

type buttondownreliefOption struct{ v any }

func (o buttondownreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttondownrelief %s`, optionString(o.v))
}

// # Spinbox(Buttondownrelief(...))
//
// The relief to be used for the upper spin button.
//
// # Spinbox(Buttondownrelief(...))
//
// The relief to be used for the upper spin button.
func Buttondownrelief(value any) option {
	return buttondownreliefOption{value}
}

type buttonupreliefOption struct{ v any }

func (o buttonupreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttonuprelief %s`, optionString(o.v))
}

// # Spinbox(Buttonuprelief(...))
//
// The relief to be used for the lower spin button.
//
// # Spinbox(Buttonuprelief(...))
//
// The relief to be used for the lower spin button.
func Buttonuprelief(value any) option {
	return buttonupreliefOption{value}
}

type capstyleOption struct{ v any }

func (o capstyleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-capstyle %s`, optionString(o.v))
}

// # Canvas(Capstyle(...))
//
// Specifies the ways in which caps are to be drawn at the endpoints
// of the line.
// Style may have any of the forms accepted by Tk_GetCapStyle
// (butt, projecting, or round).
// If this option is not specified then it defaults to butt.
// Where arrowheads are drawn the cap style is ignored.
//
// # Canvas(Capstyle(...))
//
// Specifies the ways in which caps are to be drawn at the endpoints
// of the line.
// Style may have any of the forms accepted by Tk_GetCapStyle
// (butt, projecting, or round).
// If this option is not specified then it defaults to butt.
// Where arrowheads are drawn the cap style is ignored.
func Capstyle(value any) option {
	return capstyleOption{value}
}

type channelOption struct{ v any }

func (o channelOption) optionString(w *Window) string {
	return fmt.Sprintf(`-channel %s`, optionString(o.v))
}

// # Canvas(Channel(...))
//
// Specifies the name of the channel to which to write the Postscript.
// If this option and the -file option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Canvas(Channel(...))
//
// Specifies the name of the channel to which to write the Postscript.
// If this option and the -file option are
// not specified then the Postscript is returned as the
// result of the command.
func Channel(value any) option {
	return channelOption{value}
}

type childrenOption struct{ v any }

func (o childrenOption) optionString(w *Window) string {
	return fmt.Sprintf(`-children %s`, optionString(o.v))
}

// # TStyle(Children(...))
//
// Specifies a list of elements to place inside the element.
func Children(value any) option {
	return childrenOption{value}
}

type classOption struct{ v any }

func (o classOption) optionString(w *Window) string {
	return fmt.Sprintf(`-class %s`, optionString(o.v))
}

// # Frame(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Frame(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Wm(Class(...))
//
// Specifies whether the underlying Aqua window for a toplevel is an
// object of the NSWindow class or the NSPanel class.  The two allowed
// values for this option are nswindow and nspanel.  It is
// not possible to change the class of the underlying Aqua window once
// that window has been instantiated, and attempting to do that is an
// error.  However it is allowed to set this option for a pathname that
// does not correspond to an existing window.  Doing that causes the
// class name to be cached for later use.  When a toplevel with that
// pathname is eventually created, the cached class name will determine which
// class is used for the underlying Aqua window.
func Class(value any) option {
	return classOption{value}
}

type closeenoughOption struct{ v any }

func (o closeenoughOption) optionString(w *Window) string {
	return fmt.Sprintf(`-closeenough %s`, optionString(o.v))
}

// # Canvas(Closeenough(...))
//
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
//
// # Canvas(Closeenough(...))
//
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
func Closeenough(value any) option {
	return closeenoughOption{value}
}

type colormapOption struct{ v any }

func (o colormapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-colormap %s`, optionString(o.v))
}

// # Canvas(Colormap(...))
//
// VarName must be the name of an array variable
// that specifies a color mapping to use in the Postscript.
// Each element of varName must consist of Postscript
// code to set a particular color value (e.g.
//
// # Canvas(Colormap(...))
//
// VarName must be the name of an array variable
// that specifies a color mapping to use in the Postscript.
// Each element of varName must consist of Postscript
// code to set a particular color value (e.g.
//
// # Frame(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Frame(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
func Colormap(value any) option {
	return colormapOption{value}
}

type colormodeOption struct{ v any }

func (o colormodeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-colormode %s`, optionString(o.v))
}

// # Canvas(Colormode(...))
//
// Specifies how to output color information. Mode must be either
// color (for full color output), gray (convert all colors
// to their gray-scale equivalents) or mono (convert all colors
// to black or white).
//
// # Canvas(Colormode(...))
//
// Specifies how to output color information. Mode must be either
// color (for full color output), gray (convert all colors
// to their gray-scale equivalents) or mono (convert all colors
// to black or white).
func Colormode(value any) option {
	return colormodeOption{value}
}

type columnOption struct{ v any }

func (o columnOption) optionString(w *Window) string {
	return fmt.Sprintf(`-column %s`, optionString(o.v))
}

// # Grid(Column(...))
//
// Insert the window so that it occupies the nth column in the grid.
// Column numbers start with 0.  If this option is not supplied, then the
// window is arranged just to the right of previous window specified on this
// call to grid, or column
func Column(value any) option {
	return columnOption{value}
}

type columnbreakOption struct{ v any }

func (o columnbreakOption) optionString(w *Window) string {
	return fmt.Sprintf(`-columnbreak %s`, optionString(o.v))
}

// # Menu(Columnbreak(...))
//
// When this option is zero, the entry appears below the previous entry. When
// this option is one, the entry appears at the top of a new column in the
// menu.
// This option is ignored on Aqua/macOS, where menus are always a single
// column.
//
// # Menu(Columnbreak(...))
//
// When this option is zero, the entry appears below the previous entry. When
// this option is one, the entry appears at the top of a new column in the
// menu.
// This option is ignored on Aqua/macOS, where menus are always a single
// column.
func Columnbreak(value any) option {
	return columnbreakOption{value}
}

type columnsOption struct{ v any }

func (o columnsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-columns %s`, optionString(o.v))
}

// # TTreeview(Columns(...))
//
// A list of column identifiers,
// specifying the number of columns and their names.
//
// # TTreeview(Columns(...))
//
// A list of column identifiers,
// specifying the number of columns and their names.
func Columns(value any) option {
	return columnsOption{value}
}

type columnspanOption struct{ v any }

func (o columnspanOption) optionString(w *Window) string {
	return fmt.Sprintf(`-columnspan %s`, optionString(o.v))
}

// # Grid(Columnspan(...))
//
// Insert the window so that it occupies n columns in the grid.
// The default is one column, unless the window name is followed by a
// -, in which case the columnspan is incremented once for each immediately
// following -.
func Columnspan(value any) option {
	return columnspanOption{value}
}

// See also [Event handlers]
//
// # Button(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
//
// # Button(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
//
// # Checkbutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Checkbutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # ChooseDirectory(Command(...))
//
// Specifies the prefix of a Tcl command to invoke when the user closes the
// dialog after having selected an item. This callback is not called if the
// user cancelled the dialog. The actual command consists of string
// followed by a space and the value selected by the user in the dialog. This
// is only available on Mac OS X.
//
// # Fontchooser(Command(...))
//
// Specifies/returns the command prefix to be called when a font selection has
// been made by the user. The command prefix is evaluated at the global level
// after having the specification of the selected font appended. On platforms
// where the font selection dialog offers the user control of further font
// attributes (such as color), additional key/value pairs may be appended before
// evaluation. Can be set to the empty string to indicate that no callback should
// be invoked. Fonts are specified by a list of form [3] of the "FONT DESCRIPTION"
// section in the font manual page (i.e. a list of the form
// {family size style ?style ...?}).
//
// # GetOpenFile(Command(...))
//
// Specifies the prefix of a Tcl command to invoke when the user closes the
// dialog after having selected an item. This callback is not called if the
// user cancelled the dialog. The actual command consists of string
// followed by a space and the value selected by the user in the dialog. This
// is only available on Mac OS X.
//
// # Menu(Command(...))
//
// Specifies a Tcl command to execute when the menu entry is invoked.
// Not available for separator or tear-off entries.
//
// # Menu(Command(...))
//
// Specifies a Tcl command to execute when the menu entry is invoked.
// Not available for separator or tear-off entries.
//
// # MessageBox(Command(...))
//
// Specifies the prefix of a Tcl command to invoke when the user closes the
// dialog. The actual command consists of string followed by a space
// and the name of the button clicked by the user to close the dialog. This
// is only available on Mac OS X.
//
// # Radiobutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Radiobutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Scale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
//
// # Scale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
//
// # Scrollbar(Command(...))
//
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
//
// # Scrollbar(Command(...))
//
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
//
// # Spinbox(Command(...))
//
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
//
// # Spinbox(Command(...))
//
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
//
// # Text(Command(...))
//
// Instead of returning the information as the result of the dump operation,
// invoke the command on each element of the text widget within the range.
// The command has three arguments appended to it before it is evaluated: the
// key, value, and index.
//
// # Text(Command(...))
//
// Instead of returning the information as the result of the dump operation,
// invoke the command on each element of the text widget within the range.
// The command has three arguments appended to it before it is evaluated: the
// key, value, and index.
//
// # TButton(Command(...))
//
// A script to evaluate when the widget is invoked.
//
// # TButton(Command(...))
//
// A script to evaluate when the widget is invoked.
//
// # TCheckbutton(Command(...))
//
// A Tcl script to execute whenever the widget is invoked.
//
// # TCheckbutton(Command(...))
//
// A Tcl script to execute whenever the widget is invoked.
//
// # TRadiobutton(Command(...))
//
// A Tcl script to evaluate whenever the widget is invoked.
//
// # TRadiobutton(Command(...))
//
// A Tcl script to evaluate whenever the widget is invoked.
//
// # TScale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
//
// # TScale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
//
// # TScrollbar(Command(...))
//
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
//
// # TScrollbar(Command(...))
//
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
//
// # TSpinbox(Command(...))
//
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
//
// # TSpinbox(Command(...))
//
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
//
// # TTreeview(Command(...))
//
// A script to evaluate when the heading label is pressed.
//
// # TTreeview(Command(...))
//
// A script to evaluate when the heading label is pressed.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Command(args ...any) option {
	return newEventHandler("-command", args...)
}

type compositingruleOption struct{ v any }

func (o compositingruleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-compositingrule %s`, optionString(o.v))
}

// # Photo(Compositingrule(...))
//
// Specifies how transparent pixels in the source image are combined with
// the destination image.  When a compositing rule of overlay is
// set, the old contents of the destination image are visible, as if the
// source image were printed on a piece of transparent film and placed
// over the top of the destination.  When a compositing rule of set
// is set, the old contents of the destination image are discarded and
// the source image is used as-is.  The default compositing rule is
// overlay.
func Compositingrule(value any) option {
	return compositingruleOption{value}
}

type compoundOption struct{ v any }

func (o compoundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-compound %s`, optionString(o.v))
}

// Specifies if the widget should display text and bitmaps/images at the
// same time, and if so, where the bitmap/image should be placed relative
// to the text.  Must be one of the values 'none', 'bottom',
// 'top', 'left', 'right', or 'center'.  For example, the
// (default) value 'none' specifies that the bitmap or image should
// (if defined) be displayed instead of the text, the value 'left'
// specifies that the bitmap or image should be displayed to the left of
// the text, and the value 'center' specifies that the bitmap or
// image should be displayed on top of the text.
//
// # Menu(Compound(...))
//
// Specifies whether the menu entry should display both an image and text,
// and if so, where the image should be placed relative to the text.
// Valid values for this option are bottom, center,
// left, none, right and top.  The default value
// is none, meaning that the button will display either an image or
// text, depending on the values of the -image and -bitmap
// options.
//
// # Menu(Compound(...))
//
// Specifies whether the menu entry should display both an image and text,
// and if so, where the image should be placed relative to the text.
// Valid values for this option are bottom, center,
// left, none, right and top.  The default value
// is none, meaning that the button will display either an image or
// text, depending on the values of the -image and -bitmap
// options.
//
// # TNotebook(Compound(...))
//
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
//
// # TNotebook(Compound(...))
//
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
func Compound(value any) option {
	return compoundOption{value}
}

type confineOption struct{ v any }

func (o confineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-confine %s`, optionString(o.v))
}

// # Canvas(Confine(...))
//
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
//
// # Canvas(Confine(...))
//
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
func Confine(value any) option {
	return confineOption{value}
}

type confirmoverwriteOption struct{ v any }

func (o confirmoverwriteOption) optionString(w *Window) string {
	return fmt.Sprintf(`-confirmoverwrite %s`, optionString(o.v))
}

// # GetOpenFile(Confirmoverwrite(...))
//
// Configures how the Save dialog reacts when the selected file already
// exists, and saving would overwrite it.  A true value requests a
// confirmation dialog be presented to the user.  A false value requests
// that the overwrite take place without confirmation.  Default value is true.
func Confirmoverwrite(value any) option {
	return confirmoverwriteOption{value}
}

type containerOption struct{ v any }

func (o containerOption) optionString(w *Window) string {
	return fmt.Sprintf(`-container %s`, optionString(o.v))
}

// # Frame(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
//
// # Frame(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
//
// # Toplevel(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
func Container(value any) option {
	return containerOption{value}
}

type countOption struct{ v any }

func (o countOption) optionString(w *Window) string {
	return fmt.Sprintf(`-count %s`, optionString(o.v))
}

// # Event(Count(...))
//
// Number must be an integer;  it specifies the count field
// for the event.  Valid for Expose events.
// Corresponds to the %c substitution for binding scripts.
//
// # Text(Count(...))
//
// The argument following -count gives the name of a variable; if a match
// is found, the number of index positions between beginning and end of the
// matching range will be stored in the variable. If there are no embedded images
// or windows in the matching range (and there are no elided characters if
// -elide is not given), this is equivalent to the number of characters
// matched. In either case, the range matchIdx to matchIdx + $count
// chars will return the entire matched text.
//
// # Text(Count(...))
//
// The argument following -count gives the name of a variable; if a match
// is found, the number of index positions between beginning and end of the
// matching range will be stored in the variable. If there are no embedded images
// or windows in the matching range (and there are no elided characters if
// -elide is not given), this is equivalent to the number of characters
// matched. In either case, the range matchIdx to matchIdx + $count
// chars will return the entire matched text.
func Count(value any) option {
	return countOption{value}
}

type createOption struct{ v any }

func (o createOption) optionString(w *Window) string {
	return fmt.Sprintf(`-create %s`, optionString(o.v))
}

// # Text(Create(...))
//
// Specifies a Tcl script that may be evaluated to create the window for the
// annotation. If no -window option has been specified for the annotation
// this script will be evaluated when the annotation is about to be displayed on
// the screen. Script must create a window for the annotation and return
// the name of that window as its result. Two substitutions will be performed in
// script before evaluation. %W will be substituted by the name of
// the parent text widget, and %% will be substituted by a single %.
// If the annotation's window should ever be deleted, script will be
// evaluated again the next time the annotation is displayed.
//
// # Text(Create(...))
//
// Specifies a Tcl script that may be evaluated to create the window for the
// annotation. If no -window option has been specified for the annotation
// this script will be evaluated when the annotation is about to be displayed on
// the screen. Script must create a window for the annotation and return
// the name of that window as its result. Two substitutions will be performed in
// script before evaluation. %W will be substituted by the name of
// the parent text widget, and %% will be substituted by a single %.
// If the annotation's window should ever be deleted, script will be
// evaluated again the next time the annotation is displayed.
func Create(value any) option {
	return createOption{value}
}

type cursorOption struct{ v any }

func (o cursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-cursor %s`, optionString(o.v))
}

// Specifies the mouse cursor to be used for the widget.
// The value may have any of the forms acceptable to 'Tk_GetCursor'.
// In addition, if an empty string is specified, it indicates that the
// widget should defer to its parent for cursor specification.
//
// # Busy(Cursor(...))
//
// Specifies the cursor to be displayed when the widget is made busy.
// CursorName can be in any form accepted by Tk_GetCursor. The
// default cursor is wait on Windows and watch on other platforms.
func Cursor(value any) option {
	return cursorOption{value}
}

type dashOption struct{ v any }

func (o dashOption) optionString(w *Window) string {
	return fmt.Sprintf(`-dash %s`, optionString(o.v))
}

// # Canvas(Dash(...))
//
// # Canvas(Dash(...))
func Dash(value any) option {
	return dashOption{value}
}

type dashoffsetOption struct{ v any }

func (o dashoffsetOption) optionString(w *Window) string {
	return fmt.Sprintf(`-dashoffset %s`, optionString(o.v))
}

// # Canvas(Dashoffset(...))
//
// The starting offset in pixels into the pattern provided by the
// -dash option. -dashoffset is ignored if there is no
// -dash pattern. The offset may have any of the forms described
// in the COORDINATES section above.
//
// # Canvas(Dashoffset(...))
//
// The starting offset in pixels into the pattern provided by the
// -dash option. -dashoffset is ignored if there is no
// -dash pattern. The offset may have any of the forms described
// in the COORDINATES section above.
func Dashoffset(value any) option {
	return dashoffsetOption{value}
}

type dataOption struct{ v any }

func (o dataOption) optionString(w *Window) string {
	return fmt.Sprintf(`-data %s`, optionString(o.v))
}

// # Bitmap(Data(...))
//
// Specifies the contents of the source bitmap as a string.
// The string must adhere to X11 bitmap format (e.g., as generated
// by the bitmap program).
// If both the -data and -file options are specified,
// the -data option takes precedence.
//
// # Event(Data(...))
//
// String may be any value; it specifies the user_data field
// for the event.  Only valid for virtual events.  Corresponds to the
// %d substitution for virtual events in binding scripts.
//
// # Photo(Data(...))
//
// Specifies the contents of the image as a string.
func Data(value any) option {
	return dataOption{value}
}

type defaultOption struct{ v any }

func (o defaultOption) optionString(w *Window) string {
	return fmt.Sprintf(`-default %s`, optionString(o.v))
}

// # Button(Default(...))
//
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
//
// # Button(Default(...))
//
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
//
// # MessageBox(Default(...))
//
// Name gives the symbolic name of the default button for
// this message window (
//
// # TButton(Default(...))
//
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
//
// # TButton(Default(...))
//
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
func Default(value any) option {
	return defaultOption{value}
}

type defaultextensionOption struct{ v any }

func (o defaultextensionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-defaultextension %s`, optionString(o.v))
}

// # GetOpenFile(Defaultextension(...))
//
// Specifies a string that will be appended to the filename if the user
// enters a filename without an extension. The default value is the empty
// string, which means no extension will be appended to the filename in
// any case. This option is ignored on Mac OS X, which
// does not require extensions to filenames,
// and the UNIX implementation guesses reasonable values for this from
// the -filetypes option when this is not supplied.
func Defaultextension(value any) option {
	return defaultextensionOption{value}
}

type deltaOption struct{ v any }

func (o deltaOption) optionString(w *Window) string {
	return fmt.Sprintf(`-delta %s`, optionString(o.v))
}

// # Event(Delta(...))
//
// Number must be an integer;  it specifies the delta field
// for the MouseWheel event.  The delta refers to the
// direction and magnitude the mouse wheel was rotated.  Note the value
// is not a screen distance but are units of motion in the mouse wheel.
// Typically these values are multiples of 120.  For example, 120 should
// scroll the text widget up 4 lines and -240 would scroll the text
// widget down 8 lines.  Of course, other widgets may define different
// behaviors for mouse wheel motion.  This field corresponds to the
// %D substitution for binding scripts.
func Delta(value any) option {
	return deltaOption{value}
}

type descentOption struct{ v any }

func (o descentOption) optionString(w *Window) string {
	return fmt.Sprintf(`-descent %s`, optionString(o.v))
}

// # Font(Descent(...))
//
// The largest amount in pixels that any letter sticks down below the baseline
// of the font, plus any extra blank space added by the designer of the font.
func Descent(value any) option {
	return descentOption{value}
}

type detailOption struct{ v any }

func (o detailOption) optionString(w *Window) string {
	return fmt.Sprintf(`-detail %s`, optionString(o.v))
}

// # Event(Detail(...))
//
// Detail specifies the detail field for the event
// and must be one of the following:
//
// # MessageBox(Detail(...))
//
// Specifies an auxiliary message to the main message given by the
// -message option. The message detail will be presented beneath the main
// message and, where supported by the OS, in a less emphasized font than the
// main message.
func Detail(value any) option {
	return detailOption{value}
}

type digitsOption struct{ v any }

func (o digitsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-digits %s`, optionString(o.v))
}

// # Scale(Digits(...))
//
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
//
// # Scale(Digits(...))
//
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
func Digits(value any) option {
	return digitsOption{value}
}

type directionOption struct{ v any }

func (o directionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-direction %s`, optionString(o.v))
}

// # Menubutton(Direction(...))
//
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
//
// # Menubutton(Direction(...))
//
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
//
// # TMenubutton(Direction(...))
//
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
//
// # TMenubutton(Direction(...))
//
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
func Direction(value any) option {
	return directionOption{value}
}

type disabledOption struct{ v any }

func (o disabledOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabled %s`, optionString(o.v))
}

// # Wm(Disabled(...))
//
// Specifies whether the window is in a disabled state.
func Disabled(value any) option {
	return disabledOption{value}
}

type disabledbackgroundOption struct{ v any }

func (o disabledbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledbackground %s`, optionString(o.v))
}

// # Canvas(Disabledbackground(...))
//
// # Specifies the color to use for each of the bitmap's
//
// # Canvas(Disabledbackground(...))
//
// # Specifies the color to use for each of the bitmap's
//
// # Entry(Disabledbackground(...))
//
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Entry(Disabledbackground(...))
//
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Disabledbackground(...))
//
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Disabledbackground(...))
//
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
func Disabledbackground(value any) option {
	return disabledbackgroundOption{value}
}

type disabledbitmapOption struct{ v any }

func (o disabledbitmapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledbitmap %s`, optionString(o.v))
}

// # Canvas(Disabledbitmap(...))
//
// These options specify the bitmaps to display in the item in its normal,
// active and disabled states.
// Bitmap may have any of the forms accepted by Tk_GetBitmap.
//
// # Canvas(Disabledbitmap(...))
//
// These options specify the bitmaps to display in the item in its normal,
// active and disabled states.
// Bitmap may have any of the forms accepted by Tk_GetBitmap.
func Disabledbitmap(value any) option {
	return disabledbitmapOption{value}
}

type disableddashOption struct{ v any }

func (o disableddashOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disableddash %s`, optionString(o.v))
}

// # Canvas(Disableddash(...))
//
// These options specify dash patterns for the normal, active
// state, and disabled state of an item.
// pattern may have any of the forms accepted by Tk_GetDash.
// If the dash options are omitted then the default is a solid outline.
// See DASH PATTERNS for more information.
//
// # Canvas(Disableddash(...))
//
// These options specify dash patterns for the normal, active
// state, and disabled state of an item.
// pattern may have any of the forms accepted by Tk_GetDash.
// If the dash options are omitted then the default is a solid outline.
// See DASH PATTERNS for more information.
func Disableddash(value any) option {
	return disableddashOption{value}
}

type disabledfillOption struct{ v any }

func (o disabledfillOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledfill %s`, optionString(o.v))
}

// # Canvas(Disabledfill(...))
//
// These options specify the color to be used to fill item's area.
// in its normal, active, and disabled states.
// The even-odd fill rule is used.
// Color may have any of the forms accepted by Tk_GetColor.
// For the line item, it specifies the color of the line drawn.
// For the text item, it specifies the foreground color of the text.
// If color is an empty string (the default for all canvas items
// except line and text), then the item will not be filled.
//
// # Canvas(Disabledfill(...))
//
// These options specify the color to be used to fill item's area.
// in its normal, active, and disabled states.
// The even-odd fill rule is used.
// Color may have any of the forms accepted by Tk_GetColor.
// For the line item, it specifies the color of the line drawn.
// For the text item, it specifies the foreground color of the text.
// If color is an empty string (the default for all canvas items
// except line and text), then the item will not be filled.
func Disabledfill(value any) option {
	return disabledfillOption{value}
}

type disabledforegroundOption struct{ v any }

func (o disabledforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledforeground %s`, optionString(o.v))
}

// Specifies foreground color to use when drawing a disabled element.
// If the option is specified as an empty string (which is typically the
// case on monochrome displays), disabled elements are drawn with the
// normal foreground color but they are dimmed by drawing them
// with a stippled fill pattern.
//
// # Canvas(Disabledforeground(...))
//
// # These options specify the color to use for each of the bitmap's
//
// # Canvas(Disabledforeground(...))
//
// # These options specify the color to use for each of the bitmap's
//
// # Entry(Disabledforeground(...))
//
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Entry(Disabledforeground(...))
//
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Spinbox(Disabledforeground(...))
//
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Spinbox(Disabledforeground(...))
//
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
func Disabledforeground(value any) option {
	return disabledforegroundOption{value}
}

type disabledimageOption struct{ v any }

func (o disabledimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledimage %s`, optionString(o.v))
}

// # Canvas(Disabledimage(...))
//
// Specifies the name of the images to display in the item in is normal,
// active and disabled states.
// This image must have been created previously with the
// image create command.
//
// # Canvas(Disabledimage(...))
//
// Specifies the name of the images to display in the item in is normal,
// active and disabled states.
// This image must have been created previously with the
// image create command.
func Disabledimage(value any) option {
	return disabledimageOption{value}
}

type disabledoutlineOption struct{ v any }

func (o disabledoutlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledoutline %s`, optionString(o.v))
}

// # Canvas(Disabledoutline(...))
//
// These options specify the color that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Color may have any of the forms accepted by Tk_GetColor.
// If color is specified as an empty string then no outline is drawn
// for the item.
//
// # Canvas(Disabledoutline(...))
//
// These options specify the color that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Color may have any of the forms accepted by Tk_GetColor.
// If color is specified as an empty string then no outline is drawn
// for the item.
func Disabledoutline(value any) option {
	return disabledoutlineOption{value}
}

type disabledoutlinestippleOption struct{ v any }

func (o disabledoutlinestippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledoutlinestipple %s`, optionString(o.v))
}

// # Canvas(Disabledoutlinestipple(...))
//
// These options specify stipple patterns that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Indicates that the outline for the item should be drawn with a stipple pattern;
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -outline option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then the outline is drawn
// in a solid fashion.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
//
// # Canvas(Disabledoutlinestipple(...))
//
// These options specify stipple patterns that should be used to draw the
// outline of the item in its normal, active and disabled states.
// Indicates that the outline for the item should be drawn with a stipple pattern;
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -outline option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then the outline is drawn
// in a solid fashion.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
func Disabledoutlinestipple(value any) option {
	return disabledoutlinestippleOption{value}
}

type disabledstippleOption struct{ v any }

func (o disabledstippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledstipple %s`, optionString(o.v))
}

// # Canvas(Disabledstipple(...))
//
// These options specify stipple patterns that should be used to fill
// the item in its normal, active and disabled states.
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -fill option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then filling is done
// in a solid fashion.
// For the text item, it affects the actual text.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
//
// # Canvas(Disabledstipple(...))
//
// These options specify stipple patterns that should be used to fill
// the item in its normal, active and disabled states.
// bitmap specifies the stipple pattern to use, in any of the
// forms accepted by Tk_GetBitmap.
// If the -fill option has not been specified then this option
// has no effect.
// If bitmap is an empty string (the default), then filling is done
// in a solid fashion.
// For the text item, it affects the actual text.
// Note that stipples are not well supported on platforms that do not
// use X11 as their drawing API.
func Disabledstipple(value any) option {
	return disabledstippleOption{value}
}

type disabledwidthOption struct{ v any }

func (o disabledwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledwidth %s`, optionString(o.v))
}

// # Canvas(Disabledwidth(...))
//
// These options specify the width of the outline to be drawn around
// the item's region, in its normal, active and disabled states.
// outlineWidth may be in any of the forms described in the
// COORDINATES section above.
// If the -outline option has been specified as an empty string then
// this option has no effect. This option defaults to 1.0.
// For arcs, wide outlines will be drawn centered on the edges of the
// arc's region.
//
// # Canvas(Disabledwidth(...))
//
// These options specify the width of the outline to be drawn around
// the item's region, in its normal, active and disabled states.
// outlineWidth may be in any of the forms described in the
// COORDINATES section above.
// If the -outline option has been specified as an empty string then
// this option has no effect. This option defaults to 1.0.
// For arcs, wide outlines will be drawn centered on the edges of the
// arc's region.
func Disabledwidth(value any) option {
	return disabledwidthOption{value}
}

type displaycolumnsOption struct{ v any }

func (o displaycolumnsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-displaycolumns %s`, optionString(o.v))
}

// # TTreeview(Displaycolumns(...))
//
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
//
// # TTreeview(Displaycolumns(...))
//
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
func Displaycolumns(value any) option {
	return displaycolumnsOption{value}
}

type displayofOption struct{ v any }

func (o displayofOption) optionString(w *Window) string {
	return fmt.Sprintf(`-displayof %s`, optionString(o.v))
}

// # Send(Displayof(...))
//
// Specifies that the target application's main window is on the display
// of the window given by pathName, instead of the display containing
// the application's main window.
func Displayof(value any) option {
	return displayofOption{value}
}

type elementborderwidthOption struct{ v any }

func (o elementborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-elementborderwidth %s`, optionString(o.v))
}

// # Scrollbar(Elementborderwidth(...))
//
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
//
// # Scrollbar(Elementborderwidth(...))
//
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
func Elementborderwidth(value any) option {
	return elementborderwidthOption{value}
}

type elideOption struct{ v any }

func (o elideOption) optionString(w *Window) string {
	return fmt.Sprintf(`-elide %s`, optionString(o.v))
}

// # Text(Elide(...))
//
// Elide specifies whether the data should be elided. Elided data
// (characters, images, embedded windows, etc.) is not displayed and takes no
// space on screen, but further on behaves just as normal data.
//
// # Text(Elide(...))
//
// Find elided (hidden) text as well. By default only displayed text is searched.
//
// # Text(Elide(...))
//
// Elide specifies whether the data should be elided. Elided data
// (characters, images, embedded windows, etc.) is not displayed and takes no
// space on screen, but further on behaves just as normal data.
//
// # Text(Elide(...))
//
// Find elided (hidden) text as well. By default only displayed text is searched.
func Elide(value any) option {
	return elideOption{value}
}

type endlineOption struct{ v any }

func (o endlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-endline %s`, optionString(o.v))
}

// # Text(Endline(...))
//
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
//
// # Text(Endline(...))
//
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
func Endline(value any) option {
	return endlineOption{value}
}

type exactOption struct{ v any }

func (o exactOption) optionString(w *Window) string {
	return fmt.Sprintf(`-exact %s`, optionString(o.v))
}

// # Text(Exact(...))
//
// Use exact matching: the characters in the matching range must be identical to
// those in pattern. This is the default.
//
// # Text(Exact(...))
//
// Use exact matching: the characters in the matching range must be identical to
// those in pattern. This is the default.
func Exact(value any) option {
	return exactOption{value}
}

type expandOption struct{ v any }

func (o expandOption) optionString(w *Window) string {
	return fmt.Sprintf(`-expand %s`, optionString(o.v))
}

// # Pack(Expand(...))
//
// Specifies whether the content should be expanded to consume
// extra space in their container.
// Boolean may have any proper boolean value, such as 1
// or no.
// Defaults to 0.
//
// # TStyle(Expand(...))
//
// Specifies whether the allocated parcel is the entire cavity. If so,
// simultaneous specification of -side is ignored.
// Defaults to 0.
func Expand(value any) option {
	return expandOption{value}
}

type exportselectionOption struct{ v any }

func (o exportselectionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-exportselection %s`, optionString(o.v))
}

// Specifies whether or not a selection in the widget should also be
// the X selection.
// The value may have any of the forms accepted by 'Tcl_GetBoolean',
// such as 'true', 'false', '0', '1', 'yes', or 'no'.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.  The default is usually for widgets
// to export selections.
//
// # TCombobox(Exportselection(...))
//
// Boolean value.
// If set, the widget selection is linked to the X selection.
//
// # TCombobox(Exportselection(...))
//
// Boolean value.
// If set, the widget selection is linked to the X selection.
//
// # TEntry(Exportselection(...))
//
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
//
// # TEntry(Exportselection(...))
//
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
func Exportselection(value any) option {
	return exportselectionOption{value}
}

type extentOption struct{ v any }

func (o extentOption) optionString(w *Window) string {
	return fmt.Sprintf(`-extent %s`, optionString(o.v))
}

// # Canvas(Extent(...))
//
// Specifies the size of the angular range occupied by the arc.
// The arc's range extends for degrees degrees counter-clockwise
// from the starting angle given by the -start option.
// Degrees may be negative.
// If it is greater than 360 or less than -360, then degrees
// modulo 360 is used as the extent.
//
// # Canvas(Extent(...))
//
// Specifies the size of the angular range occupied by the arc.
// The arc's range extends for degrees degrees counter-clockwise
// from the starting angle given by the -start option.
// Degrees may be negative.
// If it is greater than 360 or less than -360, then degrees
// modulo 360 is used as the extent.
func Extent(value any) option {
	return extentOption{value}
}

type familyOption struct{ v any }

func (o familyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-family %s`, optionString(o.v))
}

// # Font(Family(...))
//
// The case-insensitive font family name.  Tk guarantees to support the font
// families named Courier (a monospaced
func Family(value any) option {
	return familyOption{value}
}

type fgOption struct{ v any }

func (o fgOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fg %s`, optionString(o.v))
}

// Specifies the normal foreground color to use when displaying the widget.
func Fg(value any) option {
	return fgOption{value}
}

type fgstippleOption struct{ v any }

func (o fgstippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fgstipple %s`, optionString(o.v))
}

// # Text(Fgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern when drawing
// text and other foreground information such as underlines. It may have any of
// the forms accepted by Tk_GetBitmap. If bitmap has not been
// specified, or if it is specified as an empty string, then a solid fill will be
// used.
//
// # Text(Fgstipple(...))
//
// Bitmap specifies a bitmap that is used as a stipple pattern when drawing
// text and other foreground information such as underlines. It may have any of
// the forms accepted by Tk_GetBitmap. If bitmap has not been
// specified, or if it is specified as an empty string, then a solid fill will be
// used.
func Fgstipple(value any) option {
	return fgstippleOption{value}
}

type fileOption struct{ v any }

func (o fileOption) optionString(w *Window) string {
	return fmt.Sprintf(`-file %s`, optionString(o.v))
}

// # Bitmap(File(...))
//
// name gives the name of a file whose contents define the
// source bitmap.
// The file must adhere to X11 bitmap format (e.g., as generated
// by the bitmap program).
//
// # Canvas(File(...))
//
// Specifies the name of the file in which to write the Postscript.
// If this option and the -channel option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Canvas(File(...))
//
// Specifies the name of the file in which to write the Postscript.
// If this option and the -channel option are
// not specified then the Postscript is returned as the
// result of the command.
//
// # Photo(File(...))
//
// name gives the name of a file that is to be read to supply data
// for the photo image.  The file format must be one of those for which
// there is an image file format handler that can read data.
//
// # TkMac(File(...))
//
// icon of file at given path
func File(value any) option {
	return fileOption{value}
}

type fileTypeOption struct{ v any }

func (o fileTypeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fileType %s`, optionString(o.v))
}

// # TkMac(FileType(...))
//
// icon of given file type
func FileType(value any) option {
	return fileTypeOption{value}
}

type filetypesOption struct{ v any }

func (o filetypesOption) optionString(w *Window) string {
	return fmt.Sprintf(`-filetypes %s`, optionString(o.v))
}

// # GetOpenFile(Filetypes(...))
//
// If a File types listbox exists in the file dialog on the particular
// platform, this option gives the filetypes in this listbox. When
// the user choose a filetype in the listbox, only the files of that type
// are listed. If this option is unspecified, or if it is set to the
// empty list, or if the File types listbox is not supported by the
// particular platform then all files are listed regardless of their
// types. See the section SPECIFYING FILE PATTERNS below for a
// discussion on the contents of filePatternList.
func Filetypes(value any) option {
	return filetypesOption{value}
}

type fillOption struct{ v any }

func (o fillOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fill %s`, optionString(o.v))
}

// # Canvas(Fill(...))
//
// # Canvas(Fill(...))
//
// # Pack(Fill(...))
//
// If a content's parcel is larger than its requested dimensions, this
// option may be used to stretch the content.
// Style must have one of the following values:
func Fill(value any) option {
	return fillOption{value}
}

type fixedOption struct{ v any }

func (o fixedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fixed %s`, optionString(o.v))
}

// # Font(Fixed(...))
//
// Returns a boolean flag that is
func Fixed(value any) option {
	return fixedOption{value}
}

type focusOption struct{ v any }

func (o focusOption) optionString(w *Window) string {
	return fmt.Sprintf(`-focus %s`, optionString(o.v))
}

// # Event(Focus(...))
//
// Boolean must be a boolean value;  it specifies the focus
// field for the event.
// Valid for Enter and Leave events.
// Corresponds to the %f substitution for binding scripts.
func Focus(value any) option {
	return focusOption{value}
}

type fontOption struct{ v any }

func (o fontOption) optionString(w *Window) string {
	return fmt.Sprintf(`-font %s`, optionString(o.v))
}

// Specifies the font to use when drawing text inside the widget.
// The value may have any of the forms described in the 'font' manual
// page under 'FONT DESCRIPTION'.
//
// # Canvas(Font(...))
//
// Specifies the font to use for the text item.
// FontName may be any string acceptable to Tk_GetFont.
// If this option is not specified, it defaults to a system-dependent
// font.
//
// # Canvas(Font(...))
//
// Specifies the font to use for the text item.
// FontName may be any string acceptable to Tk_GetFont.
// If this option is not specified, it defaults to a system-dependent
// font.
//
// # Fontchooser(Font(...))
//
// Specifies/returns the font that is currently selected in the dialog if it is
// visible, or that will be initially selected when the dialog is shown (if
// supported by the platform). Can be set to the empty string to indicate that no
// font should be selected. Fonts can be specified in any form given by the "FONT
// DESCRIPTION" section in the font manual page.
//
// # Menu(Font(...))
//
// Specifies the font to use when drawing the label or accelerator
// string in this entry.
// If this option is specified as an empty string (the default) then
// the -font option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Font(...))
//
// Specifies the font to use when drawing the label or accelerator
// string in this entry.
// If this option is specified as an empty string (the default) then
// the -font option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Text(Font(...))
//
// FontName is the name of a font to use for drawing characters. It may
// have any of the forms accepted by Tk_GetFont.
//
// # Text(Font(...))
//
// FontName is the name of a font to use for drawing characters. It may
// have any of the forms accepted by Tk_GetFont.
func Font(value any) option {
	return fontOption{value}
}

type fontmapOption struct{ v any }

func (o fontmapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fontmap %s`, optionString(o.v))
}

// # Canvas(Fontmap(...))
//
// VarName must be the name of an array variable
// that specifies a font mapping to use in the Postscript.
// Each element of varName must consist of a Tcl list with
// two elements, which are the name and point size of a Postscript font.
// When outputting Postscript commands for a particular font, Tk
// checks to see if varName contains an element with the same
// name as the font.
// If there is such an element, then the font information contained in
// that element is used in the Postscript.
// Otherwise Tk attempts to guess what Postscript font to use.
// Tk's guesses generally only work for well-known fonts such as
// Times and Helvetica and Courier, and only if the X font name does not
// omit any dashes up through the point size.
//
// # Canvas(Fontmap(...))
//
// VarName must be the name of an array variable
// that specifies a font mapping to use in the Postscript.
// Each element of varName must consist of a Tcl list with
// two elements, which are the name and point size of a Postscript font.
// When outputting Postscript commands for a particular font, Tk
// checks to see if varName contains an element with the same
// name as the font.
// If there is such an element, then the font information contained in
// that element is used in the Postscript.
// Otherwise Tk attempts to guess what Postscript font to use.
// Tk's guesses generally only work for well-known fonts such as
// Times and Helvetica and Courier, and only if the X font name does not
// omit any dashes up through the point size.
func Fontmap(value any) option {
	return fontmapOption{value}
}

type foregroundOption struct{ v any }

func (o foregroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-foreground %s`, optionString(o.v))
}

// Specifies the normal foreground color to use when displaying the widget.
//
// # Bitmap(Foreground(...))
//
// Specifies a foreground color for the image in any of the standard
// ways accepted by Tk.
//
// # Canvas(Foreground(...))
//
// # Canvas(Foreground(...))
//
// # Listbox(Foreground(...))
//
// Color specifies the foreground color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Listbox(Foreground(...))
//
// Color specifies the foreground color to use when displaying the
// item. It may have any of the forms accepted by Tk_GetColor.
//
// # Menu(Foreground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -foreground option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Menu(Foreground(...))
//
// Specifies a foreground color to use for displaying this entry when it
// is in the normal state (neither active nor disabled).
// This option is ignored on Aqua/macOS.
// If it is specified as an empty string (the default), then the
// -foreground option for the overall menu is used.
// This option is not available for separator or tear-off entries.
//
// # Text(Foreground(...))
//
// Color specifies the color to use when drawing text and other foreground
// information such as underlines. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Text(Foreground(...))
//
// Color specifies the color to use when drawing text and other foreground
// information such as underlines. It may have any of the forms accepted by
// Tk_GetColor.
func Foreground(value any) option {
	return foregroundOption{value}
}

type formatOption struct{ v any }

func (o formatOption) optionString(w *Window) string {
	return fmt.Sprintf(`-format %s`, optionString(o.v))
}

// # Photo(Format(...))
//
// Specifies the name of the file format for the data specified with the
// -data or -file option and optional arguments passed to
// the format handler. Note that the value of this option must be a Tcl list.
// This means that the braces may be omitted if the argument has only one
// word. Also, instead of braces, double quotes may be used for quoting.
//
// # Photo(Format(...))
//
// Specifies the name of the image file format handler to use and,
// optionally, arguments to the format handler.  Specifically, this
// subcommand searches for the first handler whose name matches an
// initial substring of format-name and which has the capability to
// write a string containing this image data.
//
// # Photo(Format(...))
//
// Specifies the format of the image data in data and, optionally,
// arguments to be passed to the format handler.
// Specifically, only image file format handlers whose names begin with
// format-name will be used while searching for an image data
// format handler to read the data.
// Note that the value of this option must be a Tcl list.
// This means that the braces may be omitted if the argument has only one
// word. Also, instead of braces, double quotes may be used for quoting.
//
// # Photo(Format(...))
//
// Specifies the format of the image data in filename and,
// optionally, additional options to the format handler.
// Specifically, only image file format handlers whose names begin with
// format-name will be used while searching for an image data
// format handler to read the data.
// Note that the value of this option must be a Tcl list.
// This means that the braces may be omitted if the argument has only one
// word. Also, instead of braces, double quotes may be used for quoting.
//
// # Photo(Format(...))
//
// Specifies the name of the image file format handler to be used to
// write the data to the file and, optionally, options to pass to the
// format handler.  Specifically, this subcommand searches for the first
// handler whose name matches an initial substring of format-name
// and which has the capability to write an image file.  If this option
// is not given, the format is guessed from the file extension. If that
// cannot be determined, this subcommand uses the first handler that has
// the capability to write an image file.
// Note that the value of this option must be a Tcl list.
// This means that the braces may be omitted if the argument has only one
// word. Also, instead of braces, double quotes may be used for quoting.
//
// # Spinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # Spinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # TSpinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # TSpinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
func Format(value any) option {
	return formatOption{value}
}

type forwardsOption struct{ v any }

func (o forwardsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-forwards %s`, optionString(o.v))
}

// # Text(Forwards(...))
//
// The search will proceed forward through the text, finding the first matching
// range starting at or after the position given by index. This is the
// default.
//
// # Text(Forwards(...))
//
// The search will proceed forward through the text, finding the first matching
// range starting at or after the position given by index. This is the
// default.
func Forwards(value any) option {
	return forwardsOption{value}
}

type fromOption struct{ v any }

func (o fromOption) optionString(w *Window) string {
	return fmt.Sprintf(`-from %s`, optionString(o.v))
}

// # Photo(From(...))
//
// Specifies a rectangular sub-region of the source image to be copied.
// (x1,y1) and (x2,y2) specify diagonally opposite corners of
// the rectangle.  If x2 and y2 are not specified, the
// default value is the bottom-right corner of the source image.  The
// pixels copied will include the left and top edges of the specified
// rectangle but not the bottom or right edges.  If the -from
// option is not given, the default is the whole source image.
//
// # Photo(From(...))
//
// Specifies a rectangular region of imageName to be returned.
// If only x1 and y1 are specified, the region
// extends from (x1,y1) to the bottom-right corner of
// imageName.  If all four coordinates are given, they specify
// diagonally opposite corners of the rectangular region, including x1,y1
// and excluding x2,y2.  The default, if this option is not given, is the
// whole image.
//
// # Photo(From(...))
//
// Specifies a rectangular sub-region of the image file data to be copied
// to the destination image.  If only x1 and y1 are
// specified, the region extends from (x1,y1) to the bottom-right
// corner of the image in the image file.  If all four coordinates are
// specified, they specify diagonally opposite corners or the region.
// The default, if this option is not specified, is the whole of the
// image in the image file.
//
// # Photo(From(...))
//
// Specifies a rectangular region of imageName to be written to the
// image file.  If only x1 and y1 are specified, the region
// extends from (x1,y1) to the bottom-right corner of
// imageName.  If all four coordinates are given, they specify
// diagonally opposite corners of the rectangular region.  The default,
// if this option is not given, is the whole image.
//
// # Scale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # Scale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # Spinbox(From(...))
//
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # Spinbox(From(...))
//
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # TScale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # TScale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # TSpinbox(From(...))
//
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
//
// # TSpinbox(From(...))
//
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
func From(value any) option {
	return fromOption{value}
}

type fullscreenOption struct{ v any }

func (o fullscreenOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fullscreen %s`, optionString(o.v))
}

// # Wm(Fullscreen(...))
//
// Places the window in a mode that takes up the entire screen, has no
// borders, and covers the general use area (i.e. Start menu and taskbar on
// Windows, dock and menubar on OSX, general window decorations on X11).
func Fullscreen(value any) option {
	return fullscreenOption{value}
}

type gammaOption struct{ v any }

func (o gammaOption) optionString(w *Window) string {
	return fmt.Sprintf(`-gamma %s`, optionString(o.v))
}

// # Photo(Gamma(...))
//
// Specifies that the colors allocated for displaying this image in a
// window should be corrected for a non-linear display with the specified
// gamma exponent value.  (The intensity produced by most
// CRT displays is a power function of the input value, to a good
// approximation; gamma is the exponent and is typically around 2).
// The value specified must be greater than zero.  The default
// value is one (no correction).  In general, values greater than one
// will make the image lighter, and values less than one will make it
// darker.
func Gamma(value any) option {
	return gammaOption{value}
}

type grayscaleOption struct{ v any }

func (o grayscaleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-grayscale %s`, optionString(o.v))
}

// # Photo(Grayscale(...))
//
// If this options is specified, the data will not contain color
// information. All pixel data will be transformed into grayscale.
//
// # Photo(Grayscale(...))
//
// If this options is specified, the data will not contain color
// information. All pixel data will be transformed into grayscale.
func Grayscale(value any) option {
	return grayscaleOption{value}
}

type handlepadOption struct{ v any }

func (o handlepadOption) optionString(w *Window) string {
	return fmt.Sprintf(`-handlepad %s`, optionString(o.v))
}

// # Panedwindow(Handlepad(...))
//
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Handlepad(...))
//
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
func Handlepad(value any) option {
	return handlepadOption{value}
}

type handlesizeOption struct{ v any }

func (o handlesizeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-handlesize %s`, optionString(o.v))
}

// # Panedwindow(Handlesize(...))
//
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Handlesize(...))
//
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
func Handlesize(value any) option {
	return handlesizeOption{value}
}

type heightOption struct{ v any }

func (o heightOption) optionString(w *Window) string {
	return fmt.Sprintf(`-height %s`, optionString(o.v))
}

// # Button(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Button(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Canvas(Height(...))
//
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Height(...))
//
// Specifies the height of the area of the canvas to print.
// Defaults to the height of the canvas window.
//
// # Canvas(Height(...))
//
// Provides a shortcut for creating a circular arc segment by defining the
// distance of the mid-point of the arc from its chord. When this option
// is used the coordinates are interpreted as the start and end coordinates
// of the chord, and the options -start and -extent are ignored.
// The value of distance has the following meaning:
//
// # Canvas(Height(...))
//
// Specifies the height to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever height it requests internally.
//
// # Canvas(Height(...))
//
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Height(...))
//
// Specifies the height of the area of the canvas to print.
// Defaults to the height of the canvas window.
//
// # Canvas(Height(...))
//
// Provides a shortcut for creating a circular arc segment by defining the
// distance of the mid-point of the arc from its chord. When this option
// is used the coordinates are interpreted as the start and end coordinates
// of the chord, and the options -start and -extent are ignored.
// The value of distance has the following meaning:
//
// # Canvas(Height(...))
//
// Specifies the height to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever height it requests internally.
//
// # Checkbutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Checkbutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Event(Height(...))
//
// Size must be a screen distance;  it specifies the height
// field for the event.  Valid for Configure events.
// Corresponds to the %h substitution for binding scripts.
//
// # Frame(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
//
// # Frame(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
//
// # Label(Height(...))
//
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Label(Height(...))
//
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Labelframe(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Labelframe(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Listbox(Height(...))
//
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
//
// # Listbox(Height(...))
//
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
//
// # Menubutton(Height(...))
//
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Menubutton(Height(...))
//
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Nsimage(Height(...))
//
// # Panedwindow(Height(...))
//
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
//
// # Panedwindow(Height(...))
//
// Specify a height for the window.  The height will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -height is not specified, then the
// height requested internally by the window will be used initially; the
// height may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Panedwindow(Height(...))
//
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
//
// # Panedwindow(Height(...))
//
// Specify a height for the window.  The height will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -height is not specified, then the
// height requested internally by the window will be used initially; the
// height may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Photo(Height(...))
//
// Specifies the height of the image, in pixels.  This option is useful
// primarily in situations where the user wishes to build up the contents
// of the image piece by piece.  A value of zero (the default) allows the
// image to expand or shrink vertically to fit the data stored in it.
//
// # Place(Height(...))
//
// Size specifies the height for window in screen units
// (i.e. any of the forms accepted by Tk_GetPixels).
// The height will be the outer dimension of window including its
// border, if any.
// If size is an empty string, or if no -height or
// -relheight option is specified, then the height requested
// internally by the window will be used.
//
// # Radiobutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Radiobutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Text(Height(...))
//
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
//
// # Text(Height(...))
//
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
//
// # Toplevel(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Toplevel(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # TCombobox(Height(...))
//
// Specifies the height of the pop-down listbox, in rows.
//
// # TCombobox(Height(...))
//
// Specifies the height of the pop-down listbox, in rows.
//
// # TFrame(Height(...))
//
// If specified, the widget's requested height in pixels.
//
// # TFrame(Height(...))
//
// If specified, the widget's requested height in pixels.
//
// # TImage(Height(...))
//
// Specifies a minimum height for the element.
// If less than zero, the base image's height is used as a default.
//
// # TLabelframe(Height(...))
//
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
//
// # TLabelframe(Height(...))
//
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
//
// # TNotebook(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
//
// # TNotebook(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
//
// # TPanedwindow(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
//
// # TPanedwindow(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
//
// # TTreeview(Height(...))
//
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
//
// # TTreeview(Height(...))
//
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
//
// # TVsapi(Height(...))
//
// Specifies the height of the element. See the comments for -width.
func Height(value any) option {
	return heightOption{value}
}

type hideOption struct{ v any }

func (o hideOption) optionString(w *Window) string {
	return fmt.Sprintf(`-hide %s`, optionString(o.v))
}

// # Panedwindow(Hide(...))
//
// Controls the visibility of a pane.  When the boolean is true
// (according to Tcl_GetBoolean) the pane will not be visible, but
// it will still be maintained in the list of panes.
//
// # Panedwindow(Hide(...))
//
// Controls the visibility of a pane.  When the boolean is true
// (according to Tcl_GetBoolean) the pane will not be visible, but
// it will still be maintained in the list of panes.
func Hide(value any) option {
	return hideOption{value}
}

type hidemarginOption struct{ v any }

func (o hidemarginOption) optionString(w *Window) string {
	return fmt.Sprintf(`-hidemargin %s`, optionString(o.v))
}

// # Menu(Hidemargin(...))
//
// Specifies whether the standard margins should be drawn for this menu
// entry. This is useful when creating palette with images in them, i.e.,
// color palettes, pattern palettes, etc. 1 indicates that the margin for
// the entry is hidden; 0 means that the margin is used.
//
// # Menu(Hidemargin(...))
//
// Specifies whether the standard margins should be drawn for this menu
// entry. This is useful when creating palette with images in them, i.e.,
// color palettes, pattern palettes, etc. 1 indicates that the margin for
// the entry is hidden; 0 means that the margin is used.
func Hidemargin(value any) option {
	return hidemarginOption{value}
}

type highlightbackgroundOption struct{ v any }

func (o highlightbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-highlightbackground %s`, optionString(o.v))
}

// Specifies the color to display in the traversal highlight region when
// the widget does not have the input focus.
func Highlightbackground(value any) option {
	return highlightbackgroundOption{value}
}

type highlightcolorOption struct{ v any }

func (o highlightcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-highlightcolor %s`, optionString(o.v))
}

// Specifies the color to use for the traversal highlight rectangle that is
// drawn around the widget when it has the input focus.
func Highlightcolor(value any) option {
	return highlightcolorOption{value}
}

type highlightthicknessOption struct{ v any }

func (o highlightthicknessOption) optionString(w *Window) string {
	return fmt.Sprintf(`-highlightthickness %s`, optionString(o.v))
}

// Specifies a non-negative value indicating the width of the highlight
// rectangle to draw around the outside of the widget when it has the
// input focus.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If the value is zero, no focus highlight is drawn around the widget.
func Highlightthickness(value any) option {
	return highlightthicknessOption{value}
}

type iconOption struct{ v any }

func (o iconOption) optionString(w *Window) string {
	return fmt.Sprintf(`-icon %s`, optionString(o.v))
}

// # MessageBox(Icon(...))
//
// Specifies an icon to display. IconImage must be one of the
// following: error, info, question or
// warning. If this option is not specified, then the info icon will be
// displayed.
func Icon(value any) option {
	return iconOption{value}
}

type idOption struct{ v any }

func (o idOption) optionString(w *Window) string {
	return fmt.Sprintf(`-id %s`, optionString(o.v))
}

// # TTreeview(Id(...))
//
// The column name.  This is a read-only option.
// For example, [$pathname column #n -id]
// returns the data column associated with display column n.
// The tree column has -id #0.
//
// # TTreeview(Id(...))
//
// The column name.  This is a read-only option.
// For example, [$pathname column #n -id]
// returns the data column associated with display column n.
// The tree column has -id #0.
func Id(value any) option {
	return idOption{value}
}

type imageOption struct{ v any }

func (o imageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-image %s`, optionString(o.v))
}

// Specifies an image to display in the widget, which must have been
// created with the 'image create' command.
// Typically, if the '-image' option is specified then it overrides other
// options that specify a bitmap or textual value to display in the
// widget, though this is controlled by the '-compound' option;
// the '-image' option may be reset to an empty string to re-enable
// a bitmap or text display.
//
// # Canvas(Image(...))
//
// # Canvas(Image(...))
//
// # Menu(Image(...))
//
// Specifies an image to display in the menu instead of a text string
// or bitmap.
// The image must have been created by some previous invocation of
// image create.
// This option overrides the -label and -bitmap options
// (as controlled by the -compound option)
// but may be reset to an empty string to enable a textual or
// bitmap label to be displayed.
// This option is not available for separator or tear-off entries.
//
// # Menu(Image(...))
//
// Specifies an image to display in the menu instead of a text string
// or bitmap.
// The image must have been created by some previous invocation of
// image create.
// This option overrides the -label and -bitmap options
// (as controlled by the -compound option)
// but may be reset to an empty string to enable a textual or
// bitmap label to be displayed.
// This option is not available for separator or tear-off entries.
//
// # Text(Image(...))
//
// Include information about images in the dump results.
//
// # Text(Image(...))
//
// Specifies the name of the Tk image to display in the annotation. If
// image is not a valid Tk image, then an error is returned.
//
// # Text(Image(...))
//
// Specifies the name of the Tk image to display in the annotation. If
// image is not a valid Tk image, then an error is returned.
//
// # Text(Image(...))
//
// Include information about images in the dump results.
//
// # TNotebook(Image(...))
//
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
//
// # TNotebook(Image(...))
//
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
//
// # TTreeview(Image(...))
//
// Specifies an image to display to the right of the column heading.
//
// # TTreeview(Image(...))
//
// Specifies an image to display to the right of the column heading.
func Image(value any) option {
	return imageOption{value}
}

type imageFileOption struct{ v any }

func (o imageFileOption) optionString(w *Window) string {
	return fmt.Sprintf(`-imageFile %s`, optionString(o.v))
}

// # TkMac(ImageFile(...))
//
// image at given path
func ImageFile(value any) option {
	return imageFileOption{value}
}

type inOption struct{ v any }

func (o inOption) optionString(w *Window) string {
	return fmt.Sprintf(`-in %s`, optionString(o.v))
}

// # Grid(In(...))
//
// Insert the window(s) in the container
// window given by container.  The default is the first window's
// parent window.
//
// # Pack(In(...))
//
// Insert the window at the end of the packing order for the container
// window given by container.
//
// # Place(In(...))
//
// Container specifies the path name of the window relative
// to which window is to be placed.
// Container must either be window's parent or a descendant
// of window's parent.
// In addition, container and window must both be descendants
// of the same top-level window.
// These restrictions are necessary to guarantee
// that window is visible whenever container is visible.
// If this option is not specified then the other window defaults to
// window's parent.
func In(value any) option {
	return inOption{value}
}

type inactiveselectbackgroundOption struct{ v any }

func (o inactiveselectbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-inactiveselectbackground %s`, optionString(o.v))
}

// # Text(Inactiveselectbackground(...))
//
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
//
// # Text(Inactiveselectbackground(...))
//
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
func Inactiveselectbackground(value any) option {
	return inactiveselectbackgroundOption{value}
}

type incrementOption struct{ v any }

func (o incrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-increment %s`, optionString(o.v))
}

// # Spinbox(Increment(...))
//
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
//
// # Spinbox(Increment(...))
//
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
//
// # TSpinbox(Increment(...))
//
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
//
// # TSpinbox(Increment(...))
//
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
func Increment(value any) option {
	return incrementOption{value}
}

type indicatoronOption struct{ v any }

func (o indicatoronOption) optionString(w *Window) string {
	return fmt.Sprintf(`-indicatoron %s`, optionString(o.v))
}

// # Checkbutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Checkbutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Menu(Indicatoron(...))
//
// Available only for checkbutton and radiobutton entries.
// Value is a boolean that determines whether or not the
// indicator should be displayed.
//
// # Menu(Indicatoron(...))
//
// Available only for checkbutton and radiobutton entries.
// Value is a boolean that determines whether or not the
// indicator should be displayed.
//
// # Menubutton(Indicatoron(...))
//
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
//
// # Menubutton(Indicatoron(...))
//
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
//
// # Radiobutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Radiobutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
func Indicatoron(value any) option {
	return indicatoronOption{value}
}

type initialcolorOption struct{ v any }

func (o initialcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-initialcolor %s`, optionString(o.v))
}

// # ChooseColor(Initialcolor(...))
//
// Specifies the color to display in the color dialog when it pops
// up. color must be in a form acceptable to the Tk_GetColor
// function.
func Initialcolor(value any) option {
	return initialcolorOption{value}
}

type initialdirOption struct{ v any }

func (o initialdirOption) optionString(w *Window) string {
	return fmt.Sprintf(`-initialdir %s`, optionString(o.v))
}

// # ChooseDirectory(Initialdir(...))
//
// Specifies that the directories in directory should be displayed
// when the dialog pops up. If this parameter is not specified,
// the initial directory defaults to the current working directory
// on non-Windows systems and on Windows systems prior to Vista.
// On Vista and later systems, the initial directory defaults to the last
// user-selected directory for the application. If the
// parameter specifies a relative path, the return value will convert the
// relative path to an absolute path.
//
// # GetOpenFile(Initialdir(...))
//
// Specifies that the files in directory should be displayed
// when the dialog pops up. If this parameter is not specified,
// the initial directory defaults to the current working directory
// on non-Windows systems and on Windows systems prior to Vista.
// On Vista and later systems, the initial directory defaults to the last
// user-selected directory for the application. If the
// parameter specifies a relative path, the return value will convert the
// relative path to an absolute path.
func Initialdir(value any) option {
	return initialdirOption{value}
}

type initialfileOption struct{ v any }

func (o initialfileOption) optionString(w *Window) string {
	return fmt.Sprintf(`-initialfile %s`, optionString(o.v))
}

// # GetOpenFile(Initialfile(...))
//
// Specifies a filename to be displayed in the dialog when it pops up.
func Initialfile(value any) option {
	return initialfileOption{value}
}

type insertbackgroundOption struct{ v any }

func (o insertbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertbackground %s`, optionString(o.v))
}

// Specifies the color to use as background in the area covered by the
// insertion cursor.  This color will normally override either the normal
// background for the widget (or the selection background if the insertion
// cursor happens to fall in the selection).
func Insertbackground(value any) option {
	return insertbackgroundOption{value}
}

type insertborderwidthOption struct{ v any }

func (o insertborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertborderwidth %s`, optionString(o.v))
}

// Specifies a non-negative value indicating the width
// of the 3-D border to draw around the insertion cursor.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
func Insertborderwidth(value any) option {
	return insertborderwidthOption{value}
}

type insertofftimeOption struct{ v any }

func (o insertofftimeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertofftime %s`, optionString(o.v))
}

// Specifies a non-negative integer value indicating the number of
// milliseconds the insertion cursor should remain
func Insertofftime(value any) option {
	return insertofftimeOption{value}
}

type insertontimeOption struct{ v any }

func (o insertontimeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertontime %s`, optionString(o.v))
}

// Specifies a non-negative integer value indicating the number of
// milliseconds the insertion cursor should remain
func Insertontime(value any) option {
	return insertontimeOption{value}
}

type insertunfocussedOption struct{ v any }

func (o insertunfocussedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertunfocussed %s`, optionString(o.v))
}

// # Text(Insertunfocussed(...))
//
// 8.6
//
// # Text(Insertunfocussed(...))
//
// 8.6
func Insertunfocussed(value any) option {
	return insertunfocussedOption{value}
}

type insertwidthOption struct{ v any }

func (o insertwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertwidth %s`, optionString(o.v))
}

// Specifies a  value indicating the total width of the insertion cursor.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If a border has been specified for the insertion
// cursor (using the '-insertborderwidth' option), the border
// will be drawn inside the width specified by the '-insertwidth'
// option.
func Insertwidth(value any) option {
	return insertwidthOption{value}
}

// See also [Event handlers]
//
// # Entry(Invalidcommand(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Entry(Invalidcommand(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Spinbox(Invalidcommand(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// # Spinbox(Invalidcommand(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// # TEntry(Invalidcommand(...))
//
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
//
// # TEntry(Invalidcommand(...))
//
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Invalidcommand(args ...any) option {
	return newEventHandler("-invalidcommand", args...)
}

// See also [Event handlers]
//
// # Entry(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Entry(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Spinbox(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// # Spinbox(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Invcmd(args ...any) option {
	return newEventHandler("-invcmd", args...)
}

type ipadxOption struct{ v any }

func (o ipadxOption) optionString(w *Window) string {
	return fmt.Sprintf(`-ipadx %s`, optionString(o.v))
}

// # Grid(Ipadx(...))
//
// The amount specifies how much horizontal internal padding to
// leave on each side of the content.  This is space is added
// inside the content border.
// The amount must be a valid screen distance, such as 2 or .5c.
// It defaults to 0.
//
// # Pack(Ipadx(...))
//
// Amount specifies how much horizontal internal padding to
// leave on each side of the content.
// Amount must be a valid screen distance, such as 2 or .5c.
// It defaults to 0.
func Ipadx(value any) option {
	return ipadxOption{value}
}

type ipadyOption struct{ v any }

func (o ipadyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-ipady %s`, optionString(o.v))
}

// # Grid(Ipady(...))
//
// The amount specifies how much vertical internal padding to
// leave on the top and bottom of the content.
// This space is added inside the content border.
// The amount  defaults to 0.
//
// # Pack(Ipady(...))
//
// Amount specifies how much vertical internal padding to
// leave on each side of the content.
// Amount  defaults to 0.
func Ipady(value any) option {
	return ipadyOption{value}
}

type isdarkOption struct{ v any }

func (o isdarkOption) optionString(w *Window) string {
	return fmt.Sprintf(`-isdark %s`, optionString(o.v))
}

// # Wm(Isdark(...))
//
// Returns a boolean value which is true if the window is currently in
// dark mode.
func Isdark(value any) option {
	return isdarkOption{value}
}

type joinstyleOption struct{ v any }

func (o joinstyleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-joinstyle %s`, optionString(o.v))
}

// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the line.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
// If the line only contains two points then this option is
// irrelevant.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the outline.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the line.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
// If the line only contains two points then this option is
// irrelevant.
//
// # Canvas(Joinstyle(...))
//
// Specifies the ways in which joints are to be drawn at the vertices
// of the outline.
// Style may have any of the forms accepted by Tk_GetJoinStyle
// (bevel, miter, or round).
// If this option is not specified then it defaults to round.
func Joinstyle(value any) option {
	return joinstyleOption{value}
}

type jumpOption struct{ v any }

func (o jumpOption) optionString(w *Window) string {
	return fmt.Sprintf(`-jump %s`, optionString(o.v))
}

// For widgets with a slider that can be dragged to adjust a value,
// such as scrollbars, this option determines when
// notifications are made about changes in the value.
// The option's value must be a boolean of the form accepted by
// 'Tcl_GetBoolean'.
// If the value is false, updates are made continuously as the
// slider is dragged.
// If the value is true, updates are delayed until the mouse button
// is released to end the drag;  at that point a single notification
// is made (the value
func Jump(value any) option {
	return jumpOption{value}
}

type justifyOption struct{ v any }

func (o justifyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-justify %s`, optionString(o.v))
}

// When there are multiple lines of text displayed in a widget, this
// option determines how the lines line up with each other.
// Must be one of 'left', 'center', or 'right'.
// 'Left' means that the lines' left edges all line up, 'center'
// means that the lines' centers are aligned, and 'right' means
// that the lines' right edges line up.
//
// # Canvas(Justify(...))
//
// Specifies how to justify the text within its bounding region.
// How must be one of the values left, right,
// or center.
// This option will only matter if the text is displayed as multiple
// lines.
// If the option is omitted, it defaults to left.
//
// # Canvas(Justify(...))
//
// Specifies how to justify the text within its bounding region.
// How must be one of the values left, right,
// or center.
// This option will only matter if the text is displayed as multiple
// lines.
// If the option is omitted, it defaults to left.
//
// # Message(Justify(...))
//
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
//
// # Message(Justify(...))
//
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
//
// # Text(Justify(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then justify determines how to justify the
// line. It must be one of left, right, or center. If a line
// wraps, then the justification for each line on the display is determined by
// the first non-elided character of that display line.
//
// # Text(Justify(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then justify determines how to justify the
// line. It must be one of left, right, or center. If a line
// wraps, then the justification for each line on the display is determined by
// the first non-elided character of that display line.
//
// # TCombobox(Justify(...))
//
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
//
// # TCombobox(Justify(...))
//
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
//
// # TEntry(Justify(...))
//
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
//
// # TEntry(Justify(...))
//
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
func Justify(value any) option {
	return justifyOption{value}
}

type keycodeOption struct{ v any }

func (o keycodeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-keycode %s`, optionString(o.v))
}

// # Event(Keycode(...))
//
// Number  must be an integer;  it specifies the keycode
// field for the event.
// Valid for Key and KeyRelease events.
// Corresponds to the %k substitution for binding scripts.
func Keycode(value any) option {
	return keycodeOption{value}
}

type keysymOption struct{ v any }

func (o keysymOption) optionString(w *Window) string {
	return fmt.Sprintf(`-keysym %s`, optionString(o.v))
}

// # Event(Keysym(...))
//
// Name must be the name of a valid keysym, such as g,
// space, or Return;  its corresponding
// keycode value is used as the keycode field for event, overriding
// any detail specified in the base event argument.
// Valid for Key and KeyRelease events.
// Corresponds to the %K substitution for binding scripts.
func Keysym(value any) option {
	return keysymOption{value}
}

type labelOption struct{ v any }

func (o labelOption) optionString(w *Window) string {
	return fmt.Sprintf(`-label %s`, optionString(o.v))
}

// # Menu(Lbl(...))
//
// Specifies a string to display as an identifying label in the menu
// entry.  Not available for separator or tear-off entries.
//
// # Menu(Lbl(...))
//
// Specifies a string to display as an identifying label in the menu
// entry.  Not available for separator or tear-off entries.
//
// # Scale(Lbl(...))
//
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
//
// # Scale(Lbl(...))
//
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
func Lbl(value any) option {
	return labelOption{value}
}

type labelanchorOption struct{ v any }

func (o labelanchorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-labelanchor %s`, optionString(o.v))
}

// # Labelframe(Labelanchor(...))
//
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
//
// # Labelframe(Labelanchor(...))
//
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
//
// # TLabelframe(Labelanchor(...))
//
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
//
// # TLabelframe(Labelanchor(...))
//
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
func Labelanchor(value any) option {
	return labelanchorOption{value}
}

type labelwidgetOption struct{ v any }

func (o labelwidgetOption) optionString(w *Window) string {
	return fmt.Sprintf(`-labelwidget %s`, optionString(o.v))
}

// # Labelframe(Labelwidget(...))
//
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
//
// # Labelframe(Labelwidget(...))
//
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
//
// # TLabelframe(Labelwidget(...))
//
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe”s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
//
// # TLabelframe(Labelwidget(...))
//
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe”s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
func Labelwidget(value any) option {
	return labelwidgetOption{value}
}

type lengthOption struct{ v any }

func (o lengthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-length %s`, optionString(o.v))
}

// # Scale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
//
// # Scale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
//
// # TProgressbar(Length(...))
//
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
//
// # TProgressbar(Length(...))
//
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
//
// # TScale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
//
// # TScale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
func Length(value any) option {
	return lengthOption{value}
}

type linespaceOption struct{ v any }

func (o linespaceOption) optionString(w *Window) string {
	return fmt.Sprintf(`-linespace %s`, optionString(o.v))
}

// # Font(Linespace(...))
//
// Returns how far apart vertically in pixels two lines of text using the same
// font should be placed so that none of the characters in one line overlap any
// of the characters in the other line.  This is generally the sum of the ascent
// above the baseline line plus the descent below the baseline.
func Linespace(value any) option {
	return linespaceOption{value}
}

type listvariableOption struct{ v any }

func (o listvariableOption) optionString(w *Window) string {
	return fmt.Sprintf(`-listvariable %s`, optionString(o.v))
}

// # Listbox(Listvariable(...))
//
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
//
// # Listbox(Listvariable(...))
//
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
func Listvariable(value any) option {
	return listvariableOption{value}
}

type lmargin1Option struct{ v any }

func (o lmargin1Option) optionString(w *Window) string {
	return fmt.Sprintf(`-lmargin1 %s`, optionString(o.v))
}

// # Text(Lmargin1(...))
//
// If the first non-elided character of a text line has a tag for which this
// option has been specified, then pixels specifies how much the line
// should be indented from the left edge of the window. Pixels may have any
// of the standard forms for screen distances. If a line of text wraps, this
// option only applies to the first line on the display; the -lmargin2
// option controls the indentation for subsequent lines.
//
// # Text(Lmargin1(...))
//
// If the first non-elided character of a text line has a tag for which this
// option has been specified, then pixels specifies how much the line
// should be indented from the left edge of the window. Pixels may have any
// of the standard forms for screen distances. If a line of text wraps, this
// option only applies to the first line on the display; the -lmargin2
// option controls the indentation for subsequent lines.
func Lmargin1(value any) option {
	return lmargin1Option{value}
}

type lmargin2Option struct{ v any }

func (o lmargin2Option) optionString(w *Window) string {
	return fmt.Sprintf(`-lmargin2 %s`, optionString(o.v))
}

// # Text(Lmargin2(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, and if the display line is not the first for its
// text line (i.e., the text line has wrapped), then pixels specifies how
// much the line should be indented from the left edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled, and it only applies to the
// second and later display lines for a text line.
//
// # Text(Lmargin2(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, and if the display line is not the first for its
// text line (i.e., the text line has wrapped), then pixels specifies how
// much the line should be indented from the left edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled, and it only applies to the
// second and later display lines for a text line.
func Lmargin2(value any) option {
	return lmargin2Option{value}
}

type lmargincolorOption struct{ v any }

func (o lmargincolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-lmargincolor %s`, optionString(o.v))
}

// # Text(Lmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -lmargin1 or
// -lmargin2. It may have any of the forms accepted by
// Tk_GetColor. If color has not been specified, or if it is
// specified as an empty string, then the color used is specified by the
// -background tag option (or, if this is also unspecified, by the
// -background widget option).
//
// # Text(Lmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -lmargin1 or
// -lmargin2. It may have any of the forms accepted by
// Tk_GetColor. If color has not been specified, or if it is
// specified as an empty string, then the color used is specified by the
// -background tag option (or, if this is also unspecified, by the
// -background widget option).
func Lmargincolor(value any) option {
	return lmargincolorOption{value}
}

type marginsOption struct{ v any }

func (o marginsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-margins %s`, optionString(o.v))
}

// # TVsapi(Margins(...))
//
// Specifies the elements exterior padding.
// padding is a list of up to four integers specifying
// the left, top, right and bottom padding quantities respectively.
// This option may not be mixed with any other options.
func Margins(value any) option {
	return marginsOption{value}
}

type markOption struct{ v any }

func (o markOption) optionString(w *Window) string {
	return fmt.Sprintf(`-mark %s`, optionString(o.v))
}

// # Text(Mark(...))
//
// Include information about marks in the dump results.
//
// # Text(Mark(...))
//
// Include information about marks in the dump results.
func Mark(value any) option {
	return markOption{value}
}

type maskdataOption struct{ v any }

func (o maskdataOption) optionString(w *Window) string {
	return fmt.Sprintf(`-maskdata %s`, optionString(o.v))
}

// # Bitmap(Maskdata(...))
//
// Specifies the contents of the mask as a string.
// The string must adhere to X11 bitmap format (e.g., as generated
// by the bitmap program).
// If both the -maskdata and -maskfile options are specified,
// the -maskdata option takes precedence.
func Maskdata(value any) option {
	return maskdataOption{value}
}

type maskfileOption struct{ v any }

func (o maskfileOption) optionString(w *Window) string {
	return fmt.Sprintf(`-maskfile %s`, optionString(o.v))
}

// # Bitmap(Maskfile(...))
//
// name gives the name of a file whose contents define the
// mask.
// The file must adhere to X11 bitmap format (e.g., as generated
// by the bitmap program).
func Maskfile(value any) option {
	return maskfileOption{value}
}

type maximumOption struct{ v any }

func (o maximumOption) optionString(w *Window) string {
	return fmt.Sprintf(`-maximum %s`, optionString(o.v))
}

// # TProgressbar(Maximum(...))
//
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
//
// # TProgressbar(Maximum(...))
//
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
func Maximum(value any) option {
	return maximumOption{value}
}

type maxundoOption struct{ v any }

func (o maxundoOption) optionString(w *Window) string {
	return fmt.Sprintf(`-maxundo %s`, optionString(o.v))
}

// # Text(Maxundo(...))
//
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
//
// # Text(Maxundo(...))
//
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
func Maxundo(value any) option {
	return maxundoOption{value}
}

type menuOption struct{ v any }

func (o menuOption) optionString(w *Window) string {
	return fmt.Sprintf(`-menu %s`, optionString(o.v))
}

// # Menu(Mnu(...))
//
// Available only for cascade entries.  Specifies the path name of
// the submenu associated with this entry.
// The submenu must be a child of the menu.
//
// # Menu(Mnu(...))
//
// Available only for cascade entries.  Specifies the path name of
// the submenu associated with this entry.
// The submenu must be a child of the menu.
//
// # Menubutton(Mnu(...))
//
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
//
// # Menubutton(Mnu(...))
//
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
//
// # Toplevel(Mnu(...))
//
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
//
// # Toplevel(Mnu(...))
//
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
//
// # TMenubutton(Mnu(...))
//
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
//
// # TMenubutton(Mnu(...))
//
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
func Mnu(value any) option {
	return menuOption{value}
}

type messageOption struct{ v any }

func (o messageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-message %s`, optionString(o.v))
}

// # ChooseDirectory(Msg(...))
//
// Specifies a message to include in the client area of the dialog.
// This is only available on Mac OS X.
//
// # GetOpenFile(Msg(...))
//
// Specifies a message to include in the client area of the dialog.
// This is only available on Mac OS X.
//
// # MessageBox(Msg(...))
//
// Specifies the message to display in this message box. The
// default value is an empty string.
func Msg(value any) option {
	return messageOption{value}
}

type metadataOption struct{ v any }

func (o metadataOption) optionString(w *Window) string {
	return fmt.Sprintf(`-metadata %s`, optionString(o.v))
}

// # Photo(Metadata(...))
//
// Set the metadata dictionary of the image.
// Additional keys may be set within the metadata dictionary of the image,
// if image data is processed due to a -file or -data options
// and the driver outputs any metadata keys.
// See section METADATA DICTIONARY below.
//
// # Photo(Metadata(...))
//
// Image format handler may use metadata to be included in the returned
// data string.
// The specified metadata is passed to the driver for inclusion in the
// data.
// If no -metadata option is given, the current metadata of the
// image is used.
//
// # Photo(Metadata(...))
//
// A specified metadata is passed to the image format driver when interpreting
// the data.
// Note that the current metadata of the image is not passed to the format driver
// and is not changed by the command.
//
// # Photo(Metadata(...))
//
// A specified metadata is passed to the image format driver when interpreting
// the data.
// Note that the current metadata of the image is not passed to the format driver
// and is not changed by the command.
//
// # Photo(Metadata(...))
//
// Image format handler may use metadata to be included in the written file.
// The specified metadata is passed to the driver for inclusion in the
// file.
// If no -metadata option is given, the current metadata of the
// image is used.
func Metadata(value any) option {
	return metadataOption{value}
}

type minsizeOption struct{ v any }

func (o minsizeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-minsize %s`, optionString(o.v))
}

// # Panedwindow(Minsize(...))
//
// Specifies that the size of the window cannot be made less than
// n.  This constraint only affects the size of the widget in the
// paned dimension \(em the x dimension for horizontal panedwindows, the y
// dimension for vertical panedwindows.  May be any value accepted by
// Tk_GetPixels.
//
// # Panedwindow(Minsize(...))
//
// Specifies that the size of the window cannot be made less than
// n.  This constraint only affects the size of the widget in the
// paned dimension \(em the x dimension for horizontal panedwindows, the y
// dimension for vertical panedwindows.  May be any value accepted by
// Tk_GetPixels.
func Minsize(value any) option {
	return minsizeOption{value}
}

type minwidthOption struct{ v any }

func (o minwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-minwidth %s`, optionString(o.v))
}

// # TTreeview(Minwidth(...))
//
// The minimum width of the column in pixels.
// The treeview widget will not make the column any smaller than
// -minwidth when the widget is resized or the user drags a
// heading column separator.  Default is 20 pixels.
//
// # TTreeview(Minwidth(...))
//
// The minimum width of the column in pixels.
// The treeview widget will not make the column any smaller than
// -minwidth when the widget is resized or the user drags a
// heading column separator.  Default is 20 pixels.
func Minwidth(value any) option {
	return minwidthOption{value}
}

type modeOption struct{ v any }

func (o modeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-mode %s`, optionString(o.v))
}

// # Event(Mode(...))
//
// Notify specifies the mode field for the event and must be
// one of NotifyNormal, NotifyGrab, NotifyUngrab, or
// NotifyWhileGrabbed.
// Valid for Enter, Leave, FocusIn, and
// FocusOut events.
// Corresponds to the %m substitution for binding scripts.
//
// # TProgressbar(Mode(...))
//
// One of 'determinate' or 'indeterminate'.
//
// # TProgressbar(Mode(...))
//
// One of 'determinate' or 'indeterminate'.
func Mode(value any) option {
	return modeOption{value}
}

type modifiedOption struct{ v any }

func (o modifiedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-modified %s`, optionString(o.v))
}

// # Wm(Modified(...))
//
// Specifies the modification state of the window (determines whether the
// window close widget contains the modification indicator and whether the
// proxy icon is draggable).
func Modified(value any) option {
	return modifiedOption{value}
}

type multipleOption struct{ v any }

func (o multipleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-multiple %s`, optionString(o.v))
}

// # GetOpenFile(Multiple(...))
//
// Allows the user to choose multiple files from the Open dialog.
func Multiple(value any) option {
	return multipleOption{value}
}

type mustexistOption struct{ v any }

func (o mustexistOption) optionString(w *Window) string {
	return fmt.Sprintf(`-mustexist %s`, optionString(o.v))
}

// # ChooseDirectory(Mustexist(...))
//
// Specifies whether the user may specify non-existent directories.  If
// this parameter is true, then the user may only select directories that
// already exist.  The default value is false.
func Mustexist(value any) option {
	return mustexistOption{value}
}

type nameOption struct{ v any }

func (o nameOption) optionString(w *Window) string {
	return fmt.Sprintf(`-name %s`, optionString(o.v))
}

// # Text(Name(...))
//
// Specifies the name by which this image instance may be referenced in the text
// widget. If ImageName is not supplied, then the name of the Tk image is
// used instead. If the imageName is already in use, #nn is appended
// to the end of the name as described above.
//
// # Text(Name(...))
//
// Specifies the name by which this image instance may be referenced in the text
// widget. If ImageName is not supplied, then the name of the Tk image is
// used instead. If the imageName is already in use, #nn is appended
// to the end of the name as described above.
func Name(value any) option {
	return nameOption{value}
}

type namedImageOption struct{ v any }

func (o namedImageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-namedImage %s`, optionString(o.v))
}

// # TkMac(NamedImage(...))
//
// named NSImage for given name
func NamedImage(value any) option {
	return namedImageOption{value}
}

type nocaseOption struct{ v any }

func (o nocaseOption) optionString(w *Window) string {
	return fmt.Sprintf(`-nocase %s`, optionString(o.v))
}

// # Text(Nocase(...))
//
// Ignore case differences between the pattern and the text.
//
// # Text(Nocase(...))
//
// Ignore case differences between the pattern and the text.
func Nocase(value any) option {
	return nocaseOption{value}
}

type nolinestopOption struct{ v any }

func (o nolinestopOption) optionString(w *Window) string {
	return fmt.Sprintf(`-nolinestop %s`, optionString(o.v))
}

// # Text(Nolinestop(...))
//
// This allows . and [^ sequences to match the newline character
// \en, which they will otherwise not do (see the regexp command for
// details). This option is only meaningful if -regexp is also given, and
// an error will be thrown otherwise. For example, to match the entire text, use
//
// # Text(Nolinestop(...))
//
// This allows . and [^ sequences to match the newline character
// \en, which they will otherwise not do (see the regexp command for
// details). This option is only meaningful if -regexp is also given, and
// an error will be thrown otherwise. For example, to match the entire text, use
func Nolinestop(value any) option {
	return nolinestopOption{value}
}

type notifyOption struct{ v any }

func (o notifyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-notify %s`, optionString(o.v))
}

// # Wm(Notify(...))
//
// Specifies process notification state (bouncing of the application dock icon).
func Notify(value any) option {
	return notifyOption{value}
}

type offreliefOption struct{ v any }

func (o offreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-offrelief %s`, optionString(o.v))
}

// # Checkbutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Checkbutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Radiobutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Radiobutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
func Offrelief(value any) option {
	return offreliefOption{value}
}

type offsetOption struct{ v any }

func (o offsetOption) optionString(w *Window) string {
	return fmt.Sprintf(`-offset %s`, optionString(o.v))
}

// # Canvas(Offset(...))
//
// Specifies the offset of stipples. The offset value can be of the form
// x,y or side, where side can be n, ne, e,
// se, s, sw, w, nw, or center. In the
// first case the origin is the origin of the toplevel of the current window.
// For the canvas itself and canvas objects the origin is the canvas origin,
// but putting # in front of the coordinate pair indicates using the
// toplevel origin instead. For canvas objects, the -offset option is
// used for stippling as well. For the line and polygon canvas items you can
// also specify an index as argument, which connects the stipple origin to one
// of the coordinate points of the line/polygon. Note that stipple offsets are
// only supported on X11; they are silently ignored on other platforms.
//
// # Canvas(Offset(...))
//
// Specifies the offset of stipples. The offset value can be of the form
// x,y or side, where side can be n, ne, e,
// se, s, sw, w, nw, or center. In the
// first case the origin is the origin of the toplevel of the current window.
// For the canvas itself and canvas objects the origin is the canvas origin,
// but putting # in front of the coordinate pair indicates using the
// toplevel origin instead. For canvas objects, the -offset option is
// used for stippling as well. For the line and polygon canvas items you can
// also specify an index as argument, which connects the stipple origin to one
// of the coordinate points of the line/polygon. Note that stipple offsets are
// only supported on X11; they are silently ignored on other platforms.
//
// # Text(Offset(...))
//
// Pixels specifies an amount by which the text's baseline should be offset
// vertically from the baseline of the overall line, in pixels. For example, a
// positive offset can be used for superscripts and a negative offset can be used
// for subscripts. Pixels may have any of the standard forms for screen
// distances.
//
// # Text(Offset(...))
//
// Pixels specifies an amount by which the text's baseline should be offset
// vertically from the baseline of the overall line, in pixels. For example, a
// positive offset can be used for superscripts and a negative offset can be used
// for subscripts. Pixels may have any of the standard forms for screen
// distances.
func Offset(value any) option {
	return offsetOption{value}
}

type offvalueOption struct{ v any }

func (o offvalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-offvalue %s`, optionString(o.v))
}

// # Checkbutton(Offvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
//
// # Checkbutton(Offvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
//
// # Menu(Offvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is
// deselected.
//
// # Menu(Offvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is
// deselected.
//
// # TCheckbutton(Offvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
//
// # TCheckbutton(Offvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
func Offvalue(value any) option {
	return offvalueOption{value}
}

type onvalueOption struct{ v any }

func (o onvalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-onvalue %s`, optionString(o.v))
}

// # Checkbutton(Onvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
//
// # Checkbutton(Onvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
//
// # Menu(Onvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
//
// # Menu(Onvalue(...))
//
// Available only for checkbutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
//
// # TCheckbutton(Onvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
//
// # TCheckbutton(Onvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
func Onvalue(value any) option {
	return onvalueOption{value}
}

type opaqueresizeOption struct{ v any }

func (o opaqueresizeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-opaqueresize %s`, optionString(o.v))
}

// # Panedwindow(Opaqueresize(...))
//
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
//
// # Panedwindow(Opaqueresize(...))
//
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
func Opaqueresize(value any) option {
	return opaqueresizeOption{value}
}

type orientOption struct{ v any }

func (o orientOption) optionString(w *Window) string {
	return fmt.Sprintf(`-orient %s`, optionString(o.v))
}

// For widgets that can lay themselves out with either a horizontal
// or vertical orientation, such as scrollbars, this option specifies
// which orientation should be used.  Must be either 'horizontal'
// or 'vertical' or an abbreviation of one of these.
//
// # TPanedwindow(Orient(...))
//
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
//
// # TPanedwindow(Orient(...))
//
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
//
// # TProgressbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
//
// # TProgressbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
//
// # TScale(Orient(...))
//
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
//
// # TScale(Orient(...))
//
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
//
// # TScrollbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
//
// # TScrollbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
//
// # TSeparator(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
//
// # TSeparator(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
func Orient(value any) option {
	return orientOption{value}
}

type osTypeOption struct{ v any }

func (o osTypeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-osType %s`, optionString(o.v))
}

// # TkMac(OsType(...))
//
// icon of given 4-char OSType file type
func OsType(value any) option {
	return osTypeOption{value}
}

type outlineOption struct{ v any }

func (o outlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-outline %s`, optionString(o.v))
}

// # Canvas(Outline(...))
//
// # Canvas(Outline(...))
func Outline(value any) option {
	return outlineOption{value}
}

type outlineoffsetOption struct{ v any }

func (o outlineoffsetOption) optionString(w *Window) string {
	return fmt.Sprintf(`-outlineoffset %s`, optionString(o.v))
}

// # Canvas(Outlineoffset(...))
//
// Specifies the offset of the stipple pattern used for outlines, in the same way
// that the -outline option controls fill stipples. (See the
// -outline option for a description of the syntax of offset.)
//
// # Canvas(Outlineoffset(...))
//
// Specifies the offset of the stipple pattern used for outlines, in the same way
// that the -outline option controls fill stipples. (See the
// -outline option for a description of the syntax of offset.)
func Outlineoffset(value any) option {
	return outlineoffsetOption{value}
}

type outlinestippleOption struct{ v any }

func (o outlinestippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-outlinestipple %s`, optionString(o.v))
}

// # Canvas(Outlinestipple(...))
//
// # Canvas(Outlinestipple(...))
func Outlinestipple(value any) option {
	return outlinestippleOption{value}
}

type overlapOption struct{ v any }

func (o overlapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-overlap %s`, optionString(o.v))
}

// # Text(Overlap(...))
//
// When performing -all searches, the normal behaviour is that matches
// which overlap an already-found match will not be returned. This switch changes
// that behaviour so that all matches which are not totally enclosed within
// another match are returned. For example, applying an -overlap search of
// the pattern
//
// # Text(Overlap(...))
//
// When performing -all searches, the normal behaviour is that matches
// which overlap an already-found match will not be returned. This switch changes
// that behaviour so that all matches which are not totally enclosed within
// another match are returned. For example, applying an -overlap search of
// the pattern
func Overlap(value any) option {
	return overlapOption{value}
}

type overreliefOption struct{ v any }

func (o overreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-overrelief %s`, optionString(o.v))
}

// # Button(Overrelief(...))
//
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
//
// # Button(Overrelief(...))
//
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
//
// # Checkbutton(Overrelief(...))
//
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
//
// # Checkbutton(Overrelief(...))
//
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
//
// # Radiobutton(Overrelief(...))
//
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
//
// # Radiobutton(Overrelief(...))
//
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
func Overrelief(value any) option {
	return overreliefOption{value}
}

type overrideOption struct{ v any }

func (o overrideOption) optionString(w *Window) string {
	return fmt.Sprintf(`-override %s`, optionString(o.v))
}

// # Event(Override(...))
//
// Boolean must be a boolean value;  it specifies the
// override_redirect field for the event.
// Valid for Map, Reparent, and Configure events.
// Corresponds to the %o substitution for binding scripts.
func Override(value any) option {
	return overrideOption{value}
}

type overstrikeOption struct{ v any }

func (o overstrikeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-overstrike %s`, optionString(o.v))
}

// # Font(Overstrike(...))
//
// The value is a boolean flag that specifies whether a horizontal line should
// be drawn through the middle of characters in this font.  The default value
// for overstrike is false.
//
// # Text(Overstrike(...))
//
// Specifies whether or not to draw a horizontal rule through the middle of
// characters. Boolean may have any of the forms accepted by
// Tcl_GetBoolean.
//
// # Text(Overstrike(...))
//
// Specifies whether or not to draw a horizontal rule through the middle of
// characters. Boolean may have any of the forms accepted by
// Tcl_GetBoolean.
func Overstrike(value any) option {
	return overstrikeOption{value}
}

type overstrikefgOption struct{ v any }

func (o overstrikefgOption) optionString(w *Window) string {
	return fmt.Sprintf(`-overstrikefg %s`, optionString(o.v))
}

// # Text(Overstrikefg(...))
//
// Color specifies the color to use when displaying the overstrike. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
//
// # Text(Overstrikefg(...))
//
// Color specifies the color to use when displaying the overstrike. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
func Overstrikefg(value any) option {
	return overstrikefgOption{value}
}

type paddingOption struct{ v any }

func (o paddingOption) optionString(w *Window) string {
	return fmt.Sprintf(`-padding %s`, optionString(o.v))
}

// # TImage(Padding(...))
//
// Specifies the element's interior padding.
// The padding is a list of up to four length specifications
// left top right bottom.
// If fewer than four elements are specified,
// bottom defaults to top,
// right defaults to left, and
// top defaults to left.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
// Defaults to -border if not specified.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
//
// # TVsapi(Padding(...))
//
// Specify the element's interior padding.
// padding is a list of up to four integers specifying
// the left, top, right and bottom padding quantities respectively.
// If fewer than four elements are specified,
// bottom defaults to top,
// right defaults to left, and
// top defaults to left.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
// This option may not be mixed with any other options.
func Padding(value any) option {
	return paddingOption{value}
}

type padxOption struct{ v any }

func (o padxOption) optionString(w *Window) string {
	return fmt.Sprintf(`-padx %s`, optionString(o.v))
}

// Specifies a non-negative value indicating how much extra space
// to request for the widget in the X-direction.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// When computing how large a window it needs, the widget will
// add this amount to the width it would normally need (as determined
// by the width of the things displayed in the widget);  if the geometry
// manager can satisfy this request, the widget will end up with extra
// internal space to the left and/or right of what it displays inside.
// Most widgets only use this option for padding text:  if they are
// displaying a bitmap or image, then they usually ignore padding
// options.
//
// # Grid(Padx(...))
//
// The amount specifies how much horizontal external padding to
// leave on each side of the content, in screen units.
// Amount may be a list
// of two values to specify padding for left and right separately.
// The amount defaults to 0.
// This space is added outside the content border.
//
// # Pack(Padx(...))
//
// Amount specifies how much horizontal external padding to
// leave on each side of the content.  Amount may be a list
// of two values to specify padding for left and right separately.
// Amount defaults to 0.
//
// # Panedwindow(Padx(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the X-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Panedwindow(Padx(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the X-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded window. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded image. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded window. It may have any of the usual forms defined for a screen
// distance.
//
// # Text(Padx(...))
//
// Pixels specifies the amount of extra space to leave on each side of the
// embedded image. It may have any of the usual forms defined for a screen
// distance.
func Padx(value any) option {
	return padxOption{value}
}

type padyOption struct{ v any }

func (o padyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pady %s`, optionString(o.v))
}

// Specifies a non-negative value indicating how much extra space
// to request for the widget in the Y-direction.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// When computing how large a window it needs, the widget will add
// this amount to the height it would normally need (as determined by
// the height of the things displayed in the widget);  if the geometry
// manager can satisfy this request, the widget will end up with extra
// internal space above and/or below what it displays inside.
// Most widgets only use this option for padding text:  if they are
// displaying a bitmap or image, then they usually ignore padding
// options.
//
// # Grid(Pady(...))
//
// The amount specifies how much vertical external padding to
// leave on the top and bottom of the content, in screen units.
// Amount may be a list
// of two values to specify padding for top and bottom separately.
// The amount defaults to 0.
// This space is added outside the content border.
//
// # Pack(Pady(...))
//
// Amount specifies how much vertical external padding to
// leave on each side of the content.  Amount may be a list
// of two values to specify padding for top and bottom separately.
// Amount defaults to 0.
//
// # Panedwindow(Pady(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the Y-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Panedwindow(Pady(...))
//
// Specifies a non-negative value indicating how much extra space to
// leave on each side of the window in the Y-direction.  The value may
// have any of the forms accepted by Tk_GetPixels.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded window. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded image. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded window. It may have any of the usual forms defined
// for a screen distance.
//
// # Text(Pady(...))
//
// Pixels specifies the amount of extra space to leave on the top and on
// the bottom of the embedded image. It may have any of the usual forms defined
// for a screen distance.
func Pady(value any) option {
	return padyOption{value}
}

type pageanchorOption struct{ v any }

func (o pageanchorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pageanchor %s`, optionString(o.v))
}

// # Canvas(Pageanchor(...))
//
// Specifies which point of the printed area of the canvas should appear over
// the positioning point on the page (which is given by the -pagex
// and -pagey options).
//
// # Canvas(Pageanchor(...))
//
// Specifies which point of the printed area of the canvas should appear over
// the positioning point on the page (which is given by the -pagex
// and -pagey options).
func Pageanchor(value any) option {
	return pageanchorOption{value}
}

type pageheightOption struct{ v any }

func (o pageheightOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pageheight %s`, optionString(o.v))
}

// # Canvas(Pageheight(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size high on the Postscript page.
// Size consists of a floating-point number followed by
// c for centimeters, i for inches, m for millimeters,
// or p or nothing for printer's points (1/72 inch).
// Defaults to the height of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
//
// # Canvas(Pageheight(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size high on the Postscript page.
// Size consists of a floating-point number followed by
// c for centimeters, i for inches, m for millimeters,
// or p or nothing for printer's points (1/72 inch).
// Defaults to the height of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
func Pageheight(value any) option {
	return pageheightOption{value}
}

type pagewidthOption struct{ v any }

func (o pagewidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pagewidth %s`, optionString(o.v))
}

// # Canvas(Pagewidth(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size wide on the Postscript page.
// Size has the same form as for -pageheight.
// Defaults to the width of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
//
// # Canvas(Pagewidth(...))
//
// Specifies that the Postscript should be scaled in both x and y so
// that the printed area is size wide on the Postscript page.
// Size has the same form as for -pageheight.
// Defaults to the width of the printed area on the screen.
// If both -pageheight and -pagewidth are specified then
// the scale factor from -pagewidth is used (non-uniform scaling
// is not implemented).
func Pagewidth(value any) option {
	return pagewidthOption{value}
}

type pagexOption struct{ v any }

func (o pagexOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pagex %s`, optionString(o.v))
}

// # Canvas(Pagex(...))
//
// Position gives the x-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagey and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
//
// # Canvas(Pagex(...))
//
// Position gives the x-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagey and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
func Pagex(value any) option {
	return pagexOption{value}
}

type pageyOption struct{ v any }

func (o pageyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pagey %s`, optionString(o.v))
}

// # Canvas(Pagey(...))
//
// Position gives the y-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagex and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
//
// # Canvas(Pagey(...))
//
// Position gives the y-coordinate of the positioning point on
// the Postscript page, using any of the forms allowed for -pageheight.
// Used in conjunction with the -pagex and -pageanchor options
// to determine where the printed area appears on the Postscript page.
// Defaults to the center of the page.
func Pagey(value any) option {
	return pageyOption{value}
}

type paletteOption struct{ v any }

func (o paletteOption) optionString(w *Window) string {
	return fmt.Sprintf(`-palette %s`, optionString(o.v))
}

// # Photo(Palette(...))
//
// Specifies the resolution of the color cube to be allocated for
// displaying this image, and thus the number of colors used from the
// colormaps of the windows where it is displayed.  The
// palette-spec string may be either a single decimal number,
// specifying the number of shades of gray to use, or three decimal
// numbers separated by slashes (/), specifying the number of shades of
// red, green and blue to use, respectively.  If the first form (a single
// number) is used, the image will be displayed in monochrome (i.e.,
// grayscale).
func Palette(value any) option {
	return paletteOption{value}
}

type parentOption struct{ v any }

func (o parentOption) optionString(w *Window) string {
	return fmt.Sprintf(`-parent %s`, optionString(o.v))
}

// # ChooseColor(Parent(...))
//
// Makes window the logical parent of the color dialog. The color
// dialog is displayed on top of its parent window.
//
// # ChooseDirectory(Parent(...))
//
// Makes window the logical parent of the dialog. The dialog
// is displayed on top of its parent window. On Mac OS X, this
// turns the file dialog into a sheet attached to the parent window.
//
// # Fontchooser(Parent(...))
//
// Specifies/returns the logical parent window of the font selection dialog
// (similar to the -parent option to other dialogs). The font selection
// dialog is hidden if it is visible when the parent window is destroyed.
//
// # GetOpenFile(Parent(...))
//
// Makes window the logical parent of the file dialog. The file
// dialog is displayed on top of its parent window. On Mac OS X, this
// turns the file dialog into a sheet attached to the parent window.
//
// # MessageBox(Parent(...))
//
// Makes window the logical parent of the message box. The message
// box is displayed on top of its parent window.
func Parent(value any) option {
	return parentOption{value}
}

type phaseOption struct{ v any }

func (o phaseOption) optionString(w *Window) string {
	return fmt.Sprintf(`-phase %s`, optionString(o.v))
}

// # TProgressbar(Phase(...))
//
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
//
// # TProgressbar(Phase(...))
//
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
func Phase(value any) option {
	return phaseOption{value}
}

type placeOption struct{ v any }

func (o placeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-place %s`, optionString(o.v))
}

// # Event(Place(...))
//
// Where specifies the place field for the event;  it must be
// either PlaceOnTop or PlaceOnBottom.
// Valid for Circulate events.
// Corresponds to the %p substitution for binding scripts.
func Place(value any) option {
	return placeOption{value}
}

type placeholderOption struct{ v any }

func (o placeholderOption) optionString(w *Window) string {
	return fmt.Sprintf(`-placeholder %s`, optionString(o.v))
}

// Specifies a help text string to display if no text is otherwise displayed,
// that is when the widget is empty. The placeholder text is displayed using
// the values of the '-font' and '-justify' options.
func Placeholder(value any) option {
	return placeholderOption{value}
}

type placeholderforegroundOption struct{ v any }

func (o placeholderforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-placeholderforeground %s`, optionString(o.v))
}

// Specifies the foreground color to use when the placeholder text is
// displayed. The default color is platform-specific.
func Placeholderforeground(value any) option {
	return placeholderforegroundOption{value}
}

// See also [Event handlers]
//
// # Menu(Postcommand(...))
//
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
//
// # Menu(Postcommand(...))
//
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
//
// # TCombobox(Postcommand(...))
//
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
//
// # TCombobox(Postcommand(...))
//
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Postcommand(args ...any) option {
	return newEventHandler("-postcommand", args...)
}

type pressedOption struct{ v any }

func (o pressedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pressed %s`, optionString(o.v))
}

// # Nsimage(Pressed(...))
func Pressed(value any) option {
	return pressedOption{value}
}

type proxybackgroundOption struct{ v any }

func (o proxybackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-proxybackground %s`, optionString(o.v))
}

// # Panedwindow(Proxybackground(...))
//
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
//
// # Panedwindow(Proxybackground(...))
//
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
func Proxybackground(value any) option {
	return proxybackgroundOption{value}
}

type proxyborderwidthOption struct{ v any }

func (o proxyborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-proxyborderwidth %s`, optionString(o.v))
}

// # Panedwindow(Proxyborderwidth(...))
//
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
//
// # Panedwindow(Proxyborderwidth(...))
//
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
func Proxyborderwidth(value any) option {
	return proxyborderwidthOption{value}
}

type proxyreliefOption struct{ v any }

func (o proxyreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-proxyrelief %s`, optionString(o.v))
}

// # Panedwindow(Proxyrelief(...))
//
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
//
// # Panedwindow(Proxyrelief(...))
//
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
func Proxyrelief(value any) option {
	return proxyreliefOption{value}
}

type radiusOption struct{ v any }

func (o radiusOption) optionString(w *Window) string {
	return fmt.Sprintf(`-radius %s`, optionString(o.v))
}

// # Nsimage(Radius(...))
func Radius(value any) option {
	return radiusOption{value}
}

type readonlybackgroundOption struct{ v any }

func (o readonlybackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-readonlybackground %s`, optionString(o.v))
}

// # Entry(Readonlybackground(...))
//
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Entry(Readonlybackground(...))
//
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Readonlybackground(...))
//
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Readonlybackground(...))
//
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
func Readonlybackground(value any) option {
	return readonlybackgroundOption{value}
}

type regexpOption struct{ v any }

func (o regexpOption) optionString(w *Window) string {
	return fmt.Sprintf(`-regexp %s`, optionString(o.v))
}

// # Text(Regexp(...))
//
// Treat pattern as a regular expression and match it against the text
// using the rules for regular expressions (see the regexp command
// and the re_syntax page for
// details). The default matching automatically passes both the
// -lineanchor and -linestop options to the regexp engine (unless
// -nolinestop is used), so that ^$ match beginning and end of line,
// and ., [^ sequences will never match the newline character
// \en.
//
// # Text(Regexp(...))
//
// Treat pattern as a regular expression and match it against the text
// using the rules for regular expressions (see the regexp command
// and the re_syntax page for
// details). The default matching automatically passes both the
// -lineanchor and -linestop options to the regexp engine (unless
// -nolinestop is used), so that ^$ match beginning and end of line,
// and ., [^ sequences will never match the newline character
// \en.
func Regexp(value any) option {
	return regexpOption{value}
}

type relheightOption struct{ v any }

func (o relheightOption) optionString(w *Window) string {
	return fmt.Sprintf(`-relheight %s`, optionString(o.v))
}

// # Place(Relheight(...))
//
// Size specifies the height for window.
// In this case the height is specified as a floating-point number
// relative to the height of the container: 0.5 means window will
// be half as high as the container, 1.0 means window will have
// the same height as the container, and so on.
// If both -height and -relheight are specified for a content,
// their values are summed.  For example, -relheight 1.0 -height -2
// makes the content 2 pixels shorter than the container.
func Relheight(value any) option {
	return relheightOption{value}
}

type reliefOption struct{ v any }

func (o reliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-relief %s`, optionString(o.v))
}

// Specifies the 3-D effect desired for the widget.  Acceptable
// values are 'raised', 'sunken', 'flat', 'ridge',
// 'solid', and 'groove'.
// The value
// indicates how the interior of the widget should appear relative
// to its exterior;  for example, 'raised' means the interior of
// the widget should appear to protrude from the screen, relative to
// the exterior of the widget.
//
// # Text(Relief(...))
//
// Relief specifies the relief style to use for drawing the border, in any
// of the forms accepted by Tk_GetRelief. This option is used in
// conjunction with the -borderwidth option to enable to the desired
// border appearance.
//
// # Text(Relief(...))
//
// Relief specifies the relief style to use for drawing the border, in any
// of the forms accepted by Tk_GetRelief. This option is used in
// conjunction with the -borderwidth option to enable to the desired
// border appearance.
//
// # TFrame(Relief(...))
//
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
//
// # TFrame(Relief(...))
//
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
//
// # TLabel(Relief(...))
//
// \" Rewrite this:
//
// # TLabel(Relief(...))
//
// \" Rewrite this:
func Relief(value any) option {
	return reliefOption{value}
}

type relwidthOption struct{ v any }

func (o relwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-relwidth %s`, optionString(o.v))
}

// # Place(Relwidth(...))
//
// Size specifies the width for window.
// In this case the width is specified as a floating-point number
// relative to the width of the container: 0.5 means window will
// be half as wide as the container, 1.0 means window will have
// the same width as the container, and so on.
// If both -width and -relwidth are specified for a content,
// their values are summed.  For example, -relwidth 1.0 -width 5
// makes the content 5 pixels wider than the container.
func Relwidth(value any) option {
	return relwidthOption{value}
}

type relxOption struct{ v any }

func (o relxOption) optionString(w *Window) string {
	return fmt.Sprintf(`-relx %s`, optionString(o.v))
}

// # Place(Relx(...))
//
// Location specifies the x-coordinate within the container window
// of the anchor point for window.
// In this case the location is specified in a relative fashion
// as a floating-point number:  0.0 corresponds to the left edge
// of the container and 1.0 corresponds to the right edge of the container.
// Location need not be in the range 0.0-1.0.
// If both -x and -relx are specified for a content
// then their values are summed.  For example, -relx 0.5 -x -2
// positions the left edge of the content 2 pixels to the left of the
// center of its container.
func Relx(value any) option {
	return relxOption{value}
}

type relyOption struct{ v any }

func (o relyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rely %s`, optionString(o.v))
}

// # Place(Rely(...))
//
// Location specifies the y-coordinate within the container window
// of the anchor point for window.
// In this case the value is specified in a relative fashion
// as a floating-point number:  0.0 corresponds to the top edge
// of the container and 1.0 corresponds to the bottom edge of the container.
// Location need not be in the range 0.0-1.0.
// If both -y and -rely are specified for a content
// then their values are summed.  For example, -rely 0.5 -x 3
// positions the top edge of the content 3 pixels below the
// center of its container.
func Rely(value any) option {
	return relyOption{value}
}

type repeatdelayOption struct{ v any }

func (o repeatdelayOption) optionString(w *Window) string {
	return fmt.Sprintf(`-repeatdelay %s`, optionString(o.v))
}

// Specifies the number of milliseconds a button or key must be held
// down before it begins to auto-repeat.  Used, for example, on the
// up- and down-arrows in scrollbars.
func Repeatdelay(value any) option {
	return repeatdelayOption{value}
}

type repeatintervalOption struct{ v any }

func (o repeatintervalOption) optionString(w *Window) string {
	return fmt.Sprintf(`-repeatinterval %s`, optionString(o.v))
}

// Used in conjunction with '-repeatdelay':  once auto-repeat
// begins, this option determines the number of milliseconds between
// auto-repeats.
func Repeatinterval(value any) option {
	return repeatintervalOption{value}
}

type resolutionOption struct{ v any }

func (o resolutionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-resolution %s`, optionString(o.v))
}

// # Scale(Resolution(...))
//
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
//
// # Scale(Resolution(...))
//
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
func Resolution(value any) option {
	return resolutionOption{value}
}

type ringOption struct{ v any }

func (o ringOption) optionString(w *Window) string {
	return fmt.Sprintf(`-ring %s`, optionString(o.v))
}

// # Nsimage(Ring(...))
func Ring(value any) option {
	return ringOption{value}
}

type rmarginOption struct{ v any }

func (o rmarginOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rmargin %s`, optionString(o.v))
}

// # Text(Rmargin(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then pixels specifies how wide a margin to
// leave between the end of the line and the right edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled. If a text line wraps, the right
// margin for each line on the display is determined by the first non-elided
// character of that display line.
//
// # Text(Rmargin(...))
//
// If the first non-elided character of a display line has a tag for which this
// option has been specified, then pixels specifies how wide a margin to
// leave between the end of the line and the right edge of the window.
// Pixels may have any of the standard forms for screen distances. This
// option is only used when wrapping is enabled. If a text line wraps, the right
// margin for each line on the display is determined by the first non-elided
// character of that display line.
func Rmargin(value any) option {
	return rmarginOption{value}
}

type rmargincolorOption struct{ v any }

func (o rmargincolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rmargincolor %s`, optionString(o.v))
}

// # Text(Rmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -rmargin. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// used is specified by the -background tag option (or, if this is also
// unspecified, by the -background widget option).
//
// # Text(Rmargincolor(...))
//
// Color specifies the background color to use in regions that do not
// contain characters because they are indented by -rmargin. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// used is specified by the -background tag option (or, if this is also
// unspecified, by the -background widget option).
func Rmargincolor(value any) option {
	return rmargincolorOption{value}
}

type rootOption struct{ v any }

func (o rootOption) optionString(w *Window) string {
	return fmt.Sprintf(`-root %s`, optionString(o.v))
}

// # Event(Root(...))
//
// Window must be either a window path name or an integer window
// identifier;  it specifies the root field for the event.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Enter, Leave, and Motion
// events.
// Corresponds to the %R substitution for binding scripts.
func Root(value any) option {
	return rootOption{value}
}

type rootxOption struct{ v any }

func (o rootxOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rootx %s`, optionString(o.v))
}

// # Event(Rootx(...))
//
// Coord must be a screen distance;  it specifies the x_root
// field for the event.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Enter, Leave, and Motion
// events.  Corresponds to the %X substitution for binding scripts.
func Rootx(value any) option {
	return rootxOption{value}
}

type rootyOption struct{ v any }

func (o rootyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rooty %s`, optionString(o.v))
}

// # Event(Rooty(...))
//
// Coord must be a screen distance;  it specifies the y_root
// field for the event.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Enter, Leave, and Motion
// events.
// Corresponds to the %Y substitution for binding scripts.
func Rooty(value any) option {
	return rootyOption{value}
}

type rotateOption struct{ v any }

func (o rotateOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rotate %s`, optionString(o.v))
}

// # Canvas(Rotate(...))
//
// Boolean specifies whether the printed area is to be rotated 90
// degrees.
// In non-rotated output the x-axis of the printed area runs along
// the short dimension of the page
//
// # Canvas(Rotate(...))
//
// Boolean specifies whether the printed area is to be rotated 90
// degrees.
// In non-rotated output the x-axis of the printed area runs along
// the short dimension of the page
func Rotate(value any) option {
	return rotateOption{value}
}

type rowOption struct{ v any }

func (o rowOption) optionString(w *Window) string {
	return fmt.Sprintf(`-row %s`, optionString(o.v))
}

// # Grid(Row(...))
//
// Insert the content so that it occupies the nth row in the grid.
// Row numbers start with 0.  If this option is not supplied, then the
// content is arranged on the same row as the previous content specified on this
// call to grid, or the next row after the highest occupied row
// if this is the first content.
func Row(value any) option {
	return rowOption{value}
}

type rowspanOption struct{ v any }

func (o rowspanOption) optionString(w *Window) string {
	return fmt.Sprintf(`-rowspan %s`, optionString(o.v))
}

// # Grid(Rowspan(...))
//
// Insert the content so that it occupies n rows in the grid.
// The default is one row.  If the next grid command contains
// ^ characters instead of content that line up with the columns
// of this content, then the rowspan of this content is
// extended by one.
func Rowspan(value any) option {
	return rowspanOption{value}
}

type sashcursorOption struct{ v any }

func (o sashcursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashcursor %s`, optionString(o.v))
}

// # Panedwindow(Sashcursor(...))
//
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
//
// # Panedwindow(Sashcursor(...))
//
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
func Sashcursor(value any) option {
	return sashcursorOption{value}
}

type sashpadOption struct{ v any }

func (o sashpadOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashpad %s`, optionString(o.v))
}

// # Panedwindow(Sashpad(...))
//
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
//
// # Panedwindow(Sashpad(...))
//
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
func Sashpad(value any) option {
	return sashpadOption{value}
}

type sashreliefOption struct{ v any }

func (o sashreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashrelief %s`, optionString(o.v))
}

// # Panedwindow(Sashrelief(...))
//
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
//
// # Panedwindow(Sashrelief(...))
//
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
func Sashrelief(value any) option {
	return sashreliefOption{value}
}

type sashwidthOption struct{ v any }

func (o sashwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashwidth %s`, optionString(o.v))
}

// # Panedwindow(Sashwidth(...))
//
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
//
// # Panedwindow(Sashwidth(...))
//
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
func Sashwidth(value any) option {
	return sashwidthOption{value}
}

type screenOption struct{ v any }

func (o screenOption) optionString(w *Window) string {
	return fmt.Sprintf(`-screen %s`, optionString(o.v))
}

// # Toplevel(Screen(...))
//
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Screen(...))
//
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
func Screen(value any) option {
	return screenOption{value}
}

type scrollregionOption struct{ v any }

func (o scrollregionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-scrollregion %s`, optionString(o.v))
}

// # Canvas(Scrollregion(...))
//
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
//
// # Canvas(Scrollregion(...))
//
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
func Scrollregion(value any) option {
	return scrollregionOption{value}
}

type selectbackgroundOption struct{ v any }

func (o selectbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectbackground %s`, optionString(o.v))
}

// Specifies the background color to use when displaying selected
// items.
//
// # Listbox(Selectbackground(...))
//
// color specifies the background color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Listbox(Selectbackground(...))
//
// color specifies the background color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Text(Selectbackground(...))
//
// Color specifies the background color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -background tag option is
// used.
//
// # Text(Selectbackground(...))
//
// Color specifies the background color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -background tag option is
// used.
func Selectbackground(value any) option {
	return selectbackgroundOption{value}
}

type selectborderwidthOption struct{ v any }

func (o selectborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectborderwidth %s`, optionString(o.v))
}

// Specifies a non-negative value indicating the width
// of the 3-D border to draw around selected items.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
func Selectborderwidth(value any) option {
	return selectborderwidthOption{value}
}

type selectcolorOption struct{ v any }

func (o selectcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectcolor %s`, optionString(o.v))
}

// # Checkbutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Checkbutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Menu(Selectcolor(...))
//
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
//
// # Menu(Selectcolor(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies the color to display in the indicator when the entry is
// selected.
// If the value is an empty string (the default) then the -selectcolor
// option for the menu determines the indicator color.
//
// # Menu(Selectcolor(...))
//
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
//
// # Menu(Selectcolor(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies the color to display in the indicator when the entry is
// selected.
// If the value is an empty string (the default) then the -selectcolor
// option for the menu determines the indicator color.
//
// # Radiobutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Radiobutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
func Selectcolor(value any) option {
	return selectcolorOption{value}
}

type selectforegroundOption struct{ v any }

func (o selectforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectforeground %s`, optionString(o.v))
}

// Specifies the foreground color to use when displaying selected
// items.
//
// # Listbox(Selectforeground(...))
//
// color specifies the foreground color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Listbox(Selectforeground(...))
//
// color specifies the foreground color to use when displaying the
// item while it is selected. It may have any of the forms accepted by
// Tk_GetColor.
//
// # Text(Selectforeground(...))
//
// Color specifies the foreground color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -foreground tag option is
// used.
//
// # Text(Selectforeground(...))
//
// Color specifies the foreground color to use when displaying selected
// items. It may have any of the forms accepted by Tk_GetColor. If
// color has not been specified, or if it is specified as an empty
// string, then the color specified by the -foreground tag option is
// used.
func Selectforeground(value any) option {
	return selectforegroundOption{value}
}

type selectimageOption struct{ v any }

func (o selectimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectimage %s`, optionString(o.v))
}

// # Checkbutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Checkbutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Menu(Selectimage(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies an image to display in the entry (in place of
// the -image option) when it is selected.
// Value is the name of an image, which must have been created
// by some previous invocation of image create.
// This option is ignored unless the -image option has
// been specified.
//
// # Menu(Selectimage(...))
//
// Available only for checkbutton and radiobutton entries.
// Specifies an image to display in the entry (in place of
// the -image option) when it is selected.
// Value is the name of an image, which must have been created
// by some previous invocation of image create.
// This option is ignored unless the -image option has
// been specified.
//
// # Radiobutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
func Selectimage(value any) option {
	return selectimageOption{value}
}

type selectmodeOption struct{ v any }

func (o selectmodeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectmode %s`, optionString(o.v))
}

// # Listbox(Selectmode(...))
//
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
//
// # Listbox(Selectmode(...))
//
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
//
// # TTreeview(Selectmode(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
//
// # TTreeview(Selectmode(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
func Selectmode(value any) option {
	return selectmodeOption{value}
}

type selecttypeOption struct{ v any }

func (o selecttypeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selecttype %s`, optionString(o.v))
}

// # TTreeview(Selecttype(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
//
// # TTreeview(Selecttype(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
func Selecttype(value any) option {
	return selecttypeOption{value}
}

type sendeventOption struct{ v any }

func (o sendeventOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sendevent %s`, optionString(o.v))
}

// # Event(Sendevent(...))
//
// Boolean must be a boolean value;  it specifies the send_event
// field for the event.  Valid for all events.  Corresponds to the
// %E substitution for binding scripts.
func Sendevent(value any) option {
	return sendeventOption{value}
}

type separatorOption struct{ v any }

func (o separatorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-separator %s`, optionString(o.v))
}

// # TTreeview(Separator(...))
//
// Specifies whether or not a column separator should be drawn to the right
// of the column.  Default is false.
//
// # TTreeview(Separator(...))
//
// Specifies whether or not a column separator should be drawn to the right
// of the column.  Default is false.
func Separator(value any) option {
	return separatorOption{value}
}

type serialOption struct{ v any }

func (o serialOption) optionString(w *Window) string {
	return fmt.Sprintf(`-serial %s`, optionString(o.v))
}

// # Event(Serial(...))
//
// Number must be an integer;  it specifies the serial field
// for the event.  Valid for all events.
// Corresponds to the %# substitution for binding scripts.
func Serial(value any) option {
	return serialOption{value}
}

type setgridOption struct{ v any }

func (o setgridOption) optionString(w *Window) string {
	return fmt.Sprintf(`-setgrid %s`, optionString(o.v))
}

// Specifies a boolean value that determines whether this widget controls the
// resizing grid for its top-level window.
// This option is typically used in text widgets, where the information
// in the widget has a natural size (the size of a character) and it makes
// sense for the window's dimensions to be integral numbers of these units.
// These natural window sizes form a grid.
// If the '-setgrid' option is set to true then the widget will
// communicate with the window manager so that when the user interactively
// resizes the top-level window that contains the widget, the dimensions of
// the window will be displayed to the user in grid units and the window
// size will be constrained to integral numbers of grid units.
// See the section 'GRIDDED GEOMETRY MANAGEMENT' in the 'wm' manual
// entry for more details.
func Setgrid(value any) option {
	return setgridOption{value}
}

type showOption struct{ v any }

func (o showOption) optionString(w *Window) string {
	return fmt.Sprintf(`-show %s`, optionString(o.v))
}

// # Entry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # Entry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TEntry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TEntry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TTreeview(Show(...))
//
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
//
// # TTreeview(Show(...))
//
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
func Show(value any) option {
	return showOption{value}
}

type showhandleOption struct{ v any }

func (o showhandleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-showhandle %s`, optionString(o.v))
}

// # Panedwindow(Showhandle(...))
//
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
//
// # Panedwindow(Showhandle(...))
//
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
func Showhandle(value any) option {
	return showhandleOption{value}
}

type showvalueOption struct{ v any }

func (o showvalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-showvalue %s`, optionString(o.v))
}

// # Scale(Showvalue(...))
//
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
//
// # Scale(Showvalue(...))
//
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
func Showvalue(value any) option {
	return showvalueOption{value}
}

type shrinkOption struct{ v any }

func (o shrinkOption) optionString(w *Window) string {
	return fmt.Sprintf(`-shrink %s`, optionString(o.v))
}

// # Photo(Shrink(...))
//
// Specifies that the size of the destination image should be reduced, if
// necessary, so that the region being copied into is at the bottom-right
// corner of the image.  This option will not affect the width or height
// of the image if the user has specified a non-zero value for the
// -width or -height configuration option, respectively.
//
// # Photo(Shrink(...))
//
// If this option, the size of imageName will be reduced, if
// necessary, so that the region into which the image file data are read
// is at the bottom-right corner of the imageName.  This option
// will not affect the width or height of the image if the user has
// specified a non-zero value for the -width or -height
// configuration option, respectively.
func Shrink(value any) option {
	return shrinkOption{value}
}

type sideOption struct{ v any }

func (o sideOption) optionString(w *Window) string {
	return fmt.Sprintf(`-side %s`, optionString(o.v))
}

// # Pack(Side(...))
//
// Specifies which side of the container the content will be packed against.
// Must be left, right, top, or bottom.
// Defaults to top.
//
// # TStyle(Side(...))
//
// Specifies which side of the cavity to place the element;
// one of left, right, top, or bottom.
// For instance, -side top allocates the parcel along the top of
// the cavity having width and height respectively the width of the cavity
// and the height of the element.
// If omitted, the allocated parcel is the entire cavity (same effect
// as -expand 1).
func Side(value any) option {
	return sideOption{value}
}

type sizeOption struct{ v any }

func (o sizeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-size %s`, optionString(o.v))
}

// # Font(Size(...))
//
// The desired size of the font.  If the size argument is a positive
// number, it is interpreted as a size in points.  If size is a negative
// number, its absolute value is interpreted as a size in pixels.  If a
// font cannot be displayed at the specified size, a nearby size will be
// chosen.  If size is unspecified or zero, a platform-dependent default
// size will be chosen.
func Size(value any) option {
	return sizeOption{value}
}

type slantOption struct{ v any }

func (o slantOption) optionString(w *Window) string {
	return fmt.Sprintf(`-slant %s`, optionString(o.v))
}

// # Font(Slant(...))
//
// The amount the characters in the font are slanted away from the
// vertical.  Valid values for slant are roman and italic.
// A roman font is the normal, upright appearance of a font, while
// an italic font is one that is tilted some number of degrees from upright.
// The closest available slant to the one specified will be chosen.
// The default slant is roman.
func Slant(value any) option {
	return slantOption{value}
}

type sliderlengthOption struct{ v any }

func (o sliderlengthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sliderlength %s`, optionString(o.v))
}

// # Scale(Sliderlength(...))
//
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
//
// # Scale(Sliderlength(...))
//
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
func Sliderlength(value any) option {
	return sliderlengthOption{value}
}

type sliderreliefOption struct{ v any }

func (o sliderreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sliderrelief %s`, optionString(o.v))
}

// # Scale(Sliderrelief(...))
//
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
//
// # Scale(Sliderrelief(...))
//
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
func Sliderrelief(value any) option {
	return sliderreliefOption{value}
}

type smoothOption struct{ v any }

func (o smoothOption) optionString(w *Window) string {
	return fmt.Sprintf(`-smooth %s`, optionString(o.v))
}

// # Canvas(Smooth(...))
//
// smoothMethod must have one of the forms accepted by
// Tcl_GetBoolean or a line smoothing method.
// Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the line
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the line
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is a
// control point and not a knot point, the point is repeated (one or two
// times) so that it also becomes a knot point.
//
// # Canvas(Smooth(...))
//
// Boolean must have one of the forms accepted by Tcl_GetBoolean
// or a line smoothing method. Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the polygon
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the polygon
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is not the
// second point of a pair of control points, the point is repeated (one or two
// times) so that it also becomes the second point of a pair of control
// points (the associated knot point will be the first control point).
//
// # Canvas(Smooth(...))
//
// smoothMethod must have one of the forms accepted by
// Tcl_GetBoolean or a line smoothing method.
// Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the line
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the line
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is a
// control point and not a knot point, the point is repeated (one or two
// times) so that it also becomes a knot point.
//
// # Canvas(Smooth(...))
//
// Boolean must have one of the forms accepted by Tcl_GetBoolean
// or a line smoothing method. Only true and raw are
// supported in the core (with bezier being an alias for true),
// but more can be added at runtime. If a boolean
// false value or empty string is given, no smoothing is applied. A boolean
// truth value assumes true smoothing.
// If the smoothing method is true, this indicates that the polygon
// should be drawn as a curve, rendered as a set of quadratic splines: one spline
// is drawn for the first and second line segments, one for the second
// and third, and so on. Straight-line segments can be generated within
// a curve by duplicating the end-points of the desired line segment.
// If the smoothing method is raw, this indicates that the polygon
// should also be drawn as a curve but where the list of coordinates is
// such that the first coordinate pair (and every third coordinate pair
// thereafter) is a knot point on a cubic Bezier curve, and the other
// coordinates are control points on the cubic Bezier curve. Straight
// line segments can be generated within a curve by making control points
// equal to their neighbouring knot points. If the last point is not the
// second point of a pair of control points, the point is repeated (one or two
// times) so that it also becomes the second point of a pair of control
// points (the associated knot point will be the first control point).
func Smooth(value any) option {
	return smoothOption{value}
}

type sourceOption struct{ v any }

func (o sourceOption) optionString(w *Window) string {
	return fmt.Sprintf(`-source %s`, optionString(o.v))
}

// # Nsimage(Source(...))
func Source(value any) option {
	return sourceOption{value}
}

type spacing1Option struct{ v any }

func (o spacing1Option) optionString(w *Window) string {
	return fmt.Sprintf(`-spacing1 %s`, optionString(o.v))
}

// # Text(Spacing1(...))
//
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
//
// # Text(Spacing1(...))
//
// Pixels specifies how much additional space should be left above each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the first line on the display.
//
// # Text(Spacing1(...))
//
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
//
// # Text(Spacing1(...))
//
// Pixels specifies how much additional space should be left above each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the first line on the display.
func Spacing1(value any) option {
	return spacing1Option{value}
}

type spacing2Option struct{ v any }

func (o spacing2Option) optionString(w *Window) string {
	return fmt.Sprintf(`-spacing2 %s`, optionString(o.v))
}

// # Text(Spacing2(...))
//
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
//
// # Text(Spacing2(...))
//
// For lines that wrap, this option specifies how much additional space to leave
// between the display lines for a single text line. Pixels may have any of
// the standard forms for screen distances.
//
// # Text(Spacing2(...))
//
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
//
// # Text(Spacing2(...))
//
// For lines that wrap, this option specifies how much additional space to leave
// between the display lines for a single text line. Pixels may have any of
// the standard forms for screen distances.
func Spacing2(value any) option {
	return spacing2Option{value}
}

type spacing3Option struct{ v any }

func (o spacing3Option) optionString(w *Window) string {
	return fmt.Sprintf(`-spacing3 %s`, optionString(o.v))
}

// # Text(Spacing3(...))
//
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
//
// # Text(Spacing3(...))
//
// Pixels specifies how much additional space should be left below each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the last line on the display.
//
// # Text(Spacing3(...))
//
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
//
// # Text(Spacing3(...))
//
// Pixels specifies how much additional space should be left below each
// text line, using any of the standard forms for screen distances. If a line
// wraps, this option only applies to the last line on the display.
func Spacing3(value any) option {
	return spacing3Option{value}
}

type splinestepsOption struct{ v any }

func (o splinestepsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-splinesteps %s`, optionString(o.v))
}

// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
//
// # Canvas(Splinesteps(...))
//
// Specifies the degree of smoothness desired for curves: each spline
// will be approximated with number line segments. This
// option is ignored unless the -smooth option is true or raw.
func Splinesteps(value any) option {
	return splinestepsOption{value}
}

type startOption struct{ v any }

func (o startOption) optionString(w *Window) string {
	return fmt.Sprintf(`-start %s`, optionString(o.v))
}

// # Canvas(Start(...))
//
// Specifies the beginning of the angular range occupied by the
// arc.
// Degrees is given in units of degrees measured counter-clockwise
// from the 3-o'clock position; it may be either positive or negative.
//
// # Canvas(Start(...))
//
// Specifies the beginning of the angular range occupied by the
// arc.
// Degrees is given in units of degrees measured counter-clockwise
// from the 3-o'clock position; it may be either positive or negative.
func Start(value any) option {
	return startOption{value}
}

type startlineOption struct{ v any }

func (o startlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-startline %s`, optionString(o.v))
}

// # Text(Startline(...))
//
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
//
// # Text(Startline(...))
//
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
func Startline(value any) option {
	return startlineOption{value}
}

type stateOption struct{ v any }

func (o stateOption) optionString(w *Window) string {
	return fmt.Sprintf(`-state %s`, optionString(o.v))
}

// # Button(State(...))
//
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Button(State(...))
//
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Canvas(State(...))
//
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
//
// # Canvas(State(...))
//
// This allows an item to override the canvas widget's global state
// option. It takes the same values:
// normal, disabled or hidden.
//
// # Canvas(State(...))
//
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
//
// # Canvas(State(...))
//
// This allows an item to override the canvas widget's global state
// option. It takes the same values:
// normal, disabled or hidden.
//
// # Checkbutton(State(...))
//
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
//
// # Checkbutton(State(...))
//
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
//
// # Entry(State(...))
//
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Entry(State(...))
//
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Event(State(...))
//
// State specifies the state field for the event.
// For Key, KeyRelease, Buttons,
// ButtonRelease, Enter, Leave, and Motion events
// it must be an integer value.
// For Visibility events it must be one of VisibilityUnobscured,
// VisibilityPartiallyObscured, or VisibilityFullyObscured.
// This option overrides any modifiers such as Meta or Control
// specified in the base event.
// Corresponds to the %s substitution for binding scripts.
//
// # Label(State(...))
//
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
//
// # Label(State(...))
//
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
//
// # Listbox(State(...))
//
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
//
// # Listbox(State(...))
//
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
//
// # Menu(State(...))
//
// Specifies one of three states for the entry:  normal, active,
// or disabled.  In normal state the entry is displayed using the
// -foreground option for the menu and the -background
// option from the entry or the menu.
// The active state is typically used when the pointer is over the entry.
// In active state the entry is displayed using the -activeforeground
// option for the menu along with the -activebackground option from
// the entry.  Disabled state means that the entry
// should be insensitive:  the default bindings will refuse to activate
// or invoke the entry.
// In this state the entry is displayed according to the
// -disabledforeground option for the menu and the
// -background option from the entry.
// This option is not available for separator entries.
//
// # Menu(State(...))
//
// Specifies one of three states for the entry:  normal, active,
// or disabled.  In normal state the entry is displayed using the
// -foreground option for the menu and the -background
// option from the entry or the menu.
// The active state is typically used when the pointer is over the entry.
// In active state the entry is displayed using the -activeforeground
// option for the menu along with the -activebackground option from
// the entry.  Disabled state means that the entry
// should be insensitive:  the default bindings will refuse to activate
// or invoke the entry.
// In this state the entry is displayed according to the
// -disabledforeground option for the menu and the
// -background option from the entry.
// This option is not available for separator entries.
//
// # Menubutton(State(...))
//
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Menubutton(State(...))
//
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Radiobutton(State(...))
//
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
//
// # Radiobutton(State(...))
//
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
//
// # Scale(State(...))
//
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
//
// # Scale(State(...))
//
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
//
// # Spinbox(State(...))
//
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Spinbox(State(...))
//
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Text(State(...))
//
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
//
// # Text(State(...))
//
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
//
// # TCombobox(State(...))
//
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
//
// # TCombobox(State(...))
//
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
//
// # TEntry(State(...))
//
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
//
// # TEntry(State(...))
//
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
//
// # TNotebook(State(...))
//
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
//
// # TNotebook(State(...))
//
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
func State(value any) option {
	return stateOption{value}
}

type stickyOption struct{ v any }

func (o stickyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sticky %s`, optionString(o.v))
}

// # Grid(Sticky(...))
//
// If a content's cell is larger than its requested dimensions, this
// option may be used to position (or stretch) the content within its cell.
// Style  is a string that contains zero or more of the characters
// n, s, e or w.
// The string can optionally contain spaces or
// commas, but they are ignored.  Each letter refers to a side (north, south,
// east, or west) that the content will
//
// # Panedwindow(Sticky(...))
//
// If a window's pane is larger than the requested dimensions of the
// window, this option may be used to position (or stretch) the window
// within its pane.  Style  is a string that contains zero or more
// of the characters n, s, e or w.  The string
// can optionally contains spaces or commas, but they are ignored.  Each
// letter refers to a side (north, south, east, or west) that the window
// will
//
// # Panedwindow(Sticky(...))
//
// If a window's pane is larger than the requested dimensions of the
// window, this option may be used to position (or stretch) the window
// within its pane.  Style  is a string that contains zero or more
// of the characters n, s, e or w.  The string
// can optionally contains spaces or commas, but they are ignored.  Each
// letter refers to a side (north, south, east, or west) that the window
// will
//
// # TImage(Sticky(...))
//
// Specifies how the image is placed within the final parcel.
// spec contains zero or more characters
//
// # TNotebook(Sticky(...))
//
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
//
// # TNotebook(Sticky(...))
//
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
//
// # TStyle(Sticky(...))
//
// Specifies the actual parcel position and size inside the allocated parcel.
// If specified as an empty string then the actual parcel is centered in
// the allocated parcel. Default is nswe.
func Sticky(value any) option {
	return stickyOption{value}
}

type stippleOption struct{ v any }

func (o stippleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-stipple %s`, optionString(o.v))
}

// # Canvas(Stipple(...))
//
// # Canvas(Stipple(...))
func Stipple(value any) option {
	return stippleOption{value}
}

type stretchOption struct{ v any }

func (o stretchOption) optionString(w *Window) string {
	return fmt.Sprintf(`-stretch %s`, optionString(o.v))
}

// # Panedwindow(Stretch(...))
//
// Controls how extra space is allocated to each of the panes.
// When is one of always, first, last,
// middle, and never.
// The panedwindow will calculate the required size of all its panes. Any
// remaining (or deficit) space will be distributed to those panes marked
// for stretching. The space will be distributed based on each panes
// current ratio of the whole.  The when values have the following
// definition:
//
// # Panedwindow(Stretch(...))
//
// Controls how extra space is allocated to each of the panes.
// When is one of always, first, last,
// middle, and never.
// The panedwindow will calculate the required size of all its panes. Any
// remaining (or deficit) space will be distributed to those panes marked
// for stretching. The space will be distributed based on each panes
// current ratio of the whole.  The when values have the following
// definition:
//
// # Text(Stretch(...))
//
// If the requested height of the embedded window is less than the height of the
// line in which it is displayed, this option can be used to specify whether the
// window should be stretched vertically to fill its line. If the -pady
// option has been specified as well, then the requested padding will be retained
// even if the window is stretched.
//
// # Text(Stretch(...))
//
// If the requested height of the embedded window is less than the height of the
// line in which it is displayed, this option can be used to specify whether the
// window should be stretched vertically to fill its line. If the -pady
// option has been specified as well, then the requested padding will be retained
// even if the window is stretched.
//
// # TTreeview(Stretch(...))
//
// Specifies whether or not the column width should be adjusted
// when the widget is resized or the user drags a heading column separator.
// Boolean may have any of the forms accepted by Tcl_GetBoolean.
// By default columns are stretchable.
//
// # TTreeview(Stretch(...))
//
// Specifies whether or not the column width should be adjusted
// when the widget is resized or the user drags a heading column separator.
// Boolean may have any of the forms accepted by Tcl_GetBoolean.
// By default columns are stretchable.
func Stretch(value any) option {
	return stretchOption{value}
}

type strictlimitsOption struct{ v any }

func (o strictlimitsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-strictlimits %s`, optionString(o.v))
}

// # Text(Strictlimits(...))
//
// When performing any search, the normal behaviour is that the start and stop
// limits are checked with respect to the start of the matching text. With the
// -strictlimits flag, the entire matching range must lie inside the start
// and stop limits specified for the match to be valid.
//
// # Text(Strictlimits(...))
//
// When performing any search, the normal behaviour is that the start and stop
// limits are checked with respect to the start of the matching text. With the
// -strictlimits flag, the entire matching range must lie inside the start
// and stop limits specified for the match to be valid.
func Strictlimits(value any) option {
	return strictlimitsOption{value}
}

type stripedOption struct{ v any }

func (o stripedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-striped %s`, optionString(o.v))
}

// # TTreeview(Striped(...))
//
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
//
// # TTreeview(Striped(...))
//
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
func Striped(value any) option {
	return stripedOption{value}
}

type styleOption struct{ v any }

func (o styleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-style %s`, optionString(o.v))
}

// # Canvas(Style(...))
//
// Specifies how to draw the arc. If type is pieslice
// (the default) then the arc's region is defined by a section
// of the oval's perimeter plus two line segments, one between the center
// of the oval and each end of the perimeter section.
// If type is chord then the arc's region is defined
// by a section of the oval's perimeter plus a single line segment
// connecting the two end points of the perimeter section.
// If type is arc then the arc's region consists of
// a section of the perimeter alone.
// In this last case the -fill option is ignored.
//
// # Canvas(Style(...))
//
// Specifies how to draw the arc. If type is pieslice
// (the default) then the arc's region is defined by a section
// of the oval's perimeter plus two line segments, one between the center
// of the oval and each end of the perimeter section.
// If type is chord then the arc's region is defined
// by a section of the oval's perimeter plus a single line segment
// connecting the two end points of the perimeter section.
// If type is arc then the arc's region consists of
// a section of the perimeter alone.
// In this last case the -fill option is ignored.
func Style(value any) option {
	return styleOption{value}
}

type stylemaskOption struct{ v any }

func (o stylemaskOption) optionString(w *Window) string {
	return fmt.Sprintf(`-stylemask %s`, optionString(o.v))
}

// # Wm(Stylemask(...))
//
// Specifies an integer to be assigned as the styleMask of the underlying
// Aqua window.  (See the Apple documentation for styleMask property of
// the NSWindow class.) The value of this option should be a list of
// bitnames.  Each bit named in the list will be set to 1, and all other
// bits will be set to 0.  The allowed bitnames are: titled,
// closable, miniaturizable, resizable,
// fullsizecontentview, docmodal, utility,
// nonactivatingpanel, and HUDwindow.  Note that a side
// effect of setting the fullsizecontentview bit is that the window title
// bar becomes transparent.
func Stylemask(value any) option {
	return stylemaskOption{value}
}

type subsampleOption struct{ v any }

func (o subsampleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-subsample %s`, optionString(o.v))
}

// # Photo(Subsample(...))
//
// Specifies that the source image should be reduced in size by using
// only every xth pixel in the X direction and yth pixel in
// the Y direction.  Negative values will cause the image to be flipped
// about the Y or X axes, respectively.  If y is not given, the
// default value is the same as x.
func Subsample(value any) option {
	return subsampleOption{value}
}

type subwindowOption struct{ v any }

func (o subwindowOption) optionString(w *Window) string {
	return fmt.Sprintf(`-subwindow %s`, optionString(o.v))
}

// # Event(Subwindow(...))
//
// Window specifies the subwindow field for the event, either
// as a path name for a Tk widget or as an integer window identifier.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Enter, Leave, and Motion events.
// Similar to %S substitution for binding scripts.
func Subwindow(value any) option {
	return subwindowOption{value}
}

type systemTypeOption struct{ v any }

func (o systemTypeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-systemType %s`, optionString(o.v))
}

// # TkMac(SystemType(...))
//
// icon for given IconServices 4-char OSType
func SystemType(value any) option {
	return systemTypeOption{value}
}

type tabbingidOption struct{ v any }

func (o tabbingidOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tabbingid %s`, optionString(o.v))
}

// # Wm(Tabbingid(...))
//
// Controls how tabbed toplevel windows are grouped together.  Two tabs
// in the same group must correspond to toplevels with the same
// tabbingid, which can be an arbitrary UTF8 string.  In the Tk
// implementation, changing the tabbingid of a toplevel in a tab group
// will cause it to be moved into a different group, in which all tabs
// have the new tabbingid or, if the new tabbingid is unique, to become
// a normal non-tabbed toplevel.   It is allowed to set the tabbingid before the
// toplevel is created.  If the pathname provided in the command does not
// correspond to a toplevel, the value will be cached and used later when
// the toplevel is actually created.
func Tabbingid(value any) option {
	return tabbingidOption{value}
}

type tabbingmodeOption struct{ v any }

func (o tabbingmodeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tabbingmode %s`, optionString(o.v))
}

// # Wm(Tabbingmode(...))
//
// Controls whether a toplevel can be opened as a tab within a tab group.
// The allowed values are auto, preferred or
// disallowed.  A toplevel can be opened as a tab in exactly two
// situations: if its tabbingmode is preferred; or if its
// tabbingmode is auto and the user has selected "prefer tabs when
// opening documents" in the Desktop and Dock panel of the System
// Settings application.  It is allowed to set the tabbingmode before the
// toplevel is created.  If the pathname provided in the command does not
// correspond to a toplevel, the value will be cached and used later when
// the toplevel is actually created.
func Tabbingmode(value any) option {
	return tabbingmodeOption{value}
}

type tabsOption struct{ v any }

func (o tabsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tabs %s`, optionString(o.v))
}

// # Text(Tabs(...))
//
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
//
// # Text(Tabs(...))
//
// TabList specifies a set of tab stops in the same form as for the
// -tabs option for the text widget. This option only applies to a display
// line if it applies to the first non-elided character on that display line. If
// this option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default). If the option is specified as a
// non-empty string that is an empty list, such as -tags\0{\0}, then it
// requests default 8-character tabs as described for the -tags widget
// option.
//
// # Text(Tabs(...))
//
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
//
// # Text(Tabs(...))
//
// TabList specifies a set of tab stops in the same form as for the
// -tabs option for the text widget. This option only applies to a display
// line if it applies to the first non-elided character on that display line. If
// this option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default). If the option is specified as a
// non-empty string that is an empty list, such as -tags\0{\0}, then it
// requests default 8-character tabs as described for the -tags widget
// option.
func Tabs(value any) option {
	return tabsOption{value}
}

type tabstyleOption struct{ v any }

func (o tabstyleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tabstyle %s`, optionString(o.v))
}

// # Text(Tabstyle(...))
//
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n”th tab
// character in the line's text will be associated with the 'n”th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n”th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
//
// # Text(Tabstyle(...))
//
// Style specifies either the tabular or wordprocessor style of
// tabbing to use for the text widget. This option only applies to a display line
// if it applies to the first non-elided character on that display line. If this
// option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default).
//
// # Text(Tabstyle(...))
//
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n”th tab
// character in the line's text will be associated with the 'n”th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n”th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
//
// # Text(Tabstyle(...))
//
// Style specifies either the tabular or wordprocessor style of
// tabbing to use for the text widget. This option only applies to a display line
// if it applies to the first non-elided character on that display line. If this
// option is specified as an empty string, it cancels the option, leaving it
// unspecified for the tag (the default).
func Tabstyle(value any) option {
	return tabstyleOption{value}
}

type tagOption struct{ v any }

func (o tagOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tag %s`, optionString(o.v))
}

// # Text(Tag(...))
//
// Include information about tag transitions in the dump results. Tag information
// is returned as tagon and tagoff elements that indicate the begin
// and end of each range of each tag, respectively.
//
// # Text(Tag(...))
//
// Include information about tag transitions in the dump results. Tag information
// is returned as tagon and tagoff elements that indicate the begin
// and end of each range of each tag, respectively.
func Tag(value any) option {
	return tagOption{value}
}

type tagsOption struct{ v any }

func (o tagsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tags %s`, optionString(o.v))
}

// # Canvas(Tags(...))
//
// Specifies a set of tags to apply to the item.
// TagList consists of a list of tag names, which replace any
// existing tags for the item. TagList may be an empty list.
//
// # Canvas(Tags(...))
//
// Specifies a set of tags to apply to the item.
// TagList consists of a list of tag names, which replace any
// existing tags for the item. TagList may be an empty list.
func Tags(value any) option {
	return tagsOption{value}
}

type takefocusOption struct{ v any }

func (o takefocusOption) optionString(w *Window) string {
	return fmt.Sprintf(`-takefocus %s`, optionString(o.v))
}

// Determines whether the window accepts the focus during keyboard
// traversal (e.g., Tab and Shift-Tab).
// Before setting the focus to a window, the traversal scripts
// consult the value of the '-takefocus' option.
// A value of '0' means that the window should be skipped entirely
// during keyboard traversal.
// '1' means that the window should receive the input
// focus as long as it is viewable (it and all of its ancestors are mapped).
// An empty value for the option means that the traversal scripts make
// the decision about whether or not to focus on the window:  the current
// algorithm is to skip the window if it is
// disabled, if it has no key bindings, or if it is not viewable.
// If the value has any other form, then the traversal scripts take
// the value, append the name of the window to it (with a separator space),
// and evaluate the resulting string as a Tcl script.
// The script must return '0', '1', or an empty string:  a
// '0' or '1' value specifies whether the window will receive
// the input focus, and an empty string results in the default decision
// described above.
// Note that this interpretation of the option is defined entirely by
// the Tcl scripts that implement traversal:  the widget implementations
// ignore the option entirely, so you can change its meaning if you
// redefine the keyboard traversal scripts.
func Takefocus(value any) option {
	return takefocusOption{value}
}

type tearoffOption struct{ v any }

func (o tearoffOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tearoff %s`, optionString(o.v))
}

// # Menu(Tearoff(...))
//
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
//
// # Menu(Tearoff(...))
//
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
func Tearoff(value any) option {
	return tearoffOption{value}
}

// See also [Event handlers]
//
// # Menu(Tearoffcommand(...))
//
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
//
// # Menu(Tearoffcommand(...))
//
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Tearoffcommand(args ...any) option {
	return newEventHandler("-tearoffcommand", args...)
}

type templateOption struct{ v any }

func (o templateOption) optionString(w *Window) string {
	return fmt.Sprintf(`-template %s`, optionString(o.v))
}

// # Nsimage(Template(...))
func Template(value any) option {
	return templateOption{value}
}

type textOption struct{ v any }

func (o textOption) optionString(w *Window) string {
	return fmt.Sprintf(`-text %s`, optionString(o.v))
}

// Specifies a string to be displayed inside the widget.  The way in which
// the string is displayed depends on the particular widget and may be
// determined by other options, such as '-anchor' or '-justify'.
//
// # Canvas(Txt(...))
//
// String specifies the characters to be displayed in the text item.
// Newline characters cause line breaks.
// The characters in the item may also be changed with the
// insert and delete widget commands.
// This option defaults to an empty string.
//
// # Canvas(Txt(...))
//
// String specifies the characters to be displayed in the text item.
// Newline characters cause line breaks.
// The characters in the item may also be changed with the
// insert and delete widget commands.
// This option defaults to an empty string.
//
// # Text(Txt(...))
//
// Include information about text in the dump results. The value is the text up
// to the next element or the end of range indicated by index2. A text
// element does not span newlines. A multi-line block of text that contains no
// marks or tag transitions will still be dumped as a set of text segments that
// each end with a newline. The newline is part of the value.
//
// # Text(Txt(...))
//
// Include information about text in the dump results. The value is the text up
// to the next element or the end of range indicated by index2. A text
// element does not span newlines. A multi-line block of text that contains no
// marks or tag transitions will still be dumped as a set of text segments that
// each end with a newline. The newline is part of the value.
//
// # TLabelframe(Txt(...))
//
// Specifies the text of the label.
//
// # TLabelframe(Txt(...))
//
// Specifies the text of the label.
//
// # TNotebook(Txt(...))
//
// Specifies a string to be displayed in the tab.
//
// # TNotebook(Txt(...))
//
// Specifies a string to be displayed in the tab.
//
// # TTreeview(Txt(...))
//
// The text to display in the column heading.
//
// # TTreeview(Txt(...))
//
// The text to display in the column heading.
func Txt(value any) option {
	return textOption{value}
}

// See also [Event handlers]
//
// Specifies the name of a global variable.  The value of the variable is a text
// string to be displayed inside the widget;  if the variable value changes
// then the widget will automatically update itself to reflect the new value.
// The way in which the string is displayed in the widget depends on the
// particular widget and may be determined by other options, such as
// '-anchor' or '-justify'.
//
// # TCombobox(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
//
// # TCombobox(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
//
// # TEntry(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
//
// # TEntry(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Textvariable(args ...any) option {
	return newEventHandler("-textvariable", args...)
}

type tickintervalOption struct{ v any }

func (o tickintervalOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tickinterval %s`, optionString(o.v))
}

// # Scale(Tickinterval(...))
//
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
//
// # Scale(Tickinterval(...))
//
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
func Tickinterval(value any) option {
	return tickintervalOption{value}
}

type tileOption struct{ v any }

func (o tileOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tile %s`, optionString(o.v))
}

// # Frame(Tile(...))
//
// "8.7, TIP262"
//
// # Frame(Tile(...))
//
// "8.7, TIP262"
//
// # Toplevel(Tile(...))
//
// "8.7, TIP262"
//
// # Toplevel(Tile(...))
//
// "8.7, TIP262"
func Tile(value any) option {
	return tileOption{value}
}

type timeOption struct{ v any }

func (o timeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-time %s`, optionString(o.v))
}

// # Event(Time(...))
//
// Integer must be an integer value;  it specifies the time field
// for the event. Additionally, the special value current is allowed;
// this value will be substituted by the current event time.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Enter, Leave, Motion,
// and Property events.
// Corresponds to the %t substitution for binding scripts.
func Time(value any) option {
	return timeOption{value}
}

type titleOption struct{ v any }

func (o titleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-title %s`, optionString(o.v))
}

// # ChooseColor(Title(...))
//
// Specifies a string to display as the title of the dialog box. If this
// option is not specified, then a default title will be displayed.
//
// # ChooseDirectory(Title(...))
//
// Specifies a string to display as the title of the dialog box. If this
// option is not specified, then a default title will be displayed.
//
// # Fontchooser(Title(...))
//
// Specifies/returns the title of the dialog. Has no effect on platforms where the
// font selection dialog does not support titles.
//
// # GetOpenFile(Title(...))
//
// Specifies a string to display as the title of the dialog box. If this
// option is not specified, then a default title is displayed.
//
// # Menu(Title(...))
//
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
//
// # Menu(Title(...))
//
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
//
// # MessageBox(Title(...))
//
// Specifies a string to display as the title of the message box. The
// default value is an empty string.
func Title(value any) option {
	return titleOption{value}
}

type titlecolumnsOption struct{ v any }

func (o titlecolumnsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-titlecolumns %s`, optionString(o.v))
}

// # TTreeview(Titlecolumns(...))
//
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
//
// # TTreeview(Titlecolumns(...))
//
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
func Titlecolumns(value any) option {
	return titlecolumnsOption{value}
}

type titleitemsOption struct{ v any }

func (o titleitemsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-titleitems %s`, optionString(o.v))
}

// # TTreeview(Titleitems(...))
//
// Number of items at the top that should not be vertically scrolled. Default is 0.
//
// # TTreeview(Titleitems(...))
//
// Number of items at the top that should not be vertically scrolled. Default is 0.
func Titleitems(value any) option {
	return titleitemsOption{value}
}

type titlepathOption struct{ v any }

func (o titlepathOption) optionString(w *Window) string {
	return fmt.Sprintf(`-titlepath %s`, optionString(o.v))
}

// # Wm(Titlepath(...))
//
// Specifies the path of the file referenced as the window proxy icon
// (which can be dragged and dropped in lieu of the file's finder icon).
func Titlepath(value any) option {
	return titlepathOption{value}
}

type toOption struct{ v any }

func (o toOption) optionString(w *Window) string {
	return fmt.Sprintf(`-to %s`, optionString(o.v))
}

// # Photo(To(...))
//
// Specifies a rectangular sub-region of the destination image to be
// affected.  (x1,y1) and (x2,y2) specify diagonally opposite
// corners of the rectangle.  If x2 and y2 are not specified,
// the default value is (x1,y1) plus the size of the source
// region (after subsampling and zooming, if specified).  If x2 and
// y2 are specified, the source region will be replicated if
// necessary to fill the destination region in a tiled fashion.
//
// # Photo(To(...))
//
// Specifies the coordinates of the top-left corner (x1,y1)
// of the region of imageName into which the image data will be
// copied.  The default position is (0,0).  If x2,y2 is given
// and data is not large enough to cover the rectangle specified by
// this option, the image data extracted will be tiled so it covers the
// entire destination rectangle. If the region specified with this option
// is smaller than the supplied data, the exceeding data is silently
// discarded. Note that if data specifies a
// single color value, then a region extending to the bottom-right corner
// represented by (x2,y2) will be filled with that color.
//
// # Photo(To(...))
//
// Specifies the coordinates of the top-left corner of the region of
// imageName into which data from filename are to be read.
// The default is (0,0).
//
// # Scale(To(...))
//
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # Scale(To(...))
//
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # Spinbox(To(...))
//
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # Spinbox(To(...))
//
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # TScale(To(...))
//
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # TScale(To(...))
//
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # TSpinbox(To(...))
//
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
//
// # TSpinbox(To(...))
//
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
func To(value any) option {
	return toOption{value}
}

type toolwindowOption struct{ v any }

func (o toolwindowOption) optionString(w *Window) string {
	return fmt.Sprintf(`-toolwindow %s`, optionString(o.v))
}

// # Wm(Toolwindow(...))
//
// Specifies a toolwindow style window (as defined in the MSDN).
func Toolwindow(value any) option {
	return toolwindowOption{value}
}

type topmostOption struct{ v any }

func (o topmostOption) optionString(w *Window) string {
	return fmt.Sprintf(`-topmost %s`, optionString(o.v))
}

// # Wm(Topmost(...))
//
// Specifies whether this is a topmost window (displays above all other windows).
func Topmost(value any) option {
	return topmostOption{value}
}

type transparentOption struct{ v any }

func (o transparentOption) optionString(w *Window) string {
	return fmt.Sprintf(`-transparent %s`, optionString(o.v))
}

// # Wm(Transparent(...))
//
// Makes the window content area transparent and turns off the window shadow. For
// the transparency to be effective, the toplevel background needs to be set to a
// color with some alpha, e.g.
func Transparent(value any) option {
	return transparentOption{value}
}

type transparentcolorOption struct{ v any }

func (o transparentcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-transparentcolor %s`, optionString(o.v))
}

// # Wm(Transparentcolor(...))
//
// Specifies the transparent color index of the toplevel.  It takes any color
// value accepted by Tk_GetColor.  If the empty string is specified
// (default), no transparent color is used.  This is supported on Windows
// 2000/XP+.  Where not supported, the -transparentcolor value remains
// at {}.
func Transparentcolor(value any) option {
	return transparentcolorOption{value}
}

type tristateimageOption struct{ v any }

func (o tristateimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tristateimage %s`, optionString(o.v))
}

// # Checkbutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Checkbutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
func Tristateimage(value any) option {
	return tristateimageOption{value}
}

type tristatevalueOption struct{ v any }

func (o tristatevalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tristatevalue %s`, optionString(o.v))
}

// # Checkbutton(Tristatevalue(...))
//
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Checkbutton(Tristatevalue(...))
//
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Radiobutton(Tristatevalue(...))
//
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Radiobutton(Tristatevalue(...))
//
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
func Tristatevalue(value any) option {
	return tristatevalueOption{value}
}

type troughcolorOption struct{ v any }

func (o troughcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-troughcolor %s`, optionString(o.v))
}

// Specifies the color to use for the rectangular trough areas
// in widgets such as scrollbars and scales.  This option is ignored for
// scrollbars on Windows (native widget does not recognize this option).
func Troughcolor(value any) option {
	return troughcolorOption{value}
}

type typeOption struct{ v any }

func (o typeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-type %s`, optionString(o.v))
}

// # Menu(Type(...))
//
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
//
// # Menu(Type(...))
//
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
//
// # MessageBox(Type(...))
//
// Arranges for a predefined set of buttons to be displayed. The
// following values are possible for predefinedType:
//
// # Wm(Type(...))
func Type(value any) option {
	return typeOption{value}
}

type typevariableOption struct{ v any }

func (o typevariableOption) optionString(w *Window) string {
	return fmt.Sprintf(`-typevariable %s`, optionString(o.v))
}

// # GetOpenFile(Typevariable(...))
//
// The global variable variableName is used to preselect which filter is
// used from filterList when the dialog box is opened and is
// updated when the dialog box is closed, to the last selected
// filter. The variable is read once at the beginning to select the
// appropriate filter. If the variable does not exist, or its value does
// not match any filter typename, or is empty ({}), the dialog box
// will revert to the default behavior of selecting the first filter in
// the list. If the dialog is canceled, the variable is not modified.
func Typevariable(value any) option {
	return typevariableOption{value}
}

type underlineOption struct{ v any }

func (o underlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-underline %s`, optionString(o.v))
}

// Specifies the integer index of a character to underline in the widget.
// This option is used by the default bindings to implement keyboard
// traversal for menu buttons and menu entries.
// 0 corresponds to the first character of the text displayed in the
// widget, 1 to the next character, and so on. 'end' corresponds to the
// last character, 'end'-1 to the before last character, and so on.
//
// # Canvas(Underline(...))
//
// Specifies the integer index of a character within the text to be
// underlined. 0 corresponds to the first character of the text
// displayed, 1 to the next character, and so on. -1 means that no
// underline should be drawn (if the whole text item is to be underlined,
// the appropriate font should be used instead).
//
// # Canvas(Underline(...))
//
// Specifies the integer index of a character within the text to be
// underlined. 0 corresponds to the first character of the text
// displayed, 1 to the next character, and so on. -1 means that no
// underline should be drawn (if the whole text item is to be underlined,
// the appropriate font should be used instead).
//
// # Font(Underline(...))
//
// The value is a boolean flag that specifies whether characters in this
// font should be underlined.  The default value for underline is false.
//
// # Menu(Underline(...))
//
// Specifies the integer index of a character to underline in the entry.
// This option is also queried by the default bindings and used to
// implement keyboard traversal.
// 0 corresponds to the first character of the text displayed in the entry,
// 1 to the next character, and so on.
// If a bitmap or image is displayed in the entry then this option is ignored.
// This option is not available for separator or tear-off entries.
//
// # Menu(Underline(...))
//
// Specifies the integer index of a character to underline in the entry.
// This option is also queried by the default bindings and used to
// implement keyboard traversal.
// 0 corresponds to the first character of the text displayed in the entry,
// 1 to the next character, and so on.
// If a bitmap or image is displayed in the entry then this option is ignored.
// This option is not available for separator or tear-off entries.
//
// # Text(Underline(...))
//
// Boolean specifies whether or not to draw an underline underneath
// characters. It may have any of the forms accepted by Tcl_GetBoolean.
//
// # Text(Underline(...))
//
// Boolean specifies whether or not to draw an underline underneath
// characters. It may have any of the forms accepted by Tcl_GetBoolean.
//
// # TLabelframe(Underline(...))
//
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
//
// # TLabelframe(Underline(...))
//
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
//
// # TNotebook(Underline(...))
//
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
//
// # TNotebook(Underline(...))
//
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
func Underline(value any) option {
	return underlineOption{value}
}

type underlinefgOption struct{ v any }

func (o underlinefgOption) optionString(w *Window) string {
	return fmt.Sprintf(`-underlinefg %s`, optionString(o.v))
}

// # Text(Underlinefg(...))
//
// Color specifies the color to use when displaying the underline. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
//
// # Text(Underlinefg(...))
//
// Color specifies the color to use when displaying the underline. It may
// have any of the forms accepted by Tk_GetColor. If color has not
// been specified, or if it is specified as an empty string, then the color
// specified by the -foreground tag option is used.
func Underlinefg(value any) option {
	return underlinefgOption{value}
}

type undoOption struct{ v any }

func (o undoOption) optionString(w *Window) string {
	return fmt.Sprintf(`-undo %s`, optionString(o.v))
}

// # Text(Undo(...))
//
// Specifies a boolean that says whether the undo mechanism is active or not.
//
// # Text(Undo(...))
//
// Specifies a boolean that says whether the undo mechanism is active or not.
func Undo(value any) option {
	return undoOption{value}
}

type useOption struct{ v any }

func (o useOption) optionString(w *Window) string {
	return fmt.Sprintf(`-use %s`, optionString(o.v))
}

// # Toplevel(Use(...))
//
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Use(...))
//
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
func Use(value any) option {
	return useOption{value}
}

type validateOption struct{ v any }

func (o validateOption) optionString(w *Window) string {
	return fmt.Sprintf(`-validate %s`, optionString(o.v))
}

// # Entry(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Entry(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Spinbox(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Spinbox(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # TEntry(Validate(...))
//
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
//
// # TEntry(Validate(...))
//
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
func Validate(value any) option {
	return validateOption{value}
}

// See also [Event handlers]
//
// # Entry(Validatecommand(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Entry(Validatecommand(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Validatecommand(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Validatecommand(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// # TEntry(Validatecommand(...))
//
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
//
// # TEntry(Validatecommand(...))
//
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Validatecommand(args ...any) option {
	return newEventHandler("-validatecommand", args...)
}

type valueOption struct{ v any }

func (o valueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-value %s`, optionString(o.v))
}

// # Menu(Value(...))
//
// Available only for radiobutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
// If an empty string is specified, then the -label option
// for the entry as the value to store in the variable.
//
// # Menu(Value(...))
//
// Available only for radiobutton entries.  Specifies the value to
// store in the entry's associated variable when the entry is selected.
// If an empty string is specified, then the -label option
// for the entry as the value to store in the variable.
//
// # Radiobutton(Value(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.
//
// # Radiobutton(Value(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.
//
// # TProgressbar(Value(...))
//
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
//
// # TProgressbar(Value(...))
//
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
//
// # TRadiobutton(Value(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.
//
// # TRadiobutton(Value(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.
//
// # TScale(Value(...))
//
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
//
// # TScale(Value(...))
//
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
func Value(value any) option {
	return valueOption{value}
}

type valuesOption struct{ v any }

func (o valuesOption) optionString(w *Window) string {
	return fmt.Sprintf(`-values %s`, optionString(o.v))
}

// # Spinbox(Values(...))
//
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
//
// # Spinbox(Values(...))
//
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
//
// # TCombobox(Values(...))
//
// Specifies the list of values to display in the drop-down listbox.
//
// # TCombobox(Values(...))
//
// Specifies the list of values to display in the drop-down listbox.
//
// # TSpinbox(Values(...))
//
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
//
// # TSpinbox(Values(...))
//
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
func Values(value any) option {
	return valuesOption{value}
}

type variableOption struct{ v any }

func (o variableOption) optionString(w *Window) string {
	return fmt.Sprintf(`-variable %s`, optionString(o.v))
}

// # Checkbutton(Variable(...))
//
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
//
// # Checkbutton(Variable(...))
//
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
//
// # Menu(Variable(...))
//
// Available only for checkbutton and radiobutton entries.  Specifies
// the name of a global variable to set when the entry is selected.
// For checkbutton entries the variable is also set when the entry
// is deselected.  For radiobutton entries, changing the variable
// causes the currently-selected entry to deselect itself.
//
// # Menu(Variable(...))
//
// Available only for checkbutton and radiobutton entries.  Specifies
// the name of a global variable to set when the entry is selected.
// For checkbutton entries the variable is also set when the entry
// is deselected.  For radiobutton entries, changing the variable
// causes the currently-selected entry to deselect itself.
//
// # Radiobutton(Variable(...))
//
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
//
// # Radiobutton(Variable(...))
//
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
//
// # Scale(Variable(...))
//
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
//
// # Scale(Variable(...))
//
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
//
// # TCheckbutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
//
// # TCheckbutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
//
// # TProgressbar(Variable(...))
//
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
//
// # TProgressbar(Variable(...))
//
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
//
// # TRadiobutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
//
// # TRadiobutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
//
// # TScale(Variable(...))
//
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
//
// # TScale(Variable(...))
//
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
func Variable(value any) option {
	return variableOption{value}
}

// See also [Event handlers]
//
// # Entry(Vcmd(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Entry(Vcmd(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Vcmd(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Vcmd(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Vcmd(args ...any) option {
	return newEventHandler("-vcmd", args...)
}

type visibleOption struct{ v any }

func (o visibleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-visible %s`, optionString(o.v))
}

// # Fontchooser(Visible(...))
//
// Read-only option that returns a boolean indicating whether the font selection
// dialog is currently visible. Attempting to set this option results in an error.
// .
func Visible(value any) option {
	return visibleOption{value}
}

type visualOption struct{ v any }

func (o visualOption) optionString(w *Window) string {
	return fmt.Sprintf(`-visual %s`, optionString(o.v))
}

// # Frame(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Frame(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Labelframe(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Labelframe(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
func Visual(value any) option {
	return visualOption{value}
}

type warpOption struct{ v any }

func (o warpOption) optionString(w *Window) string {
	return fmt.Sprintf(`-warp %s`, optionString(o.v))
}

// # Event(Warp(...))
//
// boolean must be a boolean value;  it specifies whether
// the screen pointer should be warped as well.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, and Motion events.  The pointer will
// only warp to a window if it is mapped.
func Warp(value any) option {
	return warpOption{value}
}

type weightOption struct{ v any }

func (o weightOption) optionString(w *Window) string {
	return fmt.Sprintf(`-weight %s`, optionString(o.v))
}

// # Font(Weight(...))
//
// The nominal thickness of the characters in the font.  The value
// normal specifies a normal weight font, while bold specifies a
// bold font.  The closest available weight to the one specified will
// be chosen.  The default weight is normal.
//
// # TPanedwindow(Weight(...))
//
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
//
// # TPanedwindow(Weight(...))
//
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
func Weight(value any) option {
	return weightOption{value}
}

type whenOption struct{ v any }

func (o whenOption) optionString(w *Window) string {
	return fmt.Sprintf(`-when %s`, optionString(o.v))
}

// # Event(When(...))
//
// When determines when the event will be processed;  it must have one
// of the following values:
func When(value any) option {
	return whenOption{value}
}

type widthOption struct{ v any }

func (o widthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-width %s`, optionString(o.v))
}

// # Button(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Button(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Canvas(Width(...))
//
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Width(...))
//
// Specifies the width of the area of the canvas to print.
// Defaults to the width of the canvas window.
//
// # Canvas(Width(...))
//
// # Canvas(Width(...))
//
// Specifies a maximum line length for the text, in any of the forms
// described in the COORDINATES section above.
// If this option is zero (the default) the text is broken into
// lines only at newline characters.
// However, if this option is non-zero then any line that would
// be longer than lineLength is broken just before a space
// character to make the line shorter than lineLength; the
// space character is treated as if it were a newline
// character.
//
// # Canvas(Width(...))
//
// Specifies the width to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever width it requests internally.
//
// # Canvas(Width(...))
//
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Canvas(Width(...))
//
// Specifies the width of the area of the canvas to print.
// Defaults to the width of the canvas window.
//
// # Canvas(Width(...))
//
// # Canvas(Width(...))
//
// Specifies a maximum line length for the text, in any of the forms
// described in the COORDINATES section above.
// If this option is zero (the default) the text is broken into
// lines only at newline characters.
// However, if this option is non-zero then any line that would
// be longer than lineLength is broken just before a space
// character to make the line shorter than lineLength; the
// space character is treated as if it were a newline
// character.
//
// # Canvas(Width(...))
//
// Specifies the width to assign to the item's window.
// Pixels may have any of the
// forms described in the COORDINATES section above.
// If this option is not specified, or if it is specified as zero,
// then the window is given whatever width it requests internally.
//
// # Checkbutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Checkbutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Entry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Entry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Event(Width(...))
//
// Size must be a screen distance;  it specifies the width field
// for the event.
// Valid for Configure events.
// Corresponds to the %w substitution for binding scripts.
//
// # Frame(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
//
// # Frame(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
//
// # Label(Width(...))
//
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Label(Width(...))
//
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Labelframe(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Labelframe(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Listbox(Width(...))
//
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
//
// # Listbox(Width(...))
//
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
//
// # Menubutton(Width(...))
//
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Menubutton(Width(...))
//
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Message(Width(...))
//
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
//
// # Message(Width(...))
//
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
//
// # Nsimage(Width(...))
//
// # Panedwindow(Width(...))
//
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
//
// # Panedwindow(Width(...))
//
// Specify a width for the window.  The width will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -width is not specified, then the
// width requested internally by the window will be used initially; the
// width may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Panedwindow(Width(...))
//
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
//
// # Panedwindow(Width(...))
//
// Specify a width for the window.  The width will be the outer
// dimension of the window including its border, if any.  If size
// is an empty string, or if -width is not specified, then the
// width requested internally by the window will be used initially; the
// width may later be adjusted by the movement of sashes in the
// panedwindow.  Size may be any value accepted by Tk_GetPixels.
//
// # Photo(Width(...))
//
// Specifies the width of the image, in pixels.    This option is useful
// primarily in situations where the user wishes to build up the contents
// of the image piece by piece.  A value of zero (the default) allows the
// image to expand or shrink horizontally to fit the data stored in it.
//
// # Place(Width(...))
//
// Size specifies the width for window in screen units
// (i.e. any of the forms accepted by Tk_GetPixels).
// The width will be the outer width of window including its
// border, if any.
// If size is an empty string, or if no -width
// or -relwidth option is specified, then the width requested
// internally by the window will be used.
//
// # Radiobutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Radiobutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Scale(Width(...))
//
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
//
// # Scale(Width(...))
//
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
//
// # Scrollbar(Width(...))
//
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # Scrollbar(Width(...))
//
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # Spinbox(Width(...))
//
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Spinbox(Width(...))
//
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Text(Width(...))
//
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
//
// # Text(Width(...))
//
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
//
// # Toplevel(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Toplevel(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # TCombobox(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # TCombobox(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # TEntry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # TEntry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # TFrame(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TFrame(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TImage(Width(...))
//
// Specifies a minimum width for the element.
// If less than zero, the base image's width is used as a default.
//
// # TLabelframe(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TLabelframe(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TNotebook(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
//
// # TNotebook(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
//
// # TPanedwindow(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
//
// # TPanedwindow(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
//
// # TTreeview(Width(...))
//
// The width of the column in pixels.  Default is 200 pixels. The specified
// column width may be changed by Tk in order to honor -stretch
// and/or -minwidth, or when the widget is resized or the user drags a
// heading column separator.
//
// # TTreeview(Width(...))
//
// The width of the column in pixels.  Default is 200 pixels. The specified
// column width may be changed by Tk in order to honor -stretch
// and/or -minwidth, or when the widget is resized or the user drags a
// heading column separator.
//
// # TVsapi(Width(...))
//
// Specifies the height for the element. If this option is set then
// the Visual Styles API will not be queried for the recommended
// size or the part. If this option is set then -height should
// also be set. The -width and -height options cannot
// be mixed with the -padding or -margins options.
func Width(value any) option {
	return widthOption{value}
}

type windowOption struct{ v any }

func (o windowOption) optionString(w *Window) string {
	return fmt.Sprintf(`-window %s`, optionString(o.v))
}

type wrapOption struct{ v any }

func (o wrapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-wrap %s`, optionString(o.v))
}

// # Spinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Spinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Text(Wrap(...))
//
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
//
// # Text(Wrap(...))
//
// Mode specifies how to handle lines that are wider than the text's
// window. This option only applies to a display line if it applies to the
// first non-elided character on that display line. It has the same legal
// values as the -wrap option for the text widget: none,
// char, or word. If this tag option is specified, it
// overrides the -wrap option for the text widget.
//
// # Text(Wrap(...))
//
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
//
// # Text(Wrap(...))
//
// Mode specifies how to handle lines that are wider than the text's
// window. This option only applies to a display line if it applies to the
// first non-elided character on that display line. It has the same legal
// values as the -wrap option for the text widget: none,
// char, or word. If this tag option is specified, it
// overrides the -wrap option for the text widget.
//
// # TSpinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # TSpinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
func Wrap(value any) option {
	return wrapOption{value}
}

type wraplengthOption struct{ v any }

func (o wraplengthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-wraplength %s`, optionString(o.v))
}

// For widgets that can perform word-wrapping, this option specifies
// the maximum line length.
// Lines that would exceed this length are wrapped onto the next line,
// so that no line is longer than the specified length.
// The value may be specified in any of the standard forms for
// screen distances.
// If this value is less than or equal to 0 then no wrapping is done:  lines
// will break only at newline characters in the text.
//
// # TLabel(Wraplength(...))
//
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
//
// # TLabel(Wraplength(...))
//
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
func Wraplength(value any) option {
	return wraplengthOption{value}
}

type xOption struct{ v any }

func (o xOption) optionString(w *Window) string {
	return fmt.Sprintf(`-x %s`, optionString(o.v))
}

// # Canvas(X(...))
//
// Specifies the x-coordinate of the left edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the left edge of the window.
//
// # Canvas(X(...))
//
// Specifies the x-coordinate of the left edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the left edge of the window.
//
// # Event(X(...))
//
// Coord must be a screen distance;  it specifies the x field
// for the event.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Motion, Enter, Leave,
// Expose, Configure, Gravity, and Reparent
// events.
// Corresponds to the %x substitution for binding scripts.
// If Window is empty the coordinate is relative to the
// screen, and this option corresponds to the %X substitution
// for binding scripts.
//
// # Place(X(...))
//
// Location specifies the x-coordinate within the container window
// of the anchor point for window.
// The location is specified in screen units (i.e. any of the forms
// accepted by Tk_GetPixels) and need not lie within the bounds
// of the container window.
func X(value any) option {
	return xOption{value}
}

// See also [Event handlers]
//
// Specifies the prefix for a command used to communicate with horizontal
// scrollbars.
// When the view in the widget's window changes (or
// whenever anything else occurs that could change the display in a
// scrollbar, such as a change in the total size of the widget's
// contents), the widget will
// generate a Tcl command by concatenating the scroll command and
// two numbers.
// Each of the numbers is a fraction between 0 and 1, which indicates
// a position in the document.  0 indicates the beginning of the document,
// 1 indicates the end, .333 indicates a position one third the way through
// the document, and so on.
// The first fraction indicates the first information in the document
// that is visible in the window, and the second fraction indicates
// the information just after the last portion that is visible.
// The command is
// then passed to the Tcl interpreter for execution.  Typically the
// '-xscrollcommand' option consists of the path name of a scrollbar
// widget followed by
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Xscrollcommand(args ...any) option {
	return newEventHandler("-xscrollcommand", args...)
}

type xscrollincrementOption struct{ v any }

func (o xscrollincrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-xscrollincrement %s`, optionString(o.v))
}

// # Canvas(Xscrollincrement(...))
//
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
//
// # Canvas(Xscrollincrement(...))
//
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
func Xscrollincrement(value any) option {
	return xscrollincrementOption{value}
}

type yOption struct{ v any }

func (o yOption) optionString(w *Window) string {
	return fmt.Sprintf(`-y %s`, optionString(o.v))
}

// # Canvas(Y(...))
//
// Specifies the y-coordinate of the top edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the top edge of the window.
//
// # Canvas(Y(...))
//
// Specifies the y-coordinate of the top edge of the area of the
// canvas that is to be printed, in canvas coordinates, not window
// coordinates.
// Defaults to the coordinate of the top edge of the window.
//
// # Event(Y(...))
//
// Coord must be a screen distance;  it specifies the y
// field for the event.
// Valid for Key, KeyRelease, Button,
// ButtonRelease, Motion, Enter, Leave,
// Expose, Configure, Gravity, and Reparent
// events.
// Corresponds to the %y substitution for binding scripts.
// If Window is empty the coordinate is relative to the
// screen, and this option corresponds to the %Y substitution
// for binding scripts.
//
// # Place(Y(...))
//
// Location specifies the y-coordinate within the container window
// of the anchor point for window.
// The location is specified in screen units (i.e. any of the forms
// accepted by Tk_GetPixels) and need not lie within the bounds
// of the container window.
func Y(value any) option {
	return yOption{value}
}

// See also [Event handlers]
//
// Specifies the prefix for a command used to communicate with vertical
// scrollbars.  This option is treated in the same way as the
// '-xscrollcommand' option, except that it is used for vertical
// scrollbars and is provided by widgets that support vertical scrolling.
// See the description of '-xscrollcommand' for details
// on how this option is used.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Yscrollcommand(args ...any) option {
	return newEventHandler("-yscrollcommand", args...)
}

type yscrollincrementOption struct{ v any }

func (o yscrollincrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-yscrollincrement %s`, optionString(o.v))
}

// # Canvas(Yscrollincrement(...))
//
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
//
// # Canvas(Yscrollincrement(...))
//
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
func Yscrollincrement(value any) option {
	return yscrollincrementOption{value}
}

type zoomOption struct{ v any }

func (o zoomOption) optionString(w *Window) string {
	return fmt.Sprintf(`-zoom %s`, optionString(o.v))
}

// # Photo(Zoom(...))
//
// Specifies that the source region should be magnified by a factor of
// x in the X direction and y in the Y direction.  If y
// is not given, the default value is the same as x.  With this
// option, each pixel in the source image will be expanded into a block
// of x x y pixels in the destination image, all the same
// color.  x and y must be greater than 0.
func Zoom(value any) option {
	return zoomOption{value}
}

type zoomedOption struct{ v any }

func (o zoomedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-zoomed %s`, optionString(o.v))
}

// # Wm(Zoomed(...))
//
// Requests that the window should be maximized. This is the same as wm state
// zoomed on Windows and Mac OS X.
func Zoomed(value any) option {
	return zoomedOption{value}
}

func Nice() option {
	return stringOption(fmt.Sprintf(`-nice`))
}

// # bitmap.Cget(...)
//
// Query or modify the configuration options for the image.
// If no option is specified, returns a list describing all of
// the available options for imageName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the
// image create bitmap command.
//
// # photo.Cget(...)
//
// Query or modify the configuration options for the image.
// If no option is specified, returns a list describing all of
// the available options for imageName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the
// image create photo command.
func (rx *Img) Cget(opt func(any) option) any {
	return evalAny(fmt.Sprintf(`%s cget %s`, rx.optionString(nil), collect0(opt)))
}

// # button.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the button
// command.
//
// # canvas.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list). If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified). If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s); in
// this case the command returns an empty string.
// Option may have any of the values accepted by the canvas
// command.
//
// # checkbutton.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the checkbutton
// command.
//
// # entry.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the entry
// command.
//
// # frame.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the frame
// command.
//
// # label.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the label
// command.
//
// # labelframe.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the labelframe
// command.
//
// # listbox.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the listbox
// command.
//
// # menu.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the menu
// command.
//
// # menubutton.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the menubutton
// command.
//
// # message.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the message
// command.
//
// # panedwindow.Cget(...)
//
// Query or modify the configuration options of the widget.  If no
// option is specified, returns a list describing all of the
// available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string. Option may have
// any of the values accepted by the panedwindow command.
//
// # radiobutton.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the radiobutton
// command.
//
// # scale.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the scale
// command.
//
// # scrollbar.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the scrollbar
// command.
//
// # spinbox.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the spinbox
// command.
//
// # text.Cget(...)
//
// Query or modify the configuration options of the widget. If no option is
// specified, returns a list describing all of the available options for
// pathName (see Tk_ConfigureInfo for information on the format of
// this list). If option is specified with no value, then the command
// returns a list describing the one named option (this list will be identical to
// the corresponding sublist of the value returned if no option is
// specified). If one or more option-value pairs are specified, then the
// command modifies the given widget option(s) to have the given value(s); in
// this case the command returns an empty string. Option may have any of
// the values accepted by the text command.
//
// # toplevel.Cget(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the toplevel
// command.
func (rx *Window) Cget(opt func(any) option) any {
	return evalAny(fmt.Sprintf(`%s cget %s`, rx.optionString(nil), collect0(opt)))
}

// # bitmap.Configure(...)
//
// Query or modify the configuration options for the image.
// If no option is specified, returns a list describing all of
// the available options for imageName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the
// image create bitmap command.
//
// # photo.Configure(...)
//
// Query or modify the configuration options for the image.
// If no option is specified, returns a list describing all of
// the available options for imageName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the
// image create photo command.
func (rx *Img) Configure(options ...option) any {
	return evalAny(fmt.Sprintf(`%s configure %s`, rx.optionString(nil), collect(options...)))
}

// # button.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the button
// command.
//
// # canvas.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list). If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified). If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s); in
// this case the command returns an empty string.
// Option may have any of the values accepted by the canvas
// command.
//
// # checkbutton.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the checkbutton
// command.
//
// # entry.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the entry
// command.
//
// # frame.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the frame
// command.
//
// # label.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the label
// command.
//
// # labelframe.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the labelframe
// command.
//
// # listbox.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the listbox
// command.
//
// # menu.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the menu
// command.
//
// # menubutton.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the menubutton
// command.
//
// # message.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the message
// command.
//
// # panedwindow.Configure(...)
//
// Query or modify the configuration options of the widget.  If no
// option is specified, returns a list describing all of the
// available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string. Option may have
// any of the values accepted by the panedwindow command.
//
// # radiobutton.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the radiobutton
// command.
//
// # scale.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the scale
// command.
//
// # scrollbar.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the scrollbar
// command.
//
// # spinbox.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the spinbox
// command.
//
// # text.Configure(...)
//
// Query or modify the configuration options of the widget. If no option is
// specified, returns a list describing all of the available options for
// pathName (see Tk_ConfigureInfo for information on the format of
// this list). If option is specified with no value, then the command
// returns a list describing the one named option (this list will be identical to
// the corresponding sublist of the value returned if no option is
// specified). If one or more option-value pairs are specified, then the
// command modifies the given widget option(s) to have the given value(s); in
// this case the command returns an empty string. Option may have any of
// the values accepted by the text command.
//
// # toplevel.Configure(...)
//
// Query or modify the configuration options of the widget.
// If no option is specified, returns a list describing all of
// the available options for pathName (see Tk_ConfigureInfo for
// information on the format of this list).  If option is specified
// with no value, then the command returns a list describing the
// one named option (this list will be identical to the corresponding
// sublist of the value returned if no option is specified).  If
// one or more option-value pairs are specified, then the command
// modifies the given widget option(s) to have the given value(s);  in
// this case the command returns an empty string.
// Option may have any of the values accepted by the toplevel
// command.
func (rx *Window) Configure(options ...option) any {
	return evalAny(fmt.Sprintf(`%s configure %s`, rx.optionString(nil), collect(options...)))
}
