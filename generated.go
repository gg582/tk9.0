// Code generated by generator.go, DO NOT EDIT.

package tk9_0 // import "modernc.org/tk9.0"

import (
	"fmt"
)



// bell - Ring a display's bell
// 
// This command rings the bell on the display for window and
// returns an empty string.
// If the -displayof option is omitted, the display of the
// application's main window is used by default.
// The command uses the current bell-related settings for the display, which
// may be modified with programs such as xset.
// 
// If -nice is not specified, this command also resets the screen saver
// for the screen.  Some screen savers will ignore this, but others will reset
// so that the screen becomes visible again.
func Bell(options ...option) {
	Inter.eval(fmt.Sprintf(`bell %s`, collect(options...)))
}

// button - Create and manipulate 'button' action widgets
// 
// # Button(Command(...))
// 
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
// 
// # Button(Default(...))
// 
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
// 
// # Button(Height(...))
// 
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Button(Overrelief(...))
// 
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
// 
// # Button(State(...))
// 
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
// 
// # Button(Width(...))
// 
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The button command creates a new window (given by the
// pathName argument) and makes it into a button widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the button such as its colors, font,
// text, and initial relief.  The button command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A button is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// It can display itself in either of three different ways, according
// to
// the -state option;
// it can be made to appear raised, sunken, or flat;
// and it can be made to flash.  When a user invokes the
// button (by pressing mouse button 1 with the cursor over the
// button), then the Tcl command specified in the -command
// option is invoked.
//
// The resulting Window is a child of 'w'.
func (w *Window) Button(options ...option) *Window {
	return w.newChild("button", options...)
}

// button - Create and manipulate 'button' action widgets
// 
// # Button(Command(...))
// 
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
// 
// # Button(Default(...))
// 
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
// 
// # Button(Height(...))
// 
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Button(Overrelief(...))
// 
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
// 
// # Button(State(...))
// 
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
// 
// # Button(Width(...))
// 
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The button command creates a new window (given by the
// pathName argument) and makes it into a button widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the button such as its colors, font,
// text, and initial relief.  The button command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A button is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// It can display itself in either of three different ways, according
// to
// the -state option;
// it can be made to appear raised, sunken, or flat;
// and it can be made to flash.  When a user invokes the
// button (by pressing mouse button 1 with the cursor over the
// button), then the Tcl command specified in the -command
// option is invoked.
func Button(options ...option) *Window {
	return Inter.Button(options...)
}

// canvas - Create and manipulate 'canvas' hypergraphics drawing surface widgets
// 
// # Canvas(Closeenough(...))
// 
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
// 
// # Canvas(Confine(...))
// 
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
// 
// # Canvas(Height(...))
// 
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
// 
// # Canvas(Scrollregion(...))
// 
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
// 
// # Canvas(State(...))
// 
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
// 
// # Canvas(Width(...))
// 
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
// 
// # Canvas(Xscrollincrement(...))
// 
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
// 
// # Canvas(Yscrollincrement(...))
// 
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
//
// The resulting Window is a child of 'w'.
func (w *Window) Canvas(options ...option) *Window {
	return w.newChild("canvas", options...)
}

// canvas - Create and manipulate 'canvas' hypergraphics drawing surface widgets
// 
// # Canvas(Closeenough(...))
// 
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
// 
// # Canvas(Confine(...))
// 
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
// 
// # Canvas(Height(...))
// 
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
// 
// # Canvas(Scrollregion(...))
// 
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
// 
// # Canvas(State(...))
// 
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
// 
// # Canvas(Width(...))
// 
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
// 
// # Canvas(Xscrollincrement(...))
// 
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
// 
// # Canvas(Yscrollincrement(...))
// 
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
func Canvas(options ...option) *Window {
	return Inter.Canvas(options...)
}

// checkbutton - Create and manipulate 'checkbutton' boolean selection widgets
// 
// # Checkbutton(Command(...))
// 
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
// 
// # Checkbutton(Height(...))
// 
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Checkbutton(Indicatoron(...))
// 
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
// 
// # Checkbutton(Offrelief(...))
// 
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
// 
// # Checkbutton(Offvalue(...))
// 
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
// 
// # Checkbutton(Onvalue(...))
// 
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
// 
// # Checkbutton(Overrelief(...))
// 
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
// 
// # Checkbutton(Selectcolor(...))
// 
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
// 
// # Checkbutton(Selectimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Checkbutton(State(...))
// 
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
// 
// # Checkbutton(Tristateimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Checkbutton(Tristatevalue(...))
// 
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
// 
// # Checkbutton(Variable(...))
// 
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
// 
// # Checkbutton(Width(...))
// 
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The checkbutton command creates a new window (given by the
// pathName argument) and makes it into a checkbutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the checkbutton such as its colors, font,
// text, and initial relief.  The checkbutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A checkbutton is a widget
// that displays a textual string, bitmap or image
// and a square called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// A checkbutton has
// all of the behavior of a simple button, including the
// following: it can display itself in either of three different
// ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// checkbutton.
// 
// In addition, checkbuttons can be selected.
// If a checkbutton is selected then the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the checkbutton is set to a particular
// value (normally 1).
// The indicator is drawn with a check mark inside.
// If the checkbutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a check mark inside.  In the special case
// where the variable (if specified) has a value that matches the tristatevalue,
// the indicator is drawn with a tri-state appearance and is in the tri-state
// mode indicating mixed or multiple values.  (This is used when the check
// box represents the state of multiple items.)
// The indicator is drawn in a platform dependent manner.  Under Unix and
// Windows, the background interior of the box is
// 
// Under Mac, the indicator is drawn with a dash mark inside.
// By default, the name of the variable associated with a checkbutton is the
// same as the name used to create the checkbutton.
// The variable name, and the
// 
// and
// 
// values stored in it, may be modified with options on the command line
// or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a checkbutton is configured to select and deselect
// itself on alternate button clicks.
// In addition, each checkbutton monitors its associated variable and
// automatically selects and deselects itself when the variables value
// changes to and from the button's
// 
// and
// 
// values.
//
// The resulting Window is a child of 'w'.
func (w *Window) Checkbutton(options ...option) *Window {
	return w.newChild("checkbutton", options...)
}

// checkbutton - Create and manipulate 'checkbutton' boolean selection widgets
// 
// # Checkbutton(Command(...))
// 
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
// 
// # Checkbutton(Height(...))
// 
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Checkbutton(Indicatoron(...))
// 
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
// 
// # Checkbutton(Offrelief(...))
// 
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
// 
// # Checkbutton(Offvalue(...))
// 
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
// 
// # Checkbutton(Onvalue(...))
// 
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
// 
// # Checkbutton(Overrelief(...))
// 
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
// 
// # Checkbutton(Selectcolor(...))
// 
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
// 
// # Checkbutton(Selectimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Checkbutton(State(...))
// 
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
// 
// # Checkbutton(Tristateimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Checkbutton(Tristatevalue(...))
// 
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
// 
// # Checkbutton(Variable(...))
// 
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
// 
// # Checkbutton(Width(...))
// 
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The checkbutton command creates a new window (given by the
// pathName argument) and makes it into a checkbutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the checkbutton such as its colors, font,
// text, and initial relief.  The checkbutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A checkbutton is a widget
// that displays a textual string, bitmap or image
// and a square called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// A checkbutton has
// all of the behavior of a simple button, including the
// following: it can display itself in either of three different
// ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// checkbutton.
// 
// In addition, checkbuttons can be selected.
// If a checkbutton is selected then the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the checkbutton is set to a particular
// value (normally 1).
// The indicator is drawn with a check mark inside.
// If the checkbutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a check mark inside.  In the special case
// where the variable (if specified) has a value that matches the tristatevalue,
// the indicator is drawn with a tri-state appearance and is in the tri-state
// mode indicating mixed or multiple values.  (This is used when the check
// box represents the state of multiple items.)
// The indicator is drawn in a platform dependent manner.  Under Unix and
// Windows, the background interior of the box is
// 
// Under Mac, the indicator is drawn with a dash mark inside.
// By default, the name of the variable associated with a checkbutton is the
// same as the name used to create the checkbutton.
// The variable name, and the
// 
// and
// 
// values stored in it, may be modified with options on the command line
// or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a checkbutton is configured to select and deselect
// itself on alternate button clicks.
// In addition, each checkbutton monitors its associated variable and
// automatically selects and deselects itself when the variables value
// changes to and from the button's
// 
// and
// 
// values.
func Checkbutton(options ...option) *Window {
	return Inter.Checkbutton(options...)
}

// destroy - Destroy one or more windows
// 
// This command deletes the windows given by the
// window arguments, plus all of their descendants.
// If a window
// 
// is deleted then all windows will be destroyed and the application will
// (normally) exit.
// The windows are destroyed in order, and if an error occurs
// in destroying a window the command aborts without destroying the
// remaining windows.
// No error is returned if window does not exist.
func Destroy(options ...option) {
	Inter.eval(fmt.Sprintf(`destroy %s`, collect(options...)))
}

// entry - Create and manipulate 'entry' one-line text entry widgets
// 
// # Entry(Disabledbackground(...))
// 
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
// 
// # Entry(Disabledforeground(...))
// 
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
// 
// # Entry(Invalidcommand(...)) or Entry(Invcmd(...))
// 
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
// 
// # Entry(Readonlybackground(...))
// 
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
// 
// # Entry(Show(...))
// 
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
// 
// # Entry(State(...))
// 
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
// 
// # Entry(Validate(...))
// 
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
// 
// # Entry(Validatecommand(...)) or Entry(Vcmd(...))
// 
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
// 
// # Entry(Width(...))
// 
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
// 
// # Description
// 
// The entry command creates a new window (given by the
// pathName argument) and makes it into an entry widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the entry such as its colors, font,
// and relief.  The entry command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// An entry is a widget that displays a one-line text string and
// allows that string to be edited using widget commands described below, which
// are typically bound to keystrokes and mouse actions.
// When first created, an entry's string is empty.
// A portion of the entry may be selected as described below.
// If an entry is exporting its selection (see the -exportselection
// option), then it will observe the standard X11 protocols for handling the
// selection;  entry selections are available as type STRING.
// Entries also observe the standard Tk rules for dealing with the
// input focus.  When an entry has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
// 
// Entries are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed;  commands described below
// may be used to change the view in the window.  Entries use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
//
// The resulting Window is a child of 'w'.
func (w *Window) Entry(options ...option) *Window {
	return w.newChild("entry", options...)
}

// entry - Create and manipulate 'entry' one-line text entry widgets
// 
// # Entry(Disabledbackground(...))
// 
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
// 
// # Entry(Disabledforeground(...))
// 
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
// 
// # Entry(Invalidcommand(...)) or Entry(Invcmd(...))
// 
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
// 
// # Entry(Readonlybackground(...))
// 
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
// 
// # Entry(Show(...))
// 
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
// 
// # Entry(State(...))
// 
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
// 
// # Entry(Validate(...))
// 
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
// 
// # Entry(Validatecommand(...)) or Entry(Vcmd(...))
// 
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
// 
// # Entry(Width(...))
// 
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
// 
// # Description
// 
// The entry command creates a new window (given by the
// pathName argument) and makes it into an entry widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the entry such as its colors, font,
// and relief.  The entry command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// An entry is a widget that displays a one-line text string and
// allows that string to be edited using widget commands described below, which
// are typically bound to keystrokes and mouse actions.
// When first created, an entry's string is empty.
// A portion of the entry may be selected as described below.
// If an entry is exporting its selection (see the -exportselection
// option), then it will observe the standard X11 protocols for handling the
// selection;  entry selections are available as type STRING.
// Entries also observe the standard Tk rules for dealing with the
// input focus.  When an entry has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
// 
// Entries are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed;  commands described below
// may be used to change the view in the window.  Entries use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
func Entry(options ...option) *Window {
	return Inter.Entry(options...)
}

// frame - Create and manipulate 'frame' simple container widgets
// 
// # Frame(Background(...))
// 
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
// 
// # Frame(Backgroundimage(...))
// 
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
// 
// # Frame(Class(...))
// 
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
// 
// # Frame(Colormap(...))
// 
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Frame(Container(...))
// 
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
// 
// # Frame(Height(...))
// 
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
// 
// # Frame(Tile(...))
// 
//  "8.7, TIP262"
// 
// # Frame(Visual(...))
// 
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
// 
// # Frame(Width(...))
// 
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
// 
// # Description
// 
// The frame command creates a new window (given by the
// pathName argument) and makes it into a frame widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the frame such as its background color
// and relief.  The frame command returns the
// path name of the new window.
// 
// A frame is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  The only features
// of a frame are its background and an optional 3-D border to make the
// frame appear raised or sunken.
//
// The resulting Window is a child of 'w'.
func (w *Window) Frame(options ...option) *Window {
	return w.newChild("frame", options...)
}

// frame - Create and manipulate 'frame' simple container widgets
// 
// # Frame(Background(...))
// 
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
// 
// # Frame(Backgroundimage(...))
// 
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
// 
// # Frame(Class(...))
// 
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
// 
// # Frame(Colormap(...))
// 
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Frame(Container(...))
// 
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
// 
// # Frame(Height(...))
// 
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
// 
// # Frame(Tile(...))
// 
//  "8.7, TIP262"
// 
// # Frame(Visual(...))
// 
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
// 
// # Frame(Width(...))
// 
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
// 
// # Description
// 
// The frame command creates a new window (given by the
// pathName argument) and makes it into a frame widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the frame such as its background color
// and relief.  The frame command returns the
// path name of the new window.
// 
// A frame is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  The only features
// of a frame are its background and an optional 3-D border to make the
// frame appear raised or sunken.
func Frame(options ...option) *Window {
	return Inter.Frame(options...)
}

// label - Create and manipulate 'label' non-interactive text or image widgets
// 
// # Label(Height(...))
// 
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Label(State(...))
// 
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
// 
// # Label(Width(...))
// 
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The label command creates a new window (given by the
// pathName argument) and makes it into a label widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the label such as its colors, font,
// text, and initial relief.  The label command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A label is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// The label can be manipulated in a few simple ways, such as
// changing its relief or text, using the commands described below.
//
// The resulting Window is a child of 'w'.
func (w *Window) Label(options ...option) *Window {
	return w.newChild("label", options...)
}

// label - Create and manipulate 'label' non-interactive text or image widgets
// 
// # Label(Height(...))
// 
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Label(State(...))
// 
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
// 
// # Label(Width(...))
// 
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The label command creates a new window (given by the
// pathName argument) and makes it into a label widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the label such as its colors, font,
// text, and initial relief.  The label command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A label is a widget that displays a textual string, bitmap or image.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.
// The label can be manipulated in a few simple ways, such as
// changing its relief or text, using the commands described below.
func Label(options ...option) *Window {
	return Inter.Label(options...)
}

// labelframe - Create and manipulate 'labelframe' labelled container widgets
// 
// # Labelframe(Background(...))
// 
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
// 
// # Labelframe(Class(...))
// 
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
// 
// # Labelframe(Colormap(...))
// 
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Labelframe(Height(...))
// 
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Labelframe(Labelanchor(...))
// 
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
// 
// # Labelframe(Labelwidget(...))
// 
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
// 
// # Labelframe(Visual(...))
// 
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
// 
// # Labelframe(Width(...))
// 
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Description
// 
// The labelframe command creates a new window (given by the
// pathName argument) and makes it into a labelframe widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the labelframe such as its background color
// and relief.  The labelframe command returns the
// path name of the new window.
// 
// A labelframe is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  It has the features
// of a frame plus the ability to display a label.
//
// The resulting Window is a child of 'w'.
func (w *Window) Labelframe(options ...option) *Window {
	return w.newChild("labelframe", options...)
}

// labelframe - Create and manipulate 'labelframe' labelled container widgets
// 
// # Labelframe(Background(...))
// 
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
// 
// # Labelframe(Class(...))
// 
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
// 
// # Labelframe(Colormap(...))
// 
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Labelframe(Height(...))
// 
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Labelframe(Labelanchor(...))
// 
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
// 
// # Labelframe(Labelwidget(...))
// 
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
// 
// # Labelframe(Visual(...))
// 
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
// 
// # Labelframe(Width(...))
// 
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Description
// 
// The labelframe command creates a new window (given by the
// pathName argument) and makes it into a labelframe widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the labelframe such as its background color
// and relief.  The labelframe command returns the
// path name of the new window.
// 
// A labelframe is a simple widget.  Its primary purpose is to act as a
// spacer or container for complex window layouts.  It has the features
// of a frame plus the ability to display a label.
func Labelframe(options ...option) *Window {
	return Inter.Labelframe(options...)
}

// listbox - Create and manipulate 'listbox' item list widgets
// 
// # Listbox(Activestyle(...))
// 
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
// 
// # Listbox(Height(...))
// 
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
// 
// # Listbox(Listvariable(...))
// 
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
// 
// # Listbox(Selectmode(...))
// 
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
// 
// # Listbox(State(...))
// 
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
// 
// # Listbox(Width(...))
// 
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
// 
// # Description
// 
// The listbox command creates a new window (given by the
// pathName argument) and makes it into a listbox widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the listbox such as its colors, font,
// text, and relief.  The listbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A listbox is a widget that displays a list of strings, one per line.
// When first created, a new listbox has no elements.
// Elements may be added or deleted using widget commands described
// below.  In addition, one or more elements may be selected as described
// below.
// If a listbox is exporting its selection (see -exportselection
// option), then it will observe the standard X11 protocols
// for handling the selection.
// Listbox selections are available as type STRING;
// the value of the selection will be the text of the selected elements, with
// newlines separating the elements.
// 
// It is not necessary for all the elements to be
// displayed in the listbox window at once;  commands described below
// may be used to change the view in the window.  Listboxes allow
// scrolling in both directions using the standard -xscrollcommand
// and -yscrollcommand options.
// They also support scanning, as described below.
//
// The resulting Window is a child of 'w'.
func (w *Window) Listbox(options ...option) *Window {
	return w.newChild("listbox", options...)
}

// listbox - Create and manipulate 'listbox' item list widgets
// 
// # Listbox(Activestyle(...))
// 
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
// 
// # Listbox(Height(...))
// 
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
// 
// # Listbox(Listvariable(...))
// 
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
// 
// # Listbox(Selectmode(...))
// 
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
// 
// # Listbox(State(...))
// 
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
// 
// # Listbox(Width(...))
// 
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
// 
// # Description
// 
// The listbox command creates a new window (given by the
// pathName argument) and makes it into a listbox widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the listbox such as its colors, font,
// text, and relief.  The listbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A listbox is a widget that displays a list of strings, one per line.
// When first created, a new listbox has no elements.
// Elements may be added or deleted using widget commands described
// below.  In addition, one or more elements may be selected as described
// below.
// If a listbox is exporting its selection (see -exportselection
// option), then it will observe the standard X11 protocols
// for handling the selection.
// Listbox selections are available as type STRING;
// the value of the selection will be the text of the selected elements, with
// newlines separating the elements.
// 
// It is not necessary for all the elements to be
// displayed in the listbox window at once;  commands described below
// may be used to change the view in the window.  Listboxes allow
// scrolling in both directions using the standard -xscrollcommand
// and -yscrollcommand options.
// They also support scanning, as described below.
func Listbox(options ...option) *Window {
	return Inter.Listbox(options...)
}

// menu, tk_menuSetFocus - Create and manipulate 'menu' widgets and menubars
// 
// # Menu(Postcommand(...))
// 
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
// 
// # Menu(Selectcolor(...))
// 
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
// 
// # Menu(Tearoff(...))
// 
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
// 
// # Menu(Tearoffcommand(...))
// 
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
// 
// # Menu(Title(...))
// 
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
// 
// # Menu(Type(...))
// 
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
//
// The resulting Window is a child of 'w'.
func (w *Window) Menu(options ...option) *Window {
	return w.newChild("menu", options...)
}

// menu, tk_menuSetFocus - Create and manipulate 'menu' widgets and menubars
// 
// # Menu(Postcommand(...))
// 
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
// 
// # Menu(Selectcolor(...))
// 
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
// 
// # Menu(Tearoff(...))
// 
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
// 
// # Menu(Tearoffcommand(...))
// 
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
// 
// # Menu(Title(...))
// 
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
// 
// # Menu(Type(...))
// 
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
func Menu(options ...option) *Window {
	return Inter.Menu(options...)
}

// menubutton - Create and manipulate 'menubutton' pop-up menu indicator widgets
// 
// # Menubutton(Direction(...))
// 
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
// 
// # Menubutton(Height(...))
// 
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Menubutton(Indicatoron(...))
// 
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
// 
// # Menubutton(Menu(...))
// 
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
// 
// # Menubutton(State(...))
// 
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
// 
// # Menubutton(Width(...))
// 
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// The resulting Window is a child of 'w'.
func (w *Window) Menubutton(options ...option) *Window {
	return w.newChild("menubutton", options...)
}

// menubutton - Create and manipulate 'menubutton' pop-up menu indicator widgets
// 
// # Menubutton(Direction(...))
// 
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
// 
// # Menubutton(Height(...))
// 
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Menubutton(Indicatoron(...))
// 
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
// 
// # Menubutton(Menu(...))
// 
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
// 
// # Menubutton(State(...))
// 
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
// 
// # Menubutton(Width(...))
// 
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
func Menubutton(options ...option) *Window {
	return Inter.Menubutton(options...)
}

// message - Create and manipulate 'message' non-interactive text widgets
// 
// # Message(Aspect(...))
// 
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
// 
// # Message(Justify(...))
// 
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
// 
// # Message(Width(...))
// 
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
// 
// # Description
// 
// The message command creates a new window (given by the
// pathName argument) and makes it into a message widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the message such as its colors, font,
// text, and initial relief.  The message command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A message is a widget that displays a textual string.  A message
// widget has three special features that differentiate it from a
// label widget.  First, it breaks up
// its string into lines in order to produce a given aspect ratio
// for the window.  The line breaks are chosen at word boundaries
// wherever possible (if not even a single word would fit on a
// line, then the word will be split across lines).  Newline characters
// in the string will force line breaks;  they can be used, for example,
// to leave blank lines in the display.
// 
// The second feature of a message widget is justification.  The text
// may be displayed left-justified (each line starts at the left side of
// the window), centered on a line-by-line basis, or right-justified
// (each line ends at the right side of the window).
// 
// The third feature of a message widget is that it handles control
// characters and non-printing characters specially.  Tab characters
// are replaced with enough blank space to line up on the next
// 8-character boundary.  Newlines cause line breaks.  Other control
// characters (ASCII code less than 0x20) and characters not defined
// in the font are displayed as a four-character sequence \exhh where
// hh is the two-digit hexadecimal number corresponding to
// the character.  In the unusual case where the font does not contain
// all of the characters in
// 
// then control characters and undefined characters are not displayed at all.
//
// The resulting Window is a child of 'w'.
func (w *Window) Message(options ...option) *Window {
	return w.newChild("message", options...)
}

// message - Create and manipulate 'message' non-interactive text widgets
// 
// # Message(Aspect(...))
// 
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
// 
// # Message(Justify(...))
// 
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
// 
// # Message(Width(...))
// 
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
// 
// # Description
// 
// The message command creates a new window (given by the
// pathName argument) and makes it into a message widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the message such as its colors, font,
// text, and initial relief.  The message command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A message is a widget that displays a textual string.  A message
// widget has three special features that differentiate it from a
// label widget.  First, it breaks up
// its string into lines in order to produce a given aspect ratio
// for the window.  The line breaks are chosen at word boundaries
// wherever possible (if not even a single word would fit on a
// line, then the word will be split across lines).  Newline characters
// in the string will force line breaks;  they can be used, for example,
// to leave blank lines in the display.
// 
// The second feature of a message widget is justification.  The text
// may be displayed left-justified (each line starts at the left side of
// the window), centered on a line-by-line basis, or right-justified
// (each line ends at the right side of the window).
// 
// The third feature of a message widget is that it handles control
// characters and non-printing characters specially.  Tab characters
// are replaced with enough blank space to line up on the next
// 8-character boundary.  Newlines cause line breaks.  Other control
// characters (ASCII code less than 0x20) and characters not defined
// in the font are displayed as a four-character sequence \exhh where
// hh is the two-digit hexadecimal number corresponding to
// the character.  In the unusual case where the font does not contain
// all of the characters in
// 
// then control characters and undefined characters are not displayed at all.
func Message(options ...option) *Window {
	return Inter.Message(options...)
}

// tk_optionMenu - Create an option menubutton and its menu
// 
// This procedure creates an option menubutton whose name is pathName,
// plus an associated menu.
// Together they allow the user to select one of the values
// given by the value arguments.
// The current value will be stored in the global variable whose
// name is given by varName and it will also be displayed as the label
// in the option menubutton.
// The user can click on the menubutton to display a menu containing
// all of the values and thereby select a new value.
// Once a new value is selected, it will be stored in the variable
// and appear in the option menubutton.
// The current value can also be changed by setting the variable.
// 
// The return value from tk_optionMenu is the name of the menu
// associated with pathName, so that the caller can change its
// configuration options or manipulate it in other ways.
//
// The resulting Window is a child of 'w'.
func (w *Window) OptionMenu(options ...option) *Window {
	return w.newChild("optionMenu", options...)
}

// tk_optionMenu - Create an option menubutton and its menu
// 
// This procedure creates an option menubutton whose name is pathName,
// plus an associated menu.
// Together they allow the user to select one of the values
// given by the value arguments.
// The current value will be stored in the global variable whose
// name is given by varName and it will also be displayed as the label
// in the option menubutton.
// The user can click on the menubutton to display a menu containing
// all of the values and thereby select a new value.
// Once a new value is selected, it will be stored in the variable
// and appear in the option menubutton.
// The current value can also be changed by setting the variable.
// 
// The return value from tk_optionMenu is the name of the menu
// associated with pathName, so that the caller can change its
// configuration options or manipulate it in other ways.
func OptionMenu(options ...option) *Window {
	return Inter.OptionMenu(options...)
}

// panedwindow - Create and manipulate 'panedwindow' split container widgets
// 
// # Panedwindow(Handlepad(...))
// 
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
// 
// # Panedwindow(Handlesize(...))
// 
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
// 
// # Panedwindow(Height(...))
// 
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
// 
// # Panedwindow(Opaqueresize(...))
// 
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
// 
// # Panedwindow(Proxybackground(...))
// 
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
// 
// # Panedwindow(Proxyborderwidth(...))
// 
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
// 
// # Panedwindow(Proxyrelief(...))
// 
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
// 
// # Panedwindow(Sashcursor(...))
// 
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
// 
// # Panedwindow(Sashpad(...))
// 
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
// 
// # Panedwindow(Sashrelief(...))
// 
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
// 
// # Panedwindow(Sashwidth(...))
// 
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
// 
// # Panedwindow(Showhandle(...))
// 
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
// 
// # Panedwindow(Width(...))
// 
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
// 
// # Description
// 
// The panedwindow command creates a new window (given by the
// pathName argument) and makes it into a panedwindow widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the panedwindow
// such as its default background color and relief.  The
// panedwindow command returns the path name of the new window.
// 
// A panedwindow widget contains any number of panes, arranged
// horizontally or vertically, according to the value of the
// -orient option.  Each pane contains one widget, and each pair of
// panes is separated by a moveable (via mouse movements) sash.  Moving a
// sash causes the widgets on either side of the sash to be resized.
//
// The resulting Window is a child of 'w'.
func (w *Window) Panedwindow(options ...option) *Window {
	return w.newChild("panedwindow", options...)
}

// panedwindow - Create and manipulate 'panedwindow' split container widgets
// 
// # Panedwindow(Handlepad(...))
// 
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
// 
// # Panedwindow(Handlesize(...))
// 
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
// 
// # Panedwindow(Height(...))
// 
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
// 
// # Panedwindow(Opaqueresize(...))
// 
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
// 
// # Panedwindow(Proxybackground(...))
// 
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
// 
// # Panedwindow(Proxyborderwidth(...))
// 
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
// 
// # Panedwindow(Proxyrelief(...))
// 
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
// 
// # Panedwindow(Sashcursor(...))
// 
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
// 
// # Panedwindow(Sashpad(...))
// 
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
// 
// # Panedwindow(Sashrelief(...))
// 
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
// 
// # Panedwindow(Sashwidth(...))
// 
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
// 
// # Panedwindow(Showhandle(...))
// 
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
// 
// # Panedwindow(Width(...))
// 
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
// 
// # Description
// 
// The panedwindow command creates a new window (given by the
// pathName argument) and makes it into a panedwindow widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the panedwindow
// such as its default background color and relief.  The
// panedwindow command returns the path name of the new window.
// 
// A panedwindow widget contains any number of panes, arranged
// horizontally or vertically, according to the value of the
// -orient option.  Each pane contains one widget, and each pair of
// panes is separated by a moveable (via mouse movements) sash.  Moving a
// sash causes the widgets on either side of the sash to be resized.
func Panedwindow(options ...option) *Window {
	return Inter.Panedwindow(options...)
}

// radiobutton - Create and manipulate 'radiobutton' pick-one widgets
// 
// # Radiobutton(Command(...))
// 
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
// 
// # Radiobutton(Height(...))
// 
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Radiobutton(Indicatoron(...))
// 
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
// 
// # Radiobutton(Offrelief(...))
// 
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
// 
// # Radiobutton(Overrelief(...))
// 
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
// 
// # Radiobutton(Selectcolor(...))
// 
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
// 
// # Radiobutton(Selectimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Radiobutton(State(...))
// 
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
// 
// # Radiobutton(Tristateimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Radiobutton(Tristatevalue(...))
// 
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
// 
// # Radiobutton(Value(...))
// 
// Specifies value to store in the button's associated variable whenever
// this button is selected.
// 
// # Radiobutton(Variable(...))
// 
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
// 
// # Radiobutton(Width(...))
// 
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The radiobutton command creates a new window (given by the
// pathName argument) and makes it into a radiobutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the radiobutton such as its colors, font,
// text, and initial relief.  The radiobutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A radiobutton is a widget that displays a textual string, bitmap or image
// and a diamond or circle called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.  A radiobutton has
// all of the behavior of a simple button: it can display itself in either
// of three different ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// check button.
// 
// In addition, radiobuttons can be selected.
// If a radiobutton is selected, the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the radiobutton is set to a particular
// value (normally 1).
// Under Unix, the indicator is drawn with a sunken relief and a special
// color.  Under Windows, the indicator is drawn with a round mark inside.
// If the radiobutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a round mark inside.
// Typically, several radiobuttons share a single variable and the
// value of the variable indicates which radiobutton is to be selected.
// When a radiobutton is selected it sets the value of the variable to
// indicate that fact;  each radiobutton also monitors the value of
// the variable and automatically selects and deselects itself when the
// variable's value changes.
// If the variable's value matches the -tristatevalue, then the radiobutton
// is drawn using the tri-state mode.  This mode is used to indicate mixed or
// multiple values.  (This is used when the radiobutton represents the state
// of multiple items.)
// By default the variable selectedButton
// is used;  its contents give the name of the button that is
// selected, or the empty string if no button associated with that
// variable is selected.
// The name of the variable for a radiobutton,
// plus the variable to be stored into it, may be modified with options
// on the command line or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a radiobutton is configured to select itself on button clicks.
//
// The resulting Window is a child of 'w'.
func (w *Window) Radiobutton(options ...option) *Window {
	return w.newChild("radiobutton", options...)
}

// radiobutton - Create and manipulate 'radiobutton' pick-one widgets
// 
// # Radiobutton(Command(...))
// 
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
// 
// # Radiobutton(Height(...))
// 
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Radiobutton(Indicatoron(...))
// 
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
// 
// # Radiobutton(Offrelief(...))
// 
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
// 
// # Radiobutton(Overrelief(...))
// 
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
// 
// # Radiobutton(Selectcolor(...))
// 
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
// 
// # Radiobutton(Selectimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Radiobutton(State(...))
// 
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
// 
// # Radiobutton(Tristateimage(...))
// 
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
// 
// # Radiobutton(Tristatevalue(...))
// 
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
// 
// # Radiobutton(Value(...))
// 
// Specifies value to store in the button's associated variable whenever
// this button is selected.
// 
// # Radiobutton(Variable(...))
// 
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
// 
// # Radiobutton(Width(...))
// 
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
// 
// # Description
// 
// The radiobutton command creates a new window (given by the
// pathName argument) and makes it into a radiobutton widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the radiobutton such as its colors, font,
// text, and initial relief.  The radiobutton command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A radiobutton is a widget that displays a textual string, bitmap or image
// and a diamond or circle called an indicator.
// If text is displayed, it must all be in a single font, but it
// can occupy multiple lines on the screen (if it contains newlines
// or if wrapping occurs because of the -wraplength option) and
// one of the characters may optionally be underlined using the
// -underline option.  A radiobutton has
// all of the behavior of a simple button: it can display itself in either
// of three different ways, according to the -state option;
// it can be made to appear
// raised, sunken, or flat; it can be made to flash; and it invokes
// a Tcl command whenever mouse button 1 is clicked over the
// check button.
// 
// In addition, radiobuttons can be selected.
// If a radiobutton is selected, the indicator is normally
// drawn with a selected appearance, and
// a Tcl variable associated with the radiobutton is set to a particular
// value (normally 1).
// Under Unix, the indicator is drawn with a sunken relief and a special
// color.  Under Windows, the indicator is drawn with a round mark inside.
// If the radiobutton is not selected, then the indicator is drawn with a
// deselected appearance, and the associated variable is
// set to a different value (typically 0).
// The indicator is drawn without a round mark inside.
// Typically, several radiobuttons share a single variable and the
// value of the variable indicates which radiobutton is to be selected.
// When a radiobutton is selected it sets the value of the variable to
// indicate that fact;  each radiobutton also monitors the value of
// the variable and automatically selects and deselects itself when the
// variable's value changes.
// If the variable's value matches the -tristatevalue, then the radiobutton
// is drawn using the tri-state mode.  This mode is used to indicate mixed or
// multiple values.  (This is used when the radiobutton represents the state
// of multiple items.)
// By default the variable selectedButton
// is used;  its contents give the name of the button that is
// selected, or the empty string if no button associated with that
// variable is selected.
// The name of the variable for a radiobutton,
// plus the variable to be stored into it, may be modified with options
// on the command line or in the option database.
// Configuration options may also be used to modify the way the
// indicator is displayed (or whether it is displayed at all).
// By default a radiobutton is configured to select itself on button clicks.
func Radiobutton(options ...option) *Window {
	return Inter.Radiobutton(options...)
}

// scale - Create and manipulate 'scale' value-controlled slider widgets
// 
// # Scale(Bigincrement(...))
// 
// Some interactions with the scale cause its value to change by
// 
// # Scale(Command(...))
// 
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
// 
// # Scale(Digits(...))
// 
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
// 
// # Scale(From(...))
// 
// A real value corresponding to the left or top end of the scale.
// 
// # Scale(Label(...))
// 
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
// 
// # Scale(Length(...))
// 
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
// 
// # Scale(Resolution(...))
// 
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
// 
// # Scale(Showvalue(...))
// 
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
// 
// # Scale(Sliderlength(...))
// 
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
// 
// # Scale(Sliderrelief(...))
// 
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
// 
// # Scale(State(...))
// 
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
// 
// # Scale(Tickinterval(...))
// 
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
// 
// # Scale(To(...))
// 
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
// 
// # Scale(Variable(...))
// 
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
// 
// # Scale(Width(...))
// 
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
// 
// # Description
// 
// The scale command creates a new window (given by the
// pathName argument) and makes it into a scale widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the scale such as its colors, orientation,
// and relief.  The scale command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A scale is a widget that displays a rectangular trough and a
// small slider.  The trough corresponds to a range
// of real values (determined by the -from, -to, and
// -resolution options),
// and the position of the slider selects a particular real value.
// The slider's position (and hence the scale's value) may be adjusted
// with the mouse or keyboard as described in the BINDINGS
// section below.  Whenever the scale's value is changed, a Tcl
// command is invoked (using the -command option) to notify
// other interested widgets of the change.
// In addition, the value
// of the scale can be linked to a Tcl variable (using the -variable
// option), so that changes in either are reflected in the other.
// 
// Three annotations may be displayed in a scale widget:  a label
// appearing at the top right of the widget (top left for horizontal
// scales), a number displayed just to the left of the slider
// (just above the slider for horizontal scales), and a collection
// of numerical tick marks just to the left of the current value
// (just below the trough for horizontal scales).  Each of these three
// annotations may be enabled or disabled using the
// configuration options.
//
// The resulting Window is a child of 'w'.
func (w *Window) Scale(options ...option) *Window {
	return w.newChild("scale", options...)
}

// scale - Create and manipulate 'scale' value-controlled slider widgets
// 
// # Scale(Bigincrement(...))
// 
// Some interactions with the scale cause its value to change by
// 
// # Scale(Command(...))
// 
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
// 
// # Scale(Digits(...))
// 
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
// 
// # Scale(From(...))
// 
// A real value corresponding to the left or top end of the scale.
// 
// # Scale(Label(...))
// 
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
// 
// # Scale(Length(...))
// 
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
// 
// # Scale(Resolution(...))
// 
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
// 
// # Scale(Showvalue(...))
// 
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
// 
// # Scale(Sliderlength(...))
// 
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
// 
// # Scale(Sliderrelief(...))
// 
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
// 
// # Scale(State(...))
// 
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
// 
// # Scale(Tickinterval(...))
// 
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
// 
// # Scale(To(...))
// 
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
// 
// # Scale(Variable(...))
// 
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
// 
// # Scale(Width(...))
// 
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
// 
// # Description
// 
// The scale command creates a new window (given by the
// pathName argument) and makes it into a scale widget.
// Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the scale such as its colors, orientation,
// and relief.  The scale command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A scale is a widget that displays a rectangular trough and a
// small slider.  The trough corresponds to a range
// of real values (determined by the -from, -to, and
// -resolution options),
// and the position of the slider selects a particular real value.
// The slider's position (and hence the scale's value) may be adjusted
// with the mouse or keyboard as described in the BINDINGS
// section below.  Whenever the scale's value is changed, a Tcl
// command is invoked (using the -command option) to notify
// other interested widgets of the change.
// In addition, the value
// of the scale can be linked to a Tcl variable (using the -variable
// option), so that changes in either are reflected in the other.
// 
// Three annotations may be displayed in a scale widget:  a label
// appearing at the top right of the widget (top left for horizontal
// scales), a number displayed just to the left of the slider
// (just above the slider for horizontal scales), and a collection
// of numerical tick marks just to the left of the current value
// (just below the trough for horizontal scales).  Each of these three
// annotations may be enabled or disabled using the
// configuration options.
func Scale(options ...option) *Window {
	return Inter.Scale(options...)
}

// scrollbar - Create and manipulate 'scrollbar' scrolling control and indicator widgets
// 
// # Scrollbar(Activerelief(...))
// 
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
// 
// # Scrollbar(Command(...))
// 
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
// 
// # Scrollbar(Elementborderwidth(...))
// 
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
// 
// # Scrollbar(Width(...))
// 
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// 
// # Description
// 
// The scrollbar command creates a new window (given by the
// pathName argument) and makes it into a scrollbar widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the scrollbar
// such as its colors, orientation, and relief.
// The scrollbar command returns its pathName argument.
// At the time this command is invoked, there must not exist a window
// named pathName, but pathName's parent must exist.
// 
// A scrollbar is a widget that displays two arrows, one at each end of
// the scrollbar, and a slider in the middle portion of the
// scrollbar.
// It provides information about what is visible in an associated window
// that displays a document of some sort (such as a file being edited or
// a drawing).
// The position and size of the slider indicate which portion of the
// document is visible in the associated window.  For example, if the
// slider in a vertical scrollbar covers the top third of the area
// between the two arrows, it means that the associated window displays
// the top third of its document.
// 
// Scrollbars can be used to adjust the view in the associated window
// by clicking or dragging with the mouse.  See the BINDINGS section
// below for details.
//
// The resulting Window is a child of 'w'.
func (w *Window) Scrollbar(options ...option) *Window {
	return w.newChild("scrollbar", options...)
}

// scrollbar - Create and manipulate 'scrollbar' scrolling control and indicator widgets
// 
// # Scrollbar(Activerelief(...))
// 
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
// 
// # Scrollbar(Command(...))
// 
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
// 
// # Scrollbar(Elementborderwidth(...))
// 
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
// 
// # Scrollbar(Width(...))
// 
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// 
// # Description
// 
// The scrollbar command creates a new window (given by the
// pathName argument) and makes it into a scrollbar widget.
// Additional options, described above, may be specified on the command
// line or in the option database to configure aspects of the scrollbar
// such as its colors, orientation, and relief.
// The scrollbar command returns its pathName argument.
// At the time this command is invoked, there must not exist a window
// named pathName, but pathName's parent must exist.
// 
// A scrollbar is a widget that displays two arrows, one at each end of
// the scrollbar, and a slider in the middle portion of the
// scrollbar.
// It provides information about what is visible in an associated window
// that displays a document of some sort (such as a file being edited or
// a drawing).
// The position and size of the slider indicate which portion of the
// document is visible in the associated window.  For example, if the
// slider in a vertical scrollbar covers the top third of the area
// between the two arrows, it means that the associated window displays
// the top third of its document.
// 
// Scrollbars can be used to adjust the view in the associated window
// by clicking or dragging with the mouse.  See the BINDINGS section
// below for details.
func Scrollbar(options ...option) *Window {
	return Inter.Scrollbar(options...)
}

// spinbox - Create and manipulate 'spinbox' value spinner widgets
// 
// # Spinbox(Buttonbackground(...))
// 
// The background color to be used for the spin buttons.
// 
// # Spinbox(Buttoncursor(...))
// 
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
// 
// # Spinbox(Buttondownrelief(...))
// 
// The relief to be used for the upper spin button.
// 
// # Spinbox(Buttonuprelief(...))
// 
// The relief to be used for the lower spin button.
// 
// # Spinbox(Command(...))
// 
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
// 
// # Spinbox(Disabledbackground(...))
// 
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
// 
// # Spinbox(Disabledforeground(...))
// 
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
// 
// # Spinbox(Format(...))
// 
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
// 
// # Spinbox(From(...))
// 
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
// 
// # Spinbox(Invalidcommand(...)) or Spinbox(Invcmd(...))
// 
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
// 
// # Spinbox(Increment(...))
// 
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
// 
// # Spinbox(Readonlybackground(...))
// 
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
// 
// # Spinbox(State(...))
// 
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
// 
// # Spinbox(To(...))
// 
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
// 
// # Spinbox(Validate(...))
// 
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
// 
// # Spinbox(Validatecommand(...)) or Spinbox(Vcmd(...))
// 
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
// 
// # Spinbox(Values(...))
// 
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
// 
// # Spinbox(Width(...))
// 
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
// 
// # Spinbox(Wrap(...))
// 
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
// 
// # Description
// 
// The spinbox command creates a new window (given by the
// pathName argument) and makes it into a spinbox widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the spinbox such as its colors, font,
// and relief.  The spinbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A spinbox is an extended entry widget that allows he user
// to move, or spin, through a fixed set of ascending or descending values
// such as times or dates in addition to editing the value as in an
// entry.  When first created, a spinbox's string is empty.
// A portion of the spinbox may be selected as described below.
// If a spinbox is exporting its selection (see the -exportselection
// option), then it will observe the standard protocols for handling the
// selection;  spinbox selections are available as type STRING.
// Spinboxes also observe the standard Tk rules for dealing with the
// input focus.  When a spinbox has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
// 
// Spinboxes are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed; commands described below
// may be used to change the view in the window.  Spinboxes use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
//
// The resulting Window is a child of 'w'.
func (w *Window) Spinbox(options ...option) *Window {
	return w.newChild("spinbox", options...)
}

// spinbox - Create and manipulate 'spinbox' value spinner widgets
// 
// # Spinbox(Buttonbackground(...))
// 
// The background color to be used for the spin buttons.
// 
// # Spinbox(Buttoncursor(...))
// 
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
// 
// # Spinbox(Buttondownrelief(...))
// 
// The relief to be used for the upper spin button.
// 
// # Spinbox(Buttonuprelief(...))
// 
// The relief to be used for the lower spin button.
// 
// # Spinbox(Command(...))
// 
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
// 
// # Spinbox(Disabledbackground(...))
// 
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
// 
// # Spinbox(Disabledforeground(...))
// 
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
// 
// # Spinbox(Format(...))
// 
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
// 
// # Spinbox(From(...))
// 
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
// 
// # Spinbox(Invalidcommand(...)) or Spinbox(Invcmd(...))
// 
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
// 
// # Spinbox(Increment(...))
// 
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
// 
// # Spinbox(Readonlybackground(...))
// 
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
// 
// # Spinbox(State(...))
// 
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
// 
// # Spinbox(To(...))
// 
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
// 
// # Spinbox(Validate(...))
// 
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
// 
// # Spinbox(Validatecommand(...)) or Spinbox(Vcmd(...))
// 
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
// 
// # Spinbox(Values(...))
// 
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
// 
// # Spinbox(Width(...))
// 
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
// 
// # Spinbox(Wrap(...))
// 
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
// 
// # Description
// 
// The spinbox command creates a new window (given by the
// pathName argument) and makes it into a spinbox widget.
// Additional options, described above, may be specified on the
// command line or in the option database
// to configure aspects of the spinbox such as its colors, font,
// and relief.  The spinbox command returns its
// pathName argument.  At the time this command is invoked,
// there must not exist a window named pathName, but
// pathName's parent must exist.
// 
// A spinbox is an extended entry widget that allows he user
// to move, or spin, through a fixed set of ascending or descending values
// such as times or dates in addition to editing the value as in an
// entry.  When first created, a spinbox's string is empty.
// A portion of the spinbox may be selected as described below.
// If a spinbox is exporting its selection (see the -exportselection
// option), then it will observe the standard protocols for handling the
// selection;  spinbox selections are available as type STRING.
// Spinboxes also observe the standard Tk rules for dealing with the
// input focus.  When a spinbox has the input focus it displays an
// insertion cursor to indicate where new characters will be
// inserted.
// 
// Spinboxes are capable of displaying strings that are too long to
// fit entirely within the widget's window.  In this case, only a
// portion of the string will be displayed; commands described below
// may be used to change the view in the window.  Spinboxes use
// the standard -xscrollcommand mechanism for interacting with
// scrollbars (see the description of the -xscrollcommand option
// for details).  They also support scanning, as described below.
func Spinbox(options ...option) *Window {
	return Inter.Spinbox(options...)
}

// text, tk_textCopy, tk_textCut, tk_textPaste - Create and manipulate 'text' hypertext editing widgets
// 
// # Text(Autoseparators(...))
// 
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
// 
// # Text(Blockcursor(...))
// 
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
// 
// # Text(Endline(...))
// 
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
// 
// # Text(Height(...))
// 
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
// 
// # Text(Inactiveselectbackground(...))
// 
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
// 
// # Text(Insertunfocussed(...))
// 
//  8.6
// 
// # Text(Maxundo(...))
// 
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
// 
// # Text(Spacing1(...))
// 
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
// 
// # Text(Spacing2(...))
// 
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
// 
// # Text(Spacing3(...))
// 
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
// 
// # Text(Startline(...))
// 
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
// 
// # Text(State(...))
// 
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
// 
// # Text(Tabs(...))
// 
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
// 
// # Text(Tabstyle(...))
// 
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n''th tab
// character in the line's text will be associated with the 'n''th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n''th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
// 
// # Text(Undo(...))
// 
// Specifies a boolean that says whether the undo mechanism is active or not.
// 
// # Text(Width(...))
// 
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
// 
// # Text(Wrap(...))
// 
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
// 
// # Description
// 
// The text command creates a new window (given by the pathName
// argument) and makes it into a text widget. Additional options, described
// above, may be specified on the command line or in the option database to
// configure aspects of the text such as its default background color and relief.
// The text command returns the path name of the new window.
// 
// A text widget displays one or more lines of text and allows that text to be
// edited. Text widgets support four different kinds of annotations on the text,
// called tags, marks, embedded windows or embedded images. Tags allow different
// portions of the text to be displayed with different fonts and colors. In
// addition, Tcl commands can be associated with tags so that scripts are invoked
// when particular actions such as keystrokes and mouse button presses occur in
// particular ranges of the text. See TAGS below for more details.
// 
// The second form of annotation consists of floating markers in the text called
// 
// Marks are used to keep track of various interesting positions in the text as
// it is edited. See MARKS below for more details.
// 
// The third form of annotation allows arbitrary windows to be embedded in a text
// widget. See EMBEDDED WINDOWS below for more details.
// 
// The fourth form of annotation allows Tk images to be embedded in a text
// widget. See EMBEDDED IMAGES below for more details.
// 
// The text widget also has a built-in undo/redo mechanism. See
// THE UNDO MECHANISM below for more details.
// 
// The text widget allows for the creation of peer widgets. These are other text
// widgets which share the same underlying data (text, marks, tags, images, etc).
// See PEER WIDGETS below for more details.
//
// The resulting Window is a child of 'w'.
func (w *Window) Text(options ...option) *Window {
	return w.newChild("text", options...)
}

// text, tk_textCopy, tk_textCut, tk_textPaste - Create and manipulate 'text' hypertext editing widgets
// 
// # Text(Autoseparators(...))
// 
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
// 
// # Text(Blockcursor(...))
// 
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
// 
// # Text(Endline(...))
// 
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
// 
// # Text(Height(...))
// 
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
// 
// # Text(Inactiveselectbackground(...))
// 
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
// 
// # Text(Insertunfocussed(...))
// 
//  8.6
// 
// # Text(Maxundo(...))
// 
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
// 
// # Text(Spacing1(...))
// 
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
// 
// # Text(Spacing2(...))
// 
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
// 
// # Text(Spacing3(...))
// 
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
// 
// # Text(Startline(...))
// 
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
// 
// # Text(State(...))
// 
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
// 
// # Text(Tabs(...))
// 
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
// 
// # Text(Tabstyle(...))
// 
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n''th tab
// character in the line's text will be associated with the 'n''th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n''th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
// 
// # Text(Undo(...))
// 
// Specifies a boolean that says whether the undo mechanism is active or not.
// 
// # Text(Width(...))
// 
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
// 
// # Text(Wrap(...))
// 
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
// 
// # Description
// 
// The text command creates a new window (given by the pathName
// argument) and makes it into a text widget. Additional options, described
// above, may be specified on the command line or in the option database to
// configure aspects of the text such as its default background color and relief.
// The text command returns the path name of the new window.
// 
// A text widget displays one or more lines of text and allows that text to be
// edited. Text widgets support four different kinds of annotations on the text,
// called tags, marks, embedded windows or embedded images. Tags allow different
// portions of the text to be displayed with different fonts and colors. In
// addition, Tcl commands can be associated with tags so that scripts are invoked
// when particular actions such as keystrokes and mouse button presses occur in
// particular ranges of the text. See TAGS below for more details.
// 
// The second form of annotation consists of floating markers in the text called
// 
// Marks are used to keep track of various interesting positions in the text as
// it is edited. See MARKS below for more details.
// 
// The third form of annotation allows arbitrary windows to be embedded in a text
// widget. See EMBEDDED WINDOWS below for more details.
// 
// The fourth form of annotation allows Tk images to be embedded in a text
// widget. See EMBEDDED IMAGES below for more details.
// 
// The text widget also has a built-in undo/redo mechanism. See
// THE UNDO MECHANISM below for more details.
// 
// The text widget allows for the creation of peer widgets. These are other text
// widgets which share the same underlying data (text, marks, tags, images, etc).
// See PEER WIDGETS below for more details.
func Text(options ...option) *Window {
	return Inter.Text(options...)
}

// toplevel - Create and manipulate 'toplevel' main and popup window widgets
// 
// # Toplevel(Background(...))
// 
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
// 
// # Toplevel(Backgroundimage(...))
// 
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
// 
// # Toplevel(Class(...))
// 
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Colormap(...))
// 
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Container(...))
// 
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Height(...))
// 
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Toplevel(Menu(...))
// 
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
// 
// # Toplevel(Screen(...))
// 
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
// 
// # Toplevel(Tile(...))
// 
//  "8.7, TIP262"
// 
// # Toplevel(Use(...))
// 
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Visual(...))
// 
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
// 
// # Toplevel(Width(...))
// 
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Description
// 
// The toplevel command creates a new toplevel widget (given
// by the pathName argument).  Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the toplevel such as its background color
// and relief.  The toplevel command returns the
// path name of the new window.
// 
// A toplevel is similar to a frame except that it is created as a
// top-level window:  its X parent is the root window of a screen
// rather than the logical parent from its Tk path name.  The primary
// purpose of a toplevel is to serve as a container for dialog boxes
// and other collections of widgets.  The only visible features
// of a toplevel are its background and an optional 3-D border
// to make the toplevel appear raised or sunken.
//
// The resulting Window is a child of 'w'.
func (w *Window) Toplevel(options ...option) *Window {
	return w.newChild("toplevel", options...)
}

// toplevel - Create and manipulate 'toplevel' main and popup window widgets
// 
// # Toplevel(Background(...))
// 
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
// 
// # Toplevel(Backgroundimage(...))
// 
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
// 
// # Toplevel(Class(...))
// 
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Colormap(...))
// 
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Container(...))
// 
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Height(...))
// 
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Toplevel(Menu(...))
// 
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
// 
// # Toplevel(Screen(...))
// 
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
// 
// # Toplevel(Tile(...))
// 
//  "8.7, TIP262"
// 
// # Toplevel(Use(...))
// 
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
// 
// # Toplevel(Visual(...))
// 
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
// 
// # Toplevel(Width(...))
// 
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
// 
// # Description
// 
// The toplevel command creates a new toplevel widget (given
// by the pathName argument).  Additional
// options, described above, may be specified on the command line
// or in the option database
// to configure aspects of the toplevel such as its background color
// and relief.  The toplevel command returns the
// path name of the new window.
// 
// A toplevel is similar to a frame except that it is created as a
// top-level window:  its X parent is the root window of a screen
// rather than the logical parent from its Tk path name.  The primary
// purpose of a toplevel is to serve as a container for dialog boxes
// and other collections of widgets.  The only visible features
// of a toplevel are its background and an optional 3-D border
// to make the toplevel appear raised or sunken.
func Toplevel(options ...option) *Window {
	return Inter.Toplevel(options...)
}

// ttk::button - Widget that issues a command when pressed
// 
// # TButton(Command(...))
// 
// A script to evaluate when the widget is invoked.
// 
// # TButton(Default(...))
// 
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
// 
// # Description
// 
// A ttk::button widget displays a textual label and/or image,
// and evaluates a command when pressed.
//
// The resulting Window is a child of 'w'.
func (w *Window) TButton(options ...option) *Window {
	return w.newChild("ttk_button", options...)
}

// ttk::button - Widget that issues a command when pressed
// 
// # TButton(Command(...))
// 
// A script to evaluate when the widget is invoked.
// 
// # TButton(Default(...))
// 
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
// 
// # Description
// 
// A ttk::button widget displays a textual label and/or image,
// and evaluates a command when pressed.
func TButton(options ...option) *Window {
	return Inter.TButton(options...)
}

// ttk::checkbutton - On/off widget
// 
// # TCheckbutton(Command(...))
// 
// A Tcl script to execute whenever the widget is invoked.
// 
// # TCheckbutton(Offvalue(...))
// 
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
// 
// # TCheckbutton(Onvalue(...))
// 
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
// 
// # TCheckbutton(Variable(...))
// 
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
// 
// # Description
// 
// A ttk::checkbutton widget is used to show or change a setting.
// It has two states, selected and deselected.
// The state of the checkbutton may be linked to a Tcl variable.
//
// The resulting Window is a child of 'w'.
func (w *Window) TCheckbutton(options ...option) *Window {
	return w.newChild("ttk_checkbutton", options...)
}

// ttk::checkbutton - On/off widget
// 
// # TCheckbutton(Command(...))
// 
// A Tcl script to execute whenever the widget is invoked.
// 
// # TCheckbutton(Offvalue(...))
// 
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
// 
// # TCheckbutton(Onvalue(...))
// 
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
// 
// # TCheckbutton(Variable(...))
// 
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
// 
// # Description
// 
// A ttk::checkbutton widget is used to show or change a setting.
// It has two states, selected and deselected.
// The state of the checkbutton may be linked to a Tcl variable.
func TCheckbutton(options ...option) *Window {
	return Inter.TCheckbutton(options...)
}

// ttk::combobox - text field with popdown selection list
// 
// # TCombobox(Exportselection(...))
// 
// Boolean value.
// If set, the widget selection is linked to the X selection.
// 
// # TCombobox(Justify(...))
// 
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
// 
// # TCombobox(Height(...))
// 
// Specifies the height of the pop-down listbox, in rows.
// 
// # TCombobox(Postcommand(...))
// 
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
// 
// # TCombobox(State(...))
// 
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
// 
// # TCombobox(Textvariable(...))
// 
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
// 
// # TCombobox(Values(...))
// 
// Specifies the list of values to display in the drop-down listbox.
// 
// # TCombobox(Width(...))
// 
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// 
// # Description
// 
// A ttk::combobox combines a text field with a pop-down list of values;
// the user may select the value of the text field from among the
// values in the list.
//
// The resulting Window is a child of 'w'.
func (w *Window) TCombobox(options ...option) *Window {
	return w.newChild("ttk_combobox", options...)
}

// ttk::combobox - text field with popdown selection list
// 
// # TCombobox(Exportselection(...))
// 
// Boolean value.
// If set, the widget selection is linked to the X selection.
// 
// # TCombobox(Justify(...))
// 
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
// 
// # TCombobox(Height(...))
// 
// Specifies the height of the pop-down listbox, in rows.
// 
// # TCombobox(Postcommand(...))
// 
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
// 
// # TCombobox(State(...))
// 
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
// 
// # TCombobox(Textvariable(...))
// 
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
// 
// # TCombobox(Values(...))
// 
// Specifies the list of values to display in the drop-down listbox.
// 
// # TCombobox(Width(...))
// 
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// 
// # Description
// 
// A ttk::combobox combines a text field with a pop-down list of values;
// the user may select the value of the text field from among the
// values in the list.
func TCombobox(options ...option) *Window {
	return Inter.TCombobox(options...)
}

// ttk::entry - Editable text field widget
// 
// # TEntry(Exportselection(...))
// 
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
// 
// # TEntry(Invalidcommand(...))
// 
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
// 
// # TEntry(Justify(...))
// 
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
// 
// # TEntry(Show(...))
// 
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
// 
// # TEntry(State(...))
// 
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
// 
// # TEntry(Textvariable(...))
// 
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
// 
// # TEntry(Validate(...))
// 
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
// 
// # TEntry(Validatecommand(...))
// 
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
// 
// # TEntry(Width(...))
// 
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// 
// # Description
// 
// An ttk::entry widget displays a one-line text string and
// allows that string to be edited by the user.
// The value of the string may be linked to a Tcl variable
// with the -textvariable option.
// Entry widgets support horizontal scrolling with the
// standard -xscrollcommand option and xview widget command.
//
// The resulting Window is a child of 'w'.
func (w *Window) TEntry(options ...option) *Window {
	return w.newChild("ttk_entry", options...)
}

// ttk::entry - Editable text field widget
// 
// # TEntry(Exportselection(...))
// 
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
// 
// # TEntry(Invalidcommand(...))
// 
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
// 
// # TEntry(Justify(...))
// 
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
// 
// # TEntry(Show(...))
// 
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
// 
// # TEntry(State(...))
// 
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
// 
// # TEntry(Textvariable(...))
// 
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
// 
// # TEntry(Validate(...))
// 
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
// 
// # TEntry(Validatecommand(...))
// 
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
// 
// # TEntry(Width(...))
// 
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// 
// # Description
// 
// An ttk::entry widget displays a one-line text string and
// allows that string to be edited by the user.
// The value of the string may be linked to a Tcl variable
// with the -textvariable option.
// Entry widgets support horizontal scrolling with the
// standard -xscrollcommand option and xview widget command.
func TEntry(options ...option) *Window {
	return Inter.TEntry(options...)
}

// ttk::frame - Simple container widget
// 
// # TFrame(Borderwidth(...))
// 
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
// 
// # TFrame(Relief(...))
// 
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
// 
// # TFrame(Width(...))
// 
// If specified, the widget's requested width in pixels.
// 
// # TFrame(Height(...))
// 
// If specified, the widget's requested height in pixels.
// 
// # Description
// 
// A ttk::frame widget is a container, used to group other widgets
// together.
//
// The resulting Window is a child of 'w'.
func (w *Window) TFrame(options ...option) *Window {
	return w.newChild("ttk_frame", options...)
}

// ttk::frame - Simple container widget
// 
// # TFrame(Borderwidth(...))
// 
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
// 
// # TFrame(Relief(...))
// 
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
// 
// # TFrame(Width(...))
// 
// If specified, the widget's requested width in pixels.
// 
// # TFrame(Height(...))
// 
// If specified, the widget's requested height in pixels.
// 
// # Description
// 
// A ttk::frame widget is a container, used to group other widgets
// together.
func TFrame(options ...option) *Window {
	return Inter.TFrame(options...)
}

// ttk::label - Display a text string and/or image
// 
// # TLabel(Background(...))
// 
// The widget's background color.
// If unspecified, the theme default is used.
// 
// # TLabel(Relief(...))
// 
// \" Rewrite this:
// 
// # TLabel(Wraplength(...))
// 
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
// 
// # Description
// 
// A ttk::label widget displays a textual label and/or image.
// The label may be linked to a Tcl variable
// to automatically change the displayed text.
//
// The resulting Window is a child of 'w'.
func (w *Window) TLabel(options ...option) *Window {
	return w.newChild("ttk_label", options...)
}

// ttk::label - Display a text string and/or image
// 
// # TLabel(Background(...))
// 
// The widget's background color.
// If unspecified, the theme default is used.
// 
// # TLabel(Relief(...))
// 
// \" Rewrite this:
// 
// # TLabel(Wraplength(...))
// 
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
// 
// # Description
// 
// A ttk::label widget displays a textual label and/or image.
// The label may be linked to a Tcl variable
// to automatically change the displayed text.
func TLabel(options ...option) *Window {
	return Inter.TLabel(options...)
}

// ttk::labelframe - Container widget with optional label
// 
// # TLabelframe(Height(...))
// 
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
// 
// # TLabelframe(Labelanchor(...))
// 
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
// 
// # TLabelframe(Labelwidget(...))
// 
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe''s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
// 
// # TLabelframe(Text(...))
// 
// Specifies the text of the label.
// 
// # TLabelframe(Underline(...))
// 
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
// 
// # TLabelframe(Width(...))
// 
// If specified, the widget's requested width in pixels.
// 
// # Description
// 
// A ttk::labelframe widget is a container used to group other widgets
// together.  It has an optional label, which may be a plain text string or
// another widget.
//
// The resulting Window is a child of 'w'.
func (w *Window) TLabelframe(options ...option) *Window {
	return w.newChild("ttk_labelframe", options...)
}

// ttk::labelframe - Container widget with optional label
// 
// # TLabelframe(Height(...))
// 
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
// 
// # TLabelframe(Labelanchor(...))
// 
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
// 
// # TLabelframe(Labelwidget(...))
// 
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe''s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
// 
// # TLabelframe(Text(...))
// 
// Specifies the text of the label.
// 
// # TLabelframe(Underline(...))
// 
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
// 
// # TLabelframe(Width(...))
// 
// If specified, the widget's requested width in pixels.
// 
// # Description
// 
// A ttk::labelframe widget is a container used to group other widgets
// together.  It has an optional label, which may be a plain text string or
// another widget.
func TLabelframe(options ...option) *Window {
	return Inter.TLabelframe(options...)
}

// ttk::menubutton - Widget that pops down a menu when pressed
// 
// # TMenubutton(Direction(...))
// 
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
// 
// # TMenubutton(Menu(...))
// 
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
// 
// # Description
// 
// A ttk::menubutton widget displays a textual label and/or image,
// and displays a menu when pressed.
//
// The resulting Window is a child of 'w'.
func (w *Window) TMenubutton(options ...option) *Window {
	return w.newChild("ttk_menubutton", options...)
}

// ttk::menubutton - Widget that pops down a menu when pressed
// 
// # TMenubutton(Direction(...))
// 
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
// 
// # TMenubutton(Menu(...))
// 
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
// 
// # Description
// 
// A ttk::menubutton widget displays a textual label and/or image,
// and displays a menu when pressed.
func TMenubutton(options ...option) *Window {
	return Inter.TMenubutton(options...)
}

// ttk::notebook - Multi-paned container widget
// 
// # TNotebook(Height(...))
// 
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
// 
// # TNotebook(Padding(...))
// 
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
// 
// # TNotebook(Width(...))
// 
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
// 
// # TNotebook(State(...))
// 
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
// 
// # TNotebook(Sticky(...))
// 
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
// 
// # TNotebook(Padding(...))
// 
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
// 
// # TNotebook(Text(...))
// 
// Specifies a string to be displayed in the tab.
// 
// # TNotebook(Image(...))
// 
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
// 
// # TNotebook(Compound(...))
// 
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
// 
// # TNotebook(Underline(...))
// 
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
// 
// # Description
// 
// A ttk::notebook widget manages a collection of windows
// and displays a single one at a time.
// Each content window is associated with a tab,
// which the user may select to change the currently-displayed window.
//
// The resulting Window is a child of 'w'.
func (w *Window) TNotebook(options ...option) *Window {
	return w.newChild("ttk_notebook", options...)
}

// ttk::notebook - Multi-paned container widget
// 
// # TNotebook(Height(...))
// 
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
// 
// # TNotebook(Padding(...))
// 
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
// 
// # TNotebook(Width(...))
// 
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
// 
// # TNotebook(State(...))
// 
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
// 
// # TNotebook(Sticky(...))
// 
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
// 
// # TNotebook(Padding(...))
// 
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
// 
// # TNotebook(Text(...))
// 
// Specifies a string to be displayed in the tab.
// 
// # TNotebook(Image(...))
// 
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
// 
// # TNotebook(Compound(...))
// 
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
// 
// # TNotebook(Underline(...))
// 
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
// 
// # Description
// 
// A ttk::notebook widget manages a collection of windows
// and displays a single one at a time.
// Each content window is associated with a tab,
// which the user may select to change the currently-displayed window.
func TNotebook(options ...option) *Window {
	return Inter.TNotebook(options...)
}

// ttk::panedwindow - Multi-pane container window
// 
// # TPanedwindow(Orient(...))
// 
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
// 
// # TPanedwindow(Width(...))
// 
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
// 
// # TPanedwindow(Height(...))
// 
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
// 
// # TPanedwindow(Weight(...))
// 
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
// 
// # Description
// 
// A ttk::panedwindow widget displays a number of subwindows,
// stacked either vertically or horizontally.
// The user may adjust the relative sizes of the subwindows
// by dragging the sash between panes.
//
// The resulting Window is a child of 'w'.
func (w *Window) TPanedwindow(options ...option) *Window {
	return w.newChild("ttk_panedwindow", options...)
}

// ttk::panedwindow - Multi-pane container window
// 
// # TPanedwindow(Orient(...))
// 
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
// 
// # TPanedwindow(Width(...))
// 
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
// 
// # TPanedwindow(Height(...))
// 
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
// 
// # TPanedwindow(Weight(...))
// 
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
// 
// # Description
// 
// A ttk::panedwindow widget displays a number of subwindows,
// stacked either vertically or horizontally.
// The user may adjust the relative sizes of the subwindows
// by dragging the sash between panes.
func TPanedwindow(options ...option) *Window {
	return Inter.TPanedwindow(options...)
}

// ttk::progressbar - Provide progress feedback
// 
// # TProgressbar(Length(...))
// 
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
// 
// # TProgressbar(Maximum(...))
// 
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
// 
// # TProgressbar(Mode(...))
// 
// One of 'determinate' or 'indeterminate'.
// 
// # TProgressbar(Orient(...))
// 
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
// 
// # TProgressbar(Phase(...))
// 
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
// 
// # TProgressbar(Value(...))
// 
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
// 
// # TProgressbar(Variable(...))
// 
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
// 
// # Description
// 
// A ttk::progressbar widget shows the status of a long-running
// operation.  They can operate in two modes: determinate mode shows the
// amount completed relative to the total amount of work to be done, and
// indeterminate mode provides an animated display to let the user know
// that something is happening.
// 
// If the value of -orient is horizontal a text string can be
// displayed inside the progressbar. This string can be configured using
// the -anchor, -font, -foreground, -justify,
// -text and -wraplength options. If the value of -orient
// is vertical then these options are ignored.
//
// The resulting Window is a child of 'w'.
func (w *Window) TProgressbar(options ...option) *Window {
	return w.newChild("ttk_progressbar", options...)
}

// ttk::progressbar - Provide progress feedback
// 
// # TProgressbar(Length(...))
// 
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
// 
// # TProgressbar(Maximum(...))
// 
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
// 
// # TProgressbar(Mode(...))
// 
// One of 'determinate' or 'indeterminate'.
// 
// # TProgressbar(Orient(...))
// 
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
// 
// # TProgressbar(Phase(...))
// 
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
// 
// # TProgressbar(Value(...))
// 
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
// 
// # TProgressbar(Variable(...))
// 
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
// 
// # Description
// 
// A ttk::progressbar widget shows the status of a long-running
// operation.  They can operate in two modes: determinate mode shows the
// amount completed relative to the total amount of work to be done, and
// indeterminate mode provides an animated display to let the user know
// that something is happening.
// 
// If the value of -orient is horizontal a text string can be
// displayed inside the progressbar. This string can be configured using
// the -anchor, -font, -foreground, -justify,
// -text and -wraplength options. If the value of -orient
// is vertical then these options are ignored.
func TProgressbar(options ...option) *Window {
	return Inter.TProgressbar(options...)
}

// ttk::radiobutton - Mutually exclusive option widget
// 
// # TRadiobutton(Command(...))
// 
// A Tcl script to evaluate whenever the widget is invoked.
// 
// # TRadiobutton(Value(...))
// 
// The value to store in the associated '-variable'
// when the widget is selected.
// 
// # TRadiobutton(Variable(...))
// 
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
// 
// # Description
// 
// ttk::radiobutton widgets are used in groups to show or change
// a set of mutually-exclusive options.
// Radiobuttons are linked to a Tcl variable,
// and have an associated value; when a radiobutton is clicked,
// it sets the variable to its associated value.
//
// The resulting Window is a child of 'w'.
func (w *Window) TRadiobutton(options ...option) *Window {
	return w.newChild("ttk_radiobutton", options...)
}

// ttk::radiobutton - Mutually exclusive option widget
// 
// # TRadiobutton(Command(...))
// 
// A Tcl script to evaluate whenever the widget is invoked.
// 
// # TRadiobutton(Value(...))
// 
// The value to store in the associated '-variable'
// when the widget is selected.
// 
// # TRadiobutton(Variable(...))
// 
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
// 
// # Description
// 
// ttk::radiobutton widgets are used in groups to show or change
// a set of mutually-exclusive options.
// Radiobuttons are linked to a Tcl variable,
// and have an associated value; when a radiobutton is clicked,
// it sets the variable to its associated value.
func TRadiobutton(options ...option) *Window {
	return Inter.TRadiobutton(options...)
}

// ttk::scale - Create and manipulate a scale widget
// 
// # TScale(Command(...))
// 
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
// 
// # TScale(From(...))
// 
// A real value corresponding to the left or top end of the scale.
// 
// # TScale(Length(...))
// 
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
// 
// # TScale(Orient(...))
// 
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
// 
// # TScale(To(...))
// 
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
// 
// # TScale(Value(...))
// 
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
// 
// # TScale(Variable(...))
// 
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
// 
// # Description
// 
// A ttk::scale widget is typically used to control the numeric value of a
// linked variable that varies uniformly over some range. A scale displays a
// slider that can be moved along over a trough, with the relative
// position of the slider over the trough indicating the value of the variable.
//
// The resulting Window is a child of 'w'.
func (w *Window) TScale(options ...option) *Window {
	return w.newChild("ttk_scale", options...)
}

// ttk::scale - Create and manipulate a scale widget
// 
// # TScale(Command(...))
// 
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
// 
// # TScale(From(...))
// 
// A real value corresponding to the left or top end of the scale.
// 
// # TScale(Length(...))
// 
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
// 
// # TScale(Orient(...))
// 
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
// 
// # TScale(To(...))
// 
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
// 
// # TScale(Value(...))
// 
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
// 
// # TScale(Variable(...))
// 
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
// 
// # Description
// 
// A ttk::scale widget is typically used to control the numeric value of a
// linked variable that varies uniformly over some range. A scale displays a
// slider that can be moved along over a trough, with the relative
// position of the slider over the trough indicating the value of the variable.
func TScale(options ...option) *Window {
	return Inter.TScale(options...)
}

// ttk::scrollbar - Control the viewport of a scrollable widget
// 
// # TScrollbar(Command(...))
// 
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
// 
// # TScrollbar(Orient(...))
// 
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
// 
// # Description
// 
// ttk::scrollbar widgets are typically linked to an associated window
// that displays a document of some sort, such as a file being edited or a
// drawing.
// A scrollbar displays a thumb in the middle portion of the scrollbar,
// whose position and size provides information about the portion of the
// document visible in the associated window.
// The thumb may be dragged by the user to control the visible region.
// Depending on the theme, two or more arrow buttons may also be present;
// these are used to scroll the visible region in discrete units.
//
// The resulting Window is a child of 'w'.
func (w *Window) TScrollbar(options ...option) *Window {
	return w.newChild("ttk_scrollbar", options...)
}

// ttk::scrollbar - Control the viewport of a scrollable widget
// 
// # TScrollbar(Command(...))
// 
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
// 
// # TScrollbar(Orient(...))
// 
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
// 
// # Description
// 
// ttk::scrollbar widgets are typically linked to an associated window
// that displays a document of some sort, such as a file being edited or a
// drawing.
// A scrollbar displays a thumb in the middle portion of the scrollbar,
// whose position and size provides information about the portion of the
// document visible in the associated window.
// The thumb may be dragged by the user to control the visible region.
// Depending on the theme, two or more arrow buttons may also be present;
// these are used to scroll the visible region in discrete units.
func TScrollbar(options ...option) *Window {
	return Inter.TScrollbar(options...)
}

// ttk::separator - Separator bar
// 
// # TSeparator(Orient(...))
// 
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
// 
// # Description
// 
// A ttk::separator widget displays a horizontal or vertical separator
// bar.
//
// The resulting Window is a child of 'w'.
func (w *Window) TSeparator(options ...option) *Window {
	return w.newChild("ttk_separator", options...)
}

// ttk::separator - Separator bar
// 
// # TSeparator(Orient(...))
// 
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
// 
// # Description
// 
// A ttk::separator widget displays a horizontal or vertical separator
// bar.
func TSeparator(options ...option) *Window {
	return Inter.TSeparator(options...)
}

// ttk::sizegrip - Bottom-right corner resize widget
// 
// A ttk::sizegrip widget (also known as a grow box)
// allows the user to resize the containing toplevel window
// by pressing and dragging the grip.
//
// The resulting Window is a child of 'w'.
func (w *Window) TSizegrip(options ...option) *Window {
	return w.newChild("ttk_sizegrip", options...)
}

// ttk::sizegrip - Bottom-right corner resize widget
// 
// A ttk::sizegrip widget (also known as a grow box)
// allows the user to resize the containing toplevel window
// by pressing and dragging the grip.
func TSizegrip(options ...option) *Window {
	return Inter.TSizegrip(options...)
}

// ttk::spinbox - Selecting text field widget
// 
// # TSpinbox(Command(...))
// 
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
// 
// # TSpinbox(Format(...))
// 
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
// 
// # TSpinbox(From(...))
// 
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
// 
// # TSpinbox(Increment(...))
// 
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
// 
// # TSpinbox(To(...))
// 
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
// 
// # TSpinbox(Values(...))
// 
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
// 
// # TSpinbox(Wrap(...))
// 
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
// 
// # Description
// 
// A ttk::spinbox widget is a ttk::entry widget with built-in
// up and down buttons that are used to either modify a numeric value or
// to select among a set of values. The widget implements all the features
// of the ttk::entry widget including support of the
// -textvariable option to link the value displayed by the widget
// to a Tcl variable.
//
// The resulting Window is a child of 'w'.
func (w *Window) TSpinbox(options ...option) *Window {
	return w.newChild("ttk_spinbox", options...)
}

// ttk::spinbox - Selecting text field widget
// 
// # TSpinbox(Command(...))
// 
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
// 
// # TSpinbox(Format(...))
// 
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
// 
// # TSpinbox(From(...))
// 
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
// 
// # TSpinbox(Increment(...))
// 
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
// 
// # TSpinbox(To(...))
// 
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
// 
// # TSpinbox(Values(...))
// 
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
// 
// # TSpinbox(Wrap(...))
// 
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
// 
// # Description
// 
// A ttk::spinbox widget is a ttk::entry widget with built-in
// up and down buttons that are used to either modify a numeric value or
// to select among a set of values. The widget implements all the features
// of the ttk::entry widget including support of the
// -textvariable option to link the value displayed by the widget
// to a Tcl variable.
func TSpinbox(options ...option) *Window {
	return Inter.TSpinbox(options...)
}

// ttk::treeview - hierarchical multicolumn data display widget
// 
// # TTreeview(Columns(...))
// 
// A list of column identifiers,
// specifying the number of columns and their names.
// 
// # TTreeview(Displaycolumns(...))
// 
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
// 
// # TTreeview(Height(...))
// 
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
// 
// # TTreeview(Selectmode(...))
// 
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
// 
// # TTreeview(Selecttype(...))
// 
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
// 
// # TTreeview(Show(...))
// 
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
// 
// # TTreeview(Striped(...))
// 
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
// 
// # TTreeview(Titlecolumns(...))
// 
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
// 
// # TTreeview(Titleitems(...))
// 
// Number of items at the top that should not be vertically scrolled. Default is 0.
// 
// # Description
// 
// The ttk::treeview widget displays a hierarchical collection of items.
// Each item has a textual label, an optional image,
// and an optional list of data values.
// The data values are displayed in successive columns after
// the tree label.
// 
// The order in which data values are displayed may be controlled
// by setting the -displaycolumns widget option.
// The tree widget can also display column headings.
// Columns may be accessed by number or by symbolic names
// listed in the -columns widget option;
// see COLUMN IDENTIFIERS.
// 
// Each item is identified by a unique name.
// The widget will generate item IDs if they are not supplied by the caller.
// There is a distinguished root item, named {}.
// The root item itself is not displayed;
// its children appear at the top level of the hierarchy.
// 
// Each item also has a list of tags,
// which can be used to associate event bindings with individual items
// and control the appearance of the item.
// 
// Treeview widgets support horizontal and vertical scrolling with the
// standard -[xy]scrollcommand options
// and [xy]view widget commands.
//
// The resulting Window is a child of 'w'.
func (w *Window) TTreeview(options ...option) *Window {
	return w.newChild("ttk_treeview", options...)
}

// ttk::treeview - hierarchical multicolumn data display widget
// 
// # TTreeview(Columns(...))
// 
// A list of column identifiers,
// specifying the number of columns and their names.
// 
// # TTreeview(Displaycolumns(...))
// 
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
// 
// # TTreeview(Height(...))
// 
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
// 
// # TTreeview(Selectmode(...))
// 
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
// 
// # TTreeview(Selecttype(...))
// 
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
// 
// # TTreeview(Show(...))
// 
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
// 
// # TTreeview(Striped(...))
// 
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
// 
// # TTreeview(Titlecolumns(...))
// 
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
// 
// # TTreeview(Titleitems(...))
// 
// Number of items at the top that should not be vertically scrolled. Default is 0.
// 
// # Description
// 
// The ttk::treeview widget displays a hierarchical collection of items.
// Each item has a textual label, an optional image,
// and an optional list of data values.
// The data values are displayed in successive columns after
// the tree label.
// 
// The order in which data values are displayed may be controlled
// by setting the -displaycolumns widget option.
// The tree widget can also display column headings.
// Columns may be accessed by number or by symbolic names
// listed in the -columns widget option;
// see COLUMN IDENTIFIERS.
// 
// Each item is identified by a unique name.
// The widget will generate item IDs if they are not supplied by the caller.
// There is a distinguished root item, named {}.
// The root item itself is not displayed;
// its children appear at the top level of the hierarchy.
// 
// Each item also has a list of tags,
// which can be used to associate event bindings with individual items
// and control the appearance of the item.
// 
// Treeview widgets support horizontal and vertical scrolling with the
// standard -[xy]scrollcommand options
// and [xy]view widget commands.
func TTreeview(options ...option) *Window {
	return Inter.TTreeview(options...)
}

type activebackgroundOption struct { v any }

func (o activebackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activebackground %s`, optionString(o.v))
}


// Specifies background color to use when drawing active elements.
// An element (a widget or portion of a widget) is active if the
// mouse cursor is positioned over the element and pressing a mouse button
// will cause some action to occur.
// If strict Motif compliance has been requested by setting the
// 'tk_strictMotif' variable, this option will normally be
// ignored;  the normal background color will be used instead.
// For some elements on Windows and Macintosh systems, the active color
// will only be used while mouse button 1 is pressed over the element.
func Activebackground(value any) option {
	return activebackgroundOption{value}
}

type activeborderwidthOption struct { v any }

func (o activeborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeborderwidth %s`, optionString(o.v))
}


// Specifies a non-negative value indicating
// the width of the 3-D border drawn around active elements.  See above for
// definition of active elements.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// This option is typically only available in widgets displaying more
// than one element at a time (e.g. menus but not buttons).
func Activeborderwidth(value any) option {
	return activeborderwidthOption{value}
}

type activeforegroundOption struct { v any }

func (o activeforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activeforeground %s`, optionString(o.v))
}


// Specifies foreground color to use when drawing active elements.
// See above for definition of active elements.
func Activeforeground(value any) option {
	return activeforegroundOption{value}
}

type activereliefOption struct { v any }

func (o activereliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activerelief %s`, optionString(o.v))
}


// Specifies the 3-D effect desired for the active item of the widget.
// See the '-relief' option for details.
//
// # Scrollbar(Activerelief(...))
//
// Specifies the relief to use when displaying the element that is
// active, if any.
// Elements other than the active element are always displayed with
// a raised relief.
func Activerelief(value any) option {
	return activereliefOption{value}
}

type activestyleOption struct { v any }

func (o activestyleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-activestyle %s`, optionString(o.v))
}


// # Listbox(Activestyle(...))
//
// Specifies the style in which to draw the active element.  This must be
// one of 'dotbox' (show a focus ring around the active element),
// 'none' (no special indication of active element) or
// 'underline' (underline the active element).
// The default is 'underline' on Windows, and 'dotbox' elsewhere.
func Activestyle(value any) option {
	return activestyleOption{value}
}

type anchorOption struct { v any }

func (o anchorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-anchor %s`, optionString(o.v))
}


// Specifies how the information in a widget (e.g. text or a bitmap)
// is to be displayed in the widget.
// Must be one of the values 'n', 'ne', 'e', 'se',
// 's', 'sw', 'w', 'nw', or 'center'.
// For example, 'nw' means display the information such that its
// top-left corner is at the top-left corner of the widget.
func Anchor(value any) option {
	return anchorOption{value}
}

type aspectOption struct { v any }

func (o aspectOption) optionString(w *Window) string {
	return fmt.Sprintf(`-aspect %s`, optionString(o.v))
}


// # Message(Aspect(...))
//
// Specifies a non-negative integer value indicating desired
// aspect ratio for the text.  The aspect ratio is specified as
// 100*width/height.  100 means the text should
// be as wide as it is tall, 200 means the text should
// be twice as wide as it is tall, 50 means the text should
// be twice as tall as it is wide, and so on.
// Used to choose line length for text if '-width' option
// is not specified.
// Defaults to 150.
func Aspect(value any) option {
	return aspectOption{value}
}

type autoseparatorsOption struct { v any }

func (o autoseparatorsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-autoseparators %s`, optionString(o.v))
}


// # Text(Autoseparators(...))
//
// Specifies a boolean that says whether separators are automatically inserted in
// the undo stack. Only meaningful when the '-undo' option is true.
func Autoseparators(value any) option {
	return autoseparatorsOption{value}
}

type backgroundOption struct { v any }

func (o backgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-background %s`, optionString(o.v))
}


// Specifies the normal background color to use when displaying the
// widget.
//
// # Frame(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Labelframe(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # Toplevel(Background(...))
//
// This option is the same as the standard '-background' option
// except that its value may also be specified as an empty string.
// In this case, the widget will display no background or border, and
// no colors will be consumed from its colormap for its background
// and border.
//
// # TLabel(Background(...))
//
// The widget's background color.
// If unspecified, the theme default is used.
func Background(value any) option {
	return backgroundOption{value}
}

type backgroundimageOption struct { v any }

func (o backgroundimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-backgroundimage %s`, optionString(o.v))
}


// # Frame(Backgroundimage(...))
//
// This specifies an image to display on the frame's background within
// the border of the frame (i.e., the image will be clipped by the
// frame's highlight ring and border, if either are present); subwidgets
// of the frame will be drawn on top. The image must have been created
// with the 'image create' command. If specified as the empty string,
// no image will be displayed.
//
// # Toplevel(Backgroundimage(...))
//
// This specifies an image to display on the toplevel's background within
// the border of the toplevel (i.e., the image will be clipped by the
// toplevel's highlight ring and border, if either are present) on top of
// the background;
// subwidgets of the toplevel will be drawn on top. The image must have
// been created with the 'image create' command. If specified as the
// empty string, no image will be displayed.
func Backgroundimage(value any) option {
	return backgroundimageOption{value}
}

type bdOption struct { v any }

func (o bdOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bd %s`, optionString(o.v))
}


// Specifies a non-negative value indicating the width
// of the 3-D border to draw around the outside of the widget (if such a
// border is being drawn;  the '-relief' option typically determines
// this).  The value may also be used when drawing 3-D effects in the
// interior of the widget.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
func Bd(value any) option {
	return bdOption{value}
}

type bgOption struct { v any }

func (o bgOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bg %s`, optionString(o.v))
}


// Specifies the normal background color to use when displaying the
// widget.
func Bg(value any) option {
	return bgOption{value}
}

type bigincrementOption struct { v any }

func (o bigincrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bigincrement %s`, optionString(o.v))
}


// # Scale(Bigincrement(...))
//
// Some interactions with the scale cause its value to change by
func Bigincrement(value any) option {
	return bigincrementOption{value}
}

type bitmapOption struct { v any }

func (o bitmapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-bitmap %s`, optionString(o.v))
}


// Specifies a bitmap to display in the widget, in any of the forms
// acceptable to 'Tk_GetBitmap'.
// The exact way in which the bitmap is displayed may be affected by
// other options such as '-anchor' or '-justify'.
// Typically, if this option is specified then it overrides other
// options that specify a textual value to display in the widget
// but this is controlled by the '-compound' option;
// the '-bitmap' option may be reset to an empty string to re-enable
// a text display.
// In widgets that support both '-bitmap' and '-image' options,
// '-image' will usually override '-bitmap'.
func Bitmap(value any) option {
	return bitmapOption{value}
}

type blockcursorOption struct { v any }

func (o blockcursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-blockcursor %s`, optionString(o.v))
}


// # Text(Blockcursor(...))
//
// Specifies a boolean that says whether the blinking insertion cursor should be
// drawn as a character-sized rectangular block. If false (the default) a thin
// vertical line is used for the insertion cursor.
func Blockcursor(value any) option {
	return blockcursorOption{value}
}

type borderwidthOption struct { v any }

func (o borderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-borderwidth %s`, optionString(o.v))
}


// Specifies a non-negative value indicating the width
// of the 3-D border to draw around the outside of the widget (if such a
// border is being drawn;  the '-relief' option typically determines
// this).  The value may also be used when drawing 3-D effects in the
// interior of the widget.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # TFrame(Borderwidth(...))
//
// The desired width of the widget border.  Defaults to 0.
// May be ignored depending on the theme used.
func Borderwidth(value any) option {
	return borderwidthOption{value}
}

type buttonbackgroundOption struct { v any }

func (o buttonbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttonbackground %s`, optionString(o.v))
}


// # Spinbox(Buttonbackground(...))
//
// The background color to be used for the spin buttons.
func Buttonbackground(value any) option {
	return buttonbackgroundOption{value}
}

type buttoncursorOption struct { v any }

func (o buttoncursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttoncursor %s`, optionString(o.v))
}


// # Spinbox(Buttoncursor(...))
//
// The cursor to be used when over the spin buttons.  If this is empty
// (the default), a default cursor will be used.
func Buttoncursor(value any) option {
	return buttoncursorOption{value}
}

type buttondownreliefOption struct { v any }

func (o buttondownreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttondownrelief %s`, optionString(o.v))
}


// # Spinbox(Buttondownrelief(...))
//
// The relief to be used for the upper spin button.
func Buttondownrelief(value any) option {
	return buttondownreliefOption{value}
}

type buttonupreliefOption struct { v any }

func (o buttonupreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-buttonuprelief %s`, optionString(o.v))
}


// # Spinbox(Buttonuprelief(...))
//
// The relief to be used for the lower spin button.
func Buttonuprelief(value any) option {
	return buttonupreliefOption{value}
}

type classOption struct { v any }

func (o classOption) optionString(w *Window) string {
	return fmt.Sprintf(`-class %s`, optionString(o.v))
}


// # Frame(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings.
// The '-class' option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Class(...))
//
// Specifies a class for the window.
// This class will be used when querying the option database for
// the window's other options, and it will also be used later for
// other purposes such as bindings. Some window managers display the
// class name for windows in their dock while some others display the
// window title.
// The '-class' option may not be changed with the 'configure'
// widget command.
func Class(value any) option {
	return classOption{value}
}

type closeenoughOption struct { v any }

func (o closeenoughOption) optionString(w *Window) string {
	return fmt.Sprintf(`-closeenough %s`, optionString(o.v))
}


// # Canvas(Closeenough(...))
//
// Specifies a floating-point value indicating how close the mouse cursor
// must be to an item before it is considered to be
func Closeenough(value any) option {
	return closeenoughOption{value}
}

type colormapOption struct { v any }

func (o colormapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-colormap %s`, optionString(o.v))
}


// # Frame(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Labelframe(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the same colormap as its parent.
// This option may not be changed with the 'configure'
// widget command.
//
// # Toplevel(Colormap(...))
//
// Specifies a colormap to use for the window.
// The value may be either 'new', in which case a new colormap is
// created for the window and its children, or the name of another
// window (which must be on the same screen and have the same visual
// as 'pathName'), in which case the new window will use the colormap
// from the specified window.
// If the '-colormap' option is not specified, the new window
// uses the default colormap of its screen.
// This option may not be changed with the 'configure'
// widget command.
func Colormap(value any) option {
	return colormapOption{value}
}

type columnsOption struct { v any }

func (o columnsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-columns %s`, optionString(o.v))
}


// # TTreeview(Columns(...))
//
// A list of column identifiers,
// specifying the number of columns and their names.
func Columns(value any) option {
	return columnsOption{value}
}


// See also [Event handlers]
//
// # Button(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.
//
// # Checkbutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Radiobutton(Command(...))
//
// Specifies a Tcl command to associate with the button.  This command
// is typically invoked when mouse button 1 is released over the button
// window.  The button's global variable ('-variable' option) will
// be updated before the command is invoked.
//
// # Scale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's
// value is changed via a widget command.
// The actual command consists
// of this option followed by a space and a real number indicating the
// new value of the scale.
//
// # Scrollbar(Command(...))
//
// Specifies the prefix of a Tcl command to invoke to change the view
// in the widget associated with the scrollbar.  When a user requests
// a view change by manipulating the scrollbar, a Tcl command is
// invoked.  The actual command consists of this option followed by
// additional information as described later.  This option almost always has
// a value such as '.t xview' or '.t yview', consisting of the
// name of a widget and either 'xview' (if the scrollbar is for
// horizontal scrolling) or 'yview' (for vertical scrolling).
// All scrollable widgets have 'xview' and 'yview' commands
// that take exactly the additional arguments appended by the scrollbar
// as described in 'SCROLLING COMMANDS' below.
//
// # Spinbox(Command(...))
//
// Specifies a Tcl command to invoke whenever a spinbutton is invoked.
// The command recognizes several percent substitutions: '%W' for
// the widget path, '%s' for the current value of the widget, and
// '%d' for the direction of the button pressed ('up' or 'down').
//
// # TButton(Command(...))
//
// A script to evaluate when the widget is invoked.
//
// # TCheckbutton(Command(...))
//
// A Tcl script to execute whenever the widget is invoked.
//
// # TRadiobutton(Command(...))
//
// A Tcl script to evaluate whenever the widget is invoked.
//
// # TScale(Command(...))
//
// Specifies the prefix of a Tcl command to invoke whenever the scale's value is
// changed via a widget command. The actual command consists of this option
// followed by a space and a real number indicating the new value of the scale.
//
// # TScrollbar(Command(...))
//
// A Tcl script prefix to evaluate
// to change the view in the widget associated with the scrollbar.
// Additional arguments are appended to the value of this option,
// as described in 'SCROLLING COMMANDS' below,
// whenever the user requests a view change by manipulating the scrollbar.
//
// # TSpinbox(Command(...))
//
// Specifies a Tcl command to be invoked whenever a spinbutton is invoked.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Command(args ...any) option {
	return newEventHandler("-command", args...)
}

type compoundOption struct { v any }

func (o compoundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-compound %s`, optionString(o.v))
}


// Specifies if the widget should display text and bitmaps/images at the
// same time, and if so, where the bitmap/image should be placed relative
// to the text.  Must be one of the values 'none', 'bottom',
// 'top', 'left', 'right', or 'center'.  For example, the
// (default) value 'none' specifies that the bitmap or image should
// (if defined) be displayed instead of the text, the value 'left'
// specifies that the bitmap or image should be displayed to the left of
// the text, and the value 'center' specifies that the bitmap or
// image should be displayed on top of the text.
//
// # TNotebook(Compound(...))
//
// Specifies how to display the image relative to the text,
// in the case both '-text' and '-image' are present.
// See 'label(n)' for legal values.
func Compound(value any) option {
	return compoundOption{value}
}

type confineOption struct { v any }

func (o confineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-confine %s`, optionString(o.v))
}


// # Canvas(Confine(...))
//
// Specifies a boolean value that indicates whether or not it should be
// allowable to set the canvas's view outside the region defined by the
// 'scrollRegion' argument.
// Defaults to true, which means that the view will
// be constrained within the scroll region.
func Confine(value any) option {
	return confineOption{value}
}

type containerOption struct { v any }

func (o containerOption) optionString(w *Window) string {
	return fmt.Sprintf(`-container %s`, optionString(o.v))
}


// # Frame(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
// Note that '-borderwidth', '-padx' and '-pady' are ignored when
// configured as a container since a container has no border.
//
// # Toplevel(Container(...))
//
// The value must be a boolean.  If true, it means that this window will
// be used as a container in which some other application will be embedded
// (for example, a Tk toplevel can be embedded using the '-use' option).
// The window will support the appropriate window manager protocols for
// things like geometry requests.  The window should not have any
// children of its own in this application.
// This option may not be changed with the 'configure'
// widget command.
func Container(value any) option {
	return containerOption{value}
}

type cursorOption struct { v any }

func (o cursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-cursor %s`, optionString(o.v))
}


// Specifies the mouse cursor to be used for the widget.
// The value may have any of the forms acceptable to 'Tk_GetCursor'.
// In addition, if an empty string is specified, it indicates that the
// widget should defer to its parent for cursor specification.
func Cursor(value any) option {
	return cursorOption{value}
}

type defaultOption struct { v any }

func (o defaultOption) optionString(w *Window) string {
	return fmt.Sprintf(`-default %s`, optionString(o.v))
}


// # Button(Default(...))
//
// Specifies one of three states for the default ring: 'normal',
// 'active', or 'disabled'.  In active state, the button is drawn
// with the platform specific appearance for a default button.  In normal
// state, the button is drawn with the platform specific appearance for a
// non-default button, leaving enough space to draw the default button
// appearance.  The normal and active states will result in buttons of
// the same size.  In disabled state, the button is drawn with the
// non-default button appearance without leaving space for the default
// appearance.  The disabled state may result in a smaller button than
// the active state.
//
// # TButton(Default(...))
//
// May be set to one of  'normal', 'active', or 'disabled'.
// In a dialog box, one button may be designated the
func Default(value any) option {
	return defaultOption{value}
}

type digitsOption struct { v any }

func (o digitsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-digits %s`, optionString(o.v))
}


// # Scale(Digits(...))
//
// An integer specifying how many significant digits should be retained
// when converting the value of the scale to a string.
// If the number is less than or equal to zero, then the scale picks
// the smallest value that guarantees that every possible slider
// position prints as a different string.
func Digits(value any) option {
	return digitsOption{value}
}

type directionOption struct { v any }

func (o directionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-direction %s`, optionString(o.v))
}


// # Menubutton(Direction(...))
//
// Specifies where the menu is going to be popup up. 'above' tries to
// pop the menu above the menubutton. 'below' tries to pop the menu
// below the menubutton. 'left' tries to pop the menu to the left of
// the menubutton. 'right' tries to pop the menu to the right of the
// menu button. 'flush' pops the menu directly over the menubutton.
// In the case of 'above' or 'below', the direction will be
// reversed if the menu would show offscreen.
//
// # TMenubutton(Direction(...))
//
// Specifies where the menu is to be popped up relative
// to the menubutton.
// One of: 'above', 'below', 'left', 'right',
// or 'flush'.  The default is 'below'.
// 'flush' pops the menu up directly over the menubutton.
func Direction(value any) option {
	return directionOption{value}
}

type disabledbackgroundOption struct { v any }

func (o disabledbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledbackground %s`, optionString(o.v))
}


// # Entry(Disabledbackground(...))
//
// Specifies the background color to use when the entry is disabled.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Disabledbackground(...))
//
// Specifies the background color to use when the spinbox is disabled.  If
// this option is the empty string, the normal background color is used.
func Disabledbackground(value any) option {
	return disabledbackgroundOption{value}
}

type disabledforegroundOption struct { v any }

func (o disabledforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-disabledforeground %s`, optionString(o.v))
}


// Specifies foreground color to use when drawing a disabled element.
// If the option is specified as an empty string (which is typically the
// case on monochrome displays), disabled elements are drawn with the
// normal foreground color but they are dimmed by drawing them
// with a stippled fill pattern.
//
// # Entry(Disabledforeground(...))
//
// Specifies the foreground color to use when the entry is disabled.  If
// this option is the empty string, the normal foreground color is used.
//
// # Spinbox(Disabledforeground(...))
//
// Specifies the foreground color to use when the spinbox is disabled.  If
// this option is the empty string, the normal foreground color is used.
func Disabledforeground(value any) option {
	return disabledforegroundOption{value}
}

type displaycolumnsOption struct { v any }

func (o displaycolumnsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-displaycolumns %s`, optionString(o.v))
}


// # TTreeview(Displaycolumns(...))
//
// A list of column identifiers
// (either symbolic names or integer indices)
// specifying which data columns are displayed
// and the order in which they appear,
// or the string '#all\fP.
// If set to '#all\fP (the default),
// all columns are shown in the order given.
func Displaycolumns(value any) option {
	return displaycolumnsOption{value}
}

type elementborderwidthOption struct { v any }

func (o elementborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-elementborderwidth %s`, optionString(o.v))
}


// # Scrollbar(Elementborderwidth(...))
//
// Specifies the width of borders drawn around the internal elements
// of the scrollbar (the two arrows and the slider).  The value may
// have any of the forms acceptable to 'Tk_GetPixels'.
// If this value is less than zero, the value of the '-borderwidth'
// option is used in its place.
func Elementborderwidth(value any) option {
	return elementborderwidthOption{value}
}

type endlineOption struct { v any }

func (o endlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-endline %s`, optionString(o.v))
}


// # Text(Endline(...))
//
// Specifies an integer line index representing the line of the underlying
// textual data store that should be just after the last line contained in
// the widget. This allows a text widget to reflect only a portion of a
// larger piece of text. Instead of an integer, the empty string can be
// provided to this configuration option, which will configure the widget
// to end at the very last line in the textual data store.
func Endline(value any) option {
	return endlineOption{value}
}

type exportselectionOption struct { v any }

func (o exportselectionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-exportselection %s`, optionString(o.v))
}


// Specifies whether or not a selection in the widget should also be
// the X selection.
// The value may have any of the forms accepted by 'Tcl_GetBoolean',
// such as 'true', 'false', '0', '1', 'yes', or 'no'.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.  The default is usually for widgets
// to export selections.
//
// # TCombobox(Exportselection(...))
//
// Boolean value.
// If set, the widget selection is linked to the X selection.
//
// # TEntry(Exportselection(...))
//
// A boolean value specifying whether or not
// a selection in the widget should be linked to the X selection.
// If the selection is exported, then selecting in the widget deselects
// the current X selection, selecting outside the widget deselects any
// widget selection, and the widget will respond to selection retrieval
// requests when it has a selection.
func Exportselection(value any) option {
	return exportselectionOption{value}
}

type fgOption struct { v any }

func (o fgOption) optionString(w *Window) string {
	return fmt.Sprintf(`-fg %s`, optionString(o.v))
}


// Specifies the normal foreground color to use when displaying the widget.
func Fg(value any) option {
	return fgOption{value}
}

type fontOption struct { v any }

func (o fontOption) optionString(w *Window) string {
	return fmt.Sprintf(`-font %s`, optionString(o.v))
}


// Specifies the font to use when drawing text inside the widget.
// The value may have any of the forms described in the 'font' manual
// page under 'FONT DESCRIPTION'.
func Font(value any) option {
	return fontOption{value}
}

type foregroundOption struct { v any }

func (o foregroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-foreground %s`, optionString(o.v))
}


// Specifies the normal foreground color to use when displaying the widget.
func Foreground(value any) option {
	return foregroundOption{value}
}

type formatOption struct { v any }

func (o formatOption) optionString(w *Window) string {
	return fmt.Sprintf(`-format %s`, optionString(o.v))
}


// # Spinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
//
// # TSpinbox(Format(...))
//
// Specifies an alternate format to use when setting the string value
// when using the '-from' and '-to' range.
// This must be a format specifier of the form '%<pad>.<pad>f',
// as it will format a floating-point number.
func Format(value any) option {
	return formatOption{value}
}

type fromOption struct { v any }

func (o fromOption) optionString(w *Window) string {
	return fmt.Sprintf(`-from %s`, optionString(o.v))
}


// # Scale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # Spinbox(From(...))
//
// A floating-point value corresponding to the lowest value for a spinbox, to
// be used in conjunction with '-to' and '-increment'.  When all
// are specified correctly, the spinbox will use these values to control its
// contents. If this value is greater than the '-to' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # TScale(From(...))
//
// A real value corresponding to the left or top end of the scale.
//
// # TSpinbox(From(...))
//
// A floating-point value specifying the lowest value for the spinbox. This is
// used in conjunction with '-to' and '-increment' to set a numerical
// range.
func From(value any) option {
	return fromOption{value}
}

type handlepadOption struct { v any }

func (o handlepadOption) optionString(w *Window) string {
	return fmt.Sprintf(`-handlepad %s`, optionString(o.v))
}


// # Panedwindow(Handlepad(...))
//
// When sash handles are drawn, specifies the distance from the top or
// left end of the sash (depending on the orientation of the widget) at
// which to draw the handle.  May be any value accepted by 'Tk_GetPixels'.
func Handlepad(value any) option {
	return handlepadOption{value}
}

type handlesizeOption struct { v any }

func (o handlesizeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-handlesize %s`, optionString(o.v))
}


// # Panedwindow(Handlesize(...))
//
// Specifies the side length of a sash handle.  Handles are always
// drawn as squares.  May be any value accepted by 'Tk_GetPixels'.
func Handlesize(value any) option {
	return handlesizeOption{value}
}

type heightOption struct { v any }

func (o heightOption) optionString(w *Window) string {
	return fmt.Sprintf(`-height %s`, optionString(o.v))
}


// # Button(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Canvas(Height(...))
//
// Specifies a desired window height that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Checkbutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Frame(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total height of the frame, any '-borderwidth' or similar is
// not added.  Normally '-height' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the height of the frame.
//
// # Label(Height(...))
//
// Specifies a desired height for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the label's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Labelframe(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Listbox(Height(...))
//
// Specifies the desired height for the window, in lines.
// If zero or less, then the desired height for the window is made just
// large enough to hold all the elements in the listbox.
//
// # Menubutton(Height(...))
//
// Specifies a desired height for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the menubutton's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Panedwindow(Height(...))
//
// Specifies a desired height for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made high enough to allow all contained widgets to have their natural height.
//
// # Radiobutton(Height(...))
//
// Specifies a desired height for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in lines of text.
// If this option is not specified, the button's desired height is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Text(Height(...))
//
// Specifies the desired height for the window, in units of characters in the
// font given by the '-font' option. Must be at least one.
//
// # Toplevel(Height(...))
//
// Specifies the desired height for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # TCombobox(Height(...))
//
// Specifies the height of the pop-down listbox, in rows.
//
// # TFrame(Height(...))
//
// If specified, the widget's requested height in pixels.
//
// # TLabelframe(Height(...))
//
// If specified, the widget's requested height in pixels.
// (See 'ttk::frame(n)' for further notes on '-width' and
// '-height').
//
// # TNotebook(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the pane area
// (not including internal padding or tabs).
// Otherwise, the maximum height of all panes is used.
//
// # TPanedwindow(Height(...))
//
// If present and greater than zero,
// specifies the desired height of the widget in pixels.
// Otherwise, the requested height is determined by the height
// of the managed windows.
//
// # TTreeview(Height(...))
//
// Specifies the number of rows which should be visible.
// Note that
// the requested width is determined from the sum of the column widths.
func Height(value any) option {
	return heightOption{value}
}

type highlightbackgroundOption struct { v any }

func (o highlightbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-highlightbackground %s`, optionString(o.v))
}


// Specifies the color to display in the traversal highlight region when
// the widget does not have the input focus.
func Highlightbackground(value any) option {
	return highlightbackgroundOption{value}
}

type highlightcolorOption struct { v any }

func (o highlightcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-highlightcolor %s`, optionString(o.v))
}


// Specifies the color to use for the traversal highlight rectangle that is
// drawn around the widget when it has the input focus.
func Highlightcolor(value any) option {
	return highlightcolorOption{value}
}

type highlightthicknessOption struct { v any }

func (o highlightthicknessOption) optionString(w *Window) string {
	return fmt.Sprintf(`-highlightthickness %s`, optionString(o.v))
}


// Specifies a non-negative value indicating the width of the highlight
// rectangle to draw around the outside of the widget when it has the
// input focus.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If the value is zero, no focus highlight is drawn around the widget.
func Highlightthickness(value any) option {
	return highlightthicknessOption{value}
}

type imageOption struct { v any }

func (o imageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-image %s`, optionString(o.v))
}


// Specifies an image to display in the widget, which must have been
// created with the 'image create' command.
// Typically, if the '-image' option is specified then it overrides other
// options that specify a bitmap or textual value to display in the
// widget, though this is controlled by the '-compound' option;
// the '-image' option may be reset to an empty string to re-enable
// a bitmap or text display.
//
// # TNotebook(Image(...))
//
// Specifies an image to display in the tab.
// See 'ttk_widget(n)' for details.
func Image(value any) option {
	return imageOption{value}
}

type inactiveselectbackgroundOption struct { v any }

func (o inactiveselectbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-inactiveselectbackground %s`, optionString(o.v))
}


// # Text(Inactiveselectbackground(...))
//
// Specifies the colour to use for the selection (the 'sel' tag) when the
// window does not have the input focus. If empty, '{}', then no selection is
// shown when the window does not have the focus.
func Inactiveselectbackground(value any) option {
	return inactiveselectbackgroundOption{value}
}

type incrementOption struct { v any }

func (o incrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-increment %s`, optionString(o.v))
}


// # Spinbox(Increment(...))
//
// A floating-point value specifying the increment.  When used with
// '-from' and '-to', the value in the widget will be adjusted by
// '-increment' when a spin button is pressed (up adds the value,
// down subtracts the value).
//
// # TSpinbox(Increment(...))
//
// A floating-point value specifying the change in value to be applied each
// time one of the widget spin buttons is pressed. The up button applies a
// positive increment, the down button applies a negative increment.
func Increment(value any) option {
	return incrementOption{value}
}

type indicatoronOption struct { v any }

func (o indicatoronOption) optionString(w *Window) string {
	return fmt.Sprintf(`-indicatoron %s`, optionString(o.v))
}


// # Checkbutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
//
// # Menubutton(Indicatoron(...))
//
// The value must be a proper boolean value.  If it is true then
// a small indicator rectangle will be displayed on the right side
// of the menubutton and the default menu bindings will treat this
// as an option menubutton.  If false then no indicator will be
// displayed.
//
// # Radiobutton(Indicatoron(...))
//
// Specifies whether or not the indicator should be drawn.  Must be a
// proper boolean value.  If false, the '-relief' option is
// ignored and the widget's relief is always sunken if the widget is
// selected and raised otherwise.
func Indicatoron(value any) option {
	return indicatoronOption{value}
}

type insertbackgroundOption struct { v any }

func (o insertbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertbackground %s`, optionString(o.v))
}


// Specifies the color to use as background in the area covered by the
// insertion cursor.  This color will normally override either the normal
// background for the widget (or the selection background if the insertion
// cursor happens to fall in the selection).
func Insertbackground(value any) option {
	return insertbackgroundOption{value}
}

type insertborderwidthOption struct { v any }

func (o insertborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertborderwidth %s`, optionString(o.v))
}


// Specifies a non-negative value indicating the width
// of the 3-D border to draw around the insertion cursor.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
func Insertborderwidth(value any) option {
	return insertborderwidthOption{value}
}

type insertofftimeOption struct { v any }

func (o insertofftimeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertofftime %s`, optionString(o.v))
}


// Specifies a non-negative integer value indicating the number of
// milliseconds the insertion cursor should remain
func Insertofftime(value any) option {
	return insertofftimeOption{value}
}

type insertontimeOption struct { v any }

func (o insertontimeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertontime %s`, optionString(o.v))
}


// Specifies a non-negative integer value indicating the number of
// milliseconds the insertion cursor should remain
func Insertontime(value any) option {
	return insertontimeOption{value}
}

type insertunfocussedOption struct { v any }

func (o insertunfocussedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertunfocussed %s`, optionString(o.v))
}


// # Text(Insertunfocussed(...))
//
// 8.6
func Insertunfocussed(value any) option {
	return insertunfocussedOption{value}
}

type insertwidthOption struct { v any }

func (o insertwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-insertwidth %s`, optionString(o.v))
}


// Specifies a  value indicating the total width of the insertion cursor.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If a border has been specified for the insertion
// cursor (using the '-insertborderwidth' option), the border
// will be drawn inside the width specified by the '-insertwidth'
// option.
func Insertwidth(value any) option {
	return insertwidthOption{value}
}


// See also [Event handlers]
//
// # Entry(Invalidcommand(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Spinbox(Invalidcommand(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// # TEntry(Invalidcommand(...))
//
// A script template to evaluate whenever the '-validatecommand' returns 0.
// See 'VALIDATION' below for more information.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Invalidcommand(args ...any) option {
	return newEventHandler("-invalidcommand", args...)
}


// See also [Event handlers]
//
// # Entry(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.
// Setting it to {} disables this feature (the default).  The best use
// of this option is to set it to 'bell'.  See 'VALIDATION'
// below for more information.
//
// # Spinbox(Invcmd(...))
//
// Specifies a script to eval when '-validatecommand' returns 0.  Setting
// it to an empty string disables this feature (the default).  The best use of
// this option is to set it to 'bell'.  See 'VALIDATION' below for
// more information.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Invcmd(args ...any) option {
	return newEventHandler("-invcmd", args...)
}

type jumpOption struct { v any }

func (o jumpOption) optionString(w *Window) string {
	return fmt.Sprintf(`-jump %s`, optionString(o.v))
}


// For widgets with a slider that can be dragged to adjust a value,
// such as scrollbars, this option determines when
// notifications are made about changes in the value.
// The option's value must be a boolean of the form accepted by
// 'Tcl_GetBoolean'.
// If the value is false, updates are made continuously as the
// slider is dragged.
// If the value is true, updates are delayed until the mouse button
// is released to end the drag;  at that point a single notification
// is made (the value
func Jump(value any) option {
	return jumpOption{value}
}

type justifyOption struct { v any }

func (o justifyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-justify %s`, optionString(o.v))
}


// When there are multiple lines of text displayed in a widget, this
// option determines how the lines line up with each other.
// Must be one of 'left', 'center', or 'right'.
// 'Left' means that the lines' left edges all line up, 'center'
// means that the lines' centers are aligned, and 'right' means
// that the lines' right edges line up.
//
// # Message(Justify(...))
//
// Specifies how to justify lines of text.
// Must be one of 'left', 'center', or 'right'.  Defaults
// to 'left'.
// This option works together with the '-anchor', '-aspect',
// '-padx', '-pady', and '-width' options to provide a variety
// of arrangements of the text within the window.
// The '-aspect' and '-width' options determine the amount of
// screen space needed to display the text.
// The '-anchor', '-padx', and '-pady' options determine where this
// rectangular area is displayed within the widget's window, and the
// '-justify' option determines how each line is displayed within that
// rectangular region.
// For example, suppose '-anchor' is 'e' and '-justify' is
// 'left', and that the message window is much larger than needed
// for the text.
// The text will be displayed so that the left edges of all the lines
// line up and the right edge of the longest line is '-padx' from
// the right side of the window;  the entire text block will be centered
// in the vertical span of the window.
//
// # TCombobox(Justify(...))
//
// Specifies how the text is aligned within the widget.
// Must be one of 'left', 'center', or 'right'.
//
// # TEntry(Justify(...))
//
// Specifies how the text is aligned within the entry widget.
// One of 'left', 'center', or 'right'.
func Justify(value any) option {
	return justifyOption{value}
}

type labelOption struct { v any }

func (o labelOption) optionString(w *Window) string {
	return fmt.Sprintf(`-label %s`, optionString(o.v))
}


// # Scale(Lbl(...))
//
// A string to display as a label for the scale.  For
// vertical scales the label is displayed just to the right of the
// top end of the scale.  For horizontal scales the label is displayed
// just above the left end of the scale.  If the option is specified
// as an empty string, no label is displayed.
func Lbl(value any) option {
	return labelOption{value}
}

type labelanchorOption struct { v any }

func (o labelanchorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-labelanchor %s`, optionString(o.v))
}


// # Labelframe(Labelanchor(...))
//
// Specifies where to place the label. A label is only displayed if the
// '-text' option is not the empty string.
// Valid values for this option are (listing them clockwise)
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is 'nw'.
//
// # TLabelframe(Labelanchor(...))
//
// Specifies where to place the label.
// Allowed values are (clockwise from the top upper left corner):
// 'nw', 'n', 'ne', 'en', 'e', 'es',
// 'se', 's','sw', 'ws', 'w' and 'wn'.
// The default value is theme-dependent.
func Labelanchor(value any) option {
	return labelanchorOption{value}
}

type labelwidgetOption struct { v any }

func (o labelwidgetOption) optionString(w *Window) string {
	return fmt.Sprintf(`-labelwidget %s`, optionString(o.v))
}


// # Labelframe(Labelwidget(...))
//
// Specifies a widget to use as label. This overrides any '-text'
// option. The widget must exist before being used as '-labelwidget'
// and if it is not a descendant of this window, it will be raised
// above it in the stacking order.
//
// # TLabelframe(Labelwidget(...))
//
// The name of a widget to use for the label.
// If set, overrides the '-text' option.
// The '-labelwidget' must be a child of the 'labelframe' widget
// or one of the 'labelframe''s ancestors, and must belong to the
// same top-level widget as the 'labelframe'.
func Labelwidget(value any) option {
	return labelwidgetOption{value}
}

type lengthOption struct { v any }

func (o lengthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-length %s`, optionString(o.v))
}


// # Scale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's height;  for horizontal scales
// it is the scale's width.
//
// # TProgressbar(Length(...))
//
// Specifies the length of the long axis of the progress bar
// (width if horizontal, height if vertical). The value may have any of the forms
// acceptable to 'Tk_GetPixels'.
//
// # TScale(Length(...))
//
// Specifies the desired long dimension of the scale in screen units (i.e. any of
// the forms acceptable to 'Tk_GetPixels'). For vertical scales this is the
// scale's height; for horizontal scales it is the scale's width.
func Length(value any) option {
	return lengthOption{value}
}

type listvariableOption struct { v any }

func (o listvariableOption) optionString(w *Window) string {
	return fmt.Sprintf(`-listvariable %s`, optionString(o.v))
}


// # Listbox(Listvariable(...))
//
// Specifies the name of a global variable.  The value of the variable is a list to
// be displayed inside the widget; if the variable value changes then the
// widget will automatically update itself to reflect the new value.  Attempts
// to assign a variable with an invalid list value to '-listvariable'
// will cause an error.  Attempts to unset a variable in use as a
// '-listvariable' will fail but will not generate an error.
func Listvariable(value any) option {
	return listvariableOption{value}
}

type maximumOption struct { v any }

func (o maximumOption) optionString(w *Window) string {
	return fmt.Sprintf(`-maximum %s`, optionString(o.v))
}


// # TProgressbar(Maximum(...))
//
// A floating point number specifying the maximum '-value'.
// Defaults to 100.
func Maximum(value any) option {
	return maximumOption{value}
}

type maxundoOption struct { v any }

func (o maxundoOption) optionString(w *Window) string {
	return fmt.Sprintf(`-maxundo %s`, optionString(o.v))
}


// # Text(Maxundo(...))
//
// Specifies the maximum number of compound undo actions on the undo stack. A
// zero or a negative value imply an unlimited undo stack.
func Maxundo(value any) option {
	return maxundoOption{value}
}

type menuOption struct { v any }

func (o menuOption) optionString(w *Window) string {
	return fmt.Sprintf(`-menu %s`, optionString(o.v))
}


// # Menubutton(Mnu(...))
//
// Specifies the path name of the menu associated with this menubutton.
// The menu must be a child of the menubutton.
//
// # Toplevel(Mnu(...))
//
// Specifies a menu widget to be used as a menubar. On the Macintosh, the
// menubar will be displayed across the top of the main monitor. On
// Microsoft Windows and all UNIX platforms, the menu will appear across
// the toplevel window as part of the window dressing maintained by the
// window manager.
//
// # TMenubutton(Mnu(...))
//
// Specifies the path name of the menu associated with the menubutton.
// To be on the safe side, the menu ought to be a direct child of the
// menubutton.
func Mnu(value any) option {
	return menuOption{value}
}

type modeOption struct { v any }

func (o modeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-mode %s`, optionString(o.v))
}


// # TProgressbar(Mode(...))
//
// One of 'determinate' or 'indeterminate'.
func Mode(value any) option {
	return modeOption{value}
}

type offreliefOption struct { v any }

func (o offreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-offrelief %s`, optionString(o.v))
}


// # Checkbutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
//
// # Radiobutton(Offrelief(...))
//
// Specifies the relief for the checkbutton when the indicator is not drawn and
// the checkbutton is off.  The default value is
func Offrelief(value any) option {
	return offreliefOption{value}
}

type offvalueOption struct { v any }

func (o offvalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-offvalue %s`, optionString(o.v))
}


// # Checkbutton(Offvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is deselected.  Defaults to
//
// # TCheckbutton(Offvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is deselected.  Defaults to '0'.
func Offvalue(value any) option {
	return offvalueOption{value}
}

type onvalueOption struct { v any }

func (o onvalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-onvalue %s`, optionString(o.v))
}


// # Checkbutton(Onvalue(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.  Defaults to
//
// # TCheckbutton(Onvalue(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.  Defaults to '1'.
func Onvalue(value any) option {
	return onvalueOption{value}
}

type opaqueresizeOption struct { v any }

func (o opaqueresizeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-opaqueresize %s`, optionString(o.v))
}


// # Panedwindow(Opaqueresize(...))
//
// Specifies whether panes should be resized as a sash is moved (true),
// or if resizing should be deferred until the sash is placed (false).
// In the latter case, a
func Opaqueresize(value any) option {
	return opaqueresizeOption{value}
}

type orientOption struct { v any }

func (o orientOption) optionString(w *Window) string {
	return fmt.Sprintf(`-orient %s`, optionString(o.v))
}


// For widgets that can lay themselves out with either a horizontal
// or vertical orientation, such as scrollbars, this option specifies
// which orientation should be used.  Must be either 'horizontal'
// or 'vertical' or an abbreviation of one of these.
//
// # TPanedwindow(Orient(...))
//
// Specifies the orientation of the window.
// If 'vertical', subpanes are stacked top-to-bottom;
// if 'horizontal', subpanes are stacked left-to-right.
//
// # TProgressbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the progress bar.
//
// # TScale(Orient(...))
//
// Specifies which orientation whether the widget should be laid out horizontally
// or vertically. Must be either 'horizontal' or 'vertical' or an
// abbreviation of one of these.
//
// # TScrollbar(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the scrollbar.
//
// # TSeparator(Orient(...))
//
// One of 'horizontal' or 'vertical'.
// Specifies the orientation of the separator.
func Orient(value any) option {
	return orientOption{value}
}

type overreliefOption struct { v any }

func (o overreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-overrelief %s`, optionString(o.v))
}


// # Button(Overrelief(...))
//
// Specifies an alternative relief for the button, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the button.
// The empty string is the default value.
//
// # Checkbutton(Overrelief(...))
//
// Specifies an alternative relief for the checkbutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the checkbutton.
// The empty string is the default value.
//
// # Radiobutton(Overrelief(...))
//
// Specifies an alternative relief for the radiobutton, to be used when the
// mouse cursor is over the widget.  This option can be used to make
// toolbar buttons, by configuring '-relief flat -overrelief
// raised'.  If the value of this option is the empty string, then no
// alternative relief is used when the mouse cursor is over the radiobutton.
// The empty string is the default value.
func Overrelief(value any) option {
	return overreliefOption{value}
}

type paddingOption struct { v any }

func (o paddingOption) optionString(w *Window) string {
	return fmt.Sprintf(`-padding %s`, optionString(o.v))
}


// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add around the outside
// of the notebook.
// The padding is a list of up to four length specifications
// 'left top right bottom'.
// If fewer than four elements are specified,
// 'bottom' defaults to 'top',
// 'right' defaults to 'left', and
// 'top' defaults to 'left'.
// In other words, a list of three numbers specify the left, vertical, and right
// padding; a list of two numbers specify the horizontal and the vertical padding;
// a single number specifies the same padding all the way around the widget.
//
// # TNotebook(Padding(...))
//
// Specifies the amount of extra space to add between the notebook and this pane.
// Syntax is the same as for the widget '-padding' option.
func Padding(value any) option {
	return paddingOption{value}
}

type padxOption struct { v any }

func (o padxOption) optionString(w *Window) string {
	return fmt.Sprintf(`-padx %s`, optionString(o.v))
}


// Specifies a non-negative value indicating how much extra space
// to request for the widget in the X-direction.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// When computing how large a window it needs, the widget will
// add this amount to the width it would normally need (as determined
// by the width of the things displayed in the widget);  if the geometry
// manager can satisfy this request, the widget will end up with extra
// internal space to the left and/or right of what it displays inside.
// Most widgets only use this option for padding text:  if they are
// displaying a bitmap or image, then they usually ignore padding
// options.
func Padx(value any) option {
	return padxOption{value}
}

type padyOption struct { v any }

func (o padyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-pady %s`, optionString(o.v))
}


// Specifies a non-negative value indicating how much extra space
// to request for the widget in the Y-direction.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// When computing how large a window it needs, the widget will add
// this amount to the height it would normally need (as determined by
// the height of the things displayed in the widget);  if the geometry
// manager can satisfy this request, the widget will end up with extra
// internal space above and/or below what it displays inside.
// Most widgets only use this option for padding text:  if they are
// displaying a bitmap or image, then they usually ignore padding
// options.
func Pady(value any) option {
	return padyOption{value}
}

type phaseOption struct { v any }

func (o phaseOption) optionString(w *Window) string {
	return fmt.Sprintf(`-phase %s`, optionString(o.v))
}


// # TProgressbar(Phase(...))
//
// Read-only option.
// The widget periodically increments the value of this option
// whenever the '-value' is greater than 0 and,
// in 'determinate' mode, less than '-maximum'.
// This option may be used by the current theme
// to provide additional animation effects.
func Phase(value any) option {
	return phaseOption{value}
}

type placeholderOption struct { v any }

func (o placeholderOption) optionString(w *Window) string {
	return fmt.Sprintf(`-placeholder %s`, optionString(o.v))
}


// Specifies a help text string to display if no text is otherwise displayed,
// that is when the widget is empty. The placeholder text is displayed using
// the values of the '-font' and '-justify' options.
func Placeholder(value any) option {
	return placeholderOption{value}
}

type placeholderforegroundOption struct { v any }

func (o placeholderforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-placeholderforeground %s`, optionString(o.v))
}


// Specifies the foreground color to use when the placeholder text is
// displayed. The default color is platform-specific.
func Placeholderforeground(value any) option {
	return placeholderforegroundOption{value}
}


// See also [Event handlers]
//
// # Menu(Postcommand(...))
//
// If this option is specified then it provides a Tcl command to execute
// each time the menu is posted.  The command is invoked by the 'post'
// widget command before posting the menu. Note that in Tk 8.0 on Macintosh
// and Windows, all post-commands in a system of menus are executed before any
// of those menus are posted.
// This is due to the limitations in the individual platforms' menu managers.
//
// # TCombobox(Postcommand(...))
//
// A Tcl script to evaluate immediately before displaying the listbox.
// The '-postcommand' script may specify the '-values' to display.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Postcommand(args ...any) option {
	return newEventHandler("-postcommand", args...)
}

type proxybackgroundOption struct { v any }

func (o proxybackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-proxybackground %s`, optionString(o.v))
}


// # Panedwindow(Proxybackground(...))
//
// Background color to use when drawing the proxy. If an empty string, the
// value of the '-background' option will be used.
func Proxybackground(value any) option {
	return proxybackgroundOption{value}
}

type proxyborderwidthOption struct { v any }

func (o proxyborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-proxyborderwidth %s`, optionString(o.v))
}


// # Panedwindow(Proxyborderwidth(...))
//
// Specifies the borderwidth of the proxy. May be any value accepted by
// 'Tk_GetPixels'.
func Proxyborderwidth(value any) option {
	return proxyborderwidthOption{value}
}

type proxyreliefOption struct { v any }

func (o proxyreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-proxyrelief %s`, optionString(o.v))
}


// # Panedwindow(Proxyrelief(...))
//
// Relief to use when drawing the proxy. May be any of the standard Tk
// relief values. If an empty string, the value of the '-sashrelief'
// option will be used.
func Proxyrelief(value any) option {
	return proxyreliefOption{value}
}

type readonlybackgroundOption struct { v any }

func (o readonlybackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-readonlybackground %s`, optionString(o.v))
}


// # Entry(Readonlybackground(...))
//
// Specifies the background color to use when the entry is readonly.  If
// this option is the empty string, the normal background color is used.
//
// # Spinbox(Readonlybackground(...))
//
// Specifies the background color to use when the spinbox is readonly.  If
// this option is the empty string, the normal background color is used.
func Readonlybackground(value any) option {
	return readonlybackgroundOption{value}
}

type reliefOption struct { v any }

func (o reliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-relief %s`, optionString(o.v))
}


// Specifies the 3-D effect desired for the widget.  Acceptable
// values are 'raised', 'sunken', 'flat', 'ridge',
// 'solid', and 'groove'.
// The value
// indicates how the interior of the widget should appear relative
// to its exterior;  for example, 'raised' means the interior of
// the widget should appear to protrude from the screen, relative to
// the exterior of the widget.
//
// # TFrame(Relief(...))
//
// One of the standard Tk border styles:
// 'flat', 'groove', 'raised', 'ridge',
// 'solid', or 'sunken'.
// Defaults to 'flat'.
//
// # TLabel(Relief(...))
//
// \" Rewrite this:
func Relief(value any) option {
	return reliefOption{value}
}

type repeatdelayOption struct { v any }

func (o repeatdelayOption) optionString(w *Window) string {
	return fmt.Sprintf(`-repeatdelay %s`, optionString(o.v))
}


// Specifies the number of milliseconds a button or key must be held
// down before it begins to auto-repeat.  Used, for example, on the
// up- and down-arrows in scrollbars.
func Repeatdelay(value any) option {
	return repeatdelayOption{value}
}

type repeatintervalOption struct { v any }

func (o repeatintervalOption) optionString(w *Window) string {
	return fmt.Sprintf(`-repeatinterval %s`, optionString(o.v))
}


// Used in conjunction with '-repeatdelay':  once auto-repeat
// begins, this option determines the number of milliseconds between
// auto-repeats.
func Repeatinterval(value any) option {
	return repeatintervalOption{value}
}

type resolutionOption struct { v any }

func (o resolutionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-resolution %s`, optionString(o.v))
}


// # Scale(Resolution(...))
//
// A real value specifying the resolution for the scale.
// If this value is greater than zero then the scale's value will always be
// rounded to an even multiple of this value, as will
// the endpoints of the scale.  If the value is less than zero then no
// rounding occurs.  Defaults to 1 (i.e., the value will be integral).
func Resolution(value any) option {
	return resolutionOption{value}
}

type sashcursorOption struct { v any }

func (o sashcursorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashcursor %s`, optionString(o.v))
}


// # Panedwindow(Sashcursor(...))
//
// Mouse cursor to use when over a sash.  If null,
// 'sb_h_double_arrow' will be used for horizontal panedwindows, and
// 'sb_v_double_arrow' will be used for vertical panedwindows.
func Sashcursor(value any) option {
	return sashcursorOption{value}
}

type sashpadOption struct { v any }

func (o sashpadOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashpad %s`, optionString(o.v))
}


// # Panedwindow(Sashpad(...))
//
// Specifies the amount of padding to leave of each side of a sash.  May
// be any value accepted by 'Tk_GetPixels'.
func Sashpad(value any) option {
	return sashpadOption{value}
}

type sashreliefOption struct { v any }

func (o sashreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashrelief %s`, optionString(o.v))
}


// # Panedwindow(Sashrelief(...))
//
// Relief to use when drawing a sash.  May be any of the standard Tk
// relief values.
func Sashrelief(value any) option {
	return sashreliefOption{value}
}

type sashwidthOption struct { v any }

func (o sashwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sashwidth %s`, optionString(o.v))
}


// # Panedwindow(Sashwidth(...))
//
// Specifies the width of each sash.  May be any value accepted by
// 'Tk_GetPixels'.
func Sashwidth(value any) option {
	return sashwidthOption{value}
}

type screenOption struct { v any }

func (o screenOption) optionString(w *Window) string {
	return fmt.Sprintf(`-screen %s`, optionString(o.v))
}


// # Toplevel(Screen(...))
//
// Specifies the screen on which to place the new window.
// Any valid screen name may be used, even one associated with a
// different display.
// Defaults to the same screen as its parent.
// This option is special in that it may not be specified via the option
// database, and it may not be modified with the 'configure'
// widget command.
func Screen(value any) option {
	return screenOption{value}
}

type scrollregionOption struct { v any }

func (o scrollregionOption) optionString(w *Window) string {
	return fmt.Sprintf(`-scrollregion %s`, optionString(o.v))
}


// # Canvas(Scrollregion(...))
//
// Specifies a list with four coordinates describing the left, top, right, and
// bottom coordinates of a rectangular region.
// This region is used for scrolling purposes and is considered to be
// the boundary of the information in the canvas.
// Each of the coordinates may be specified
// in any of the forms given in the 'COORDINATES' section below.
func Scrollregion(value any) option {
	return scrollregionOption{value}
}

type selectbackgroundOption struct { v any }

func (o selectbackgroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectbackground %s`, optionString(o.v))
}


// Specifies the background color to use when displaying selected
// items.
func Selectbackground(value any) option {
	return selectbackgroundOption{value}
}

type selectborderwidthOption struct { v any }

func (o selectborderwidthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectborderwidth %s`, optionString(o.v))
}


// Specifies a non-negative value indicating the width
// of the 3-D border to draw around selected items.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
func Selectborderwidth(value any) option {
	return selectborderwidthOption{value}
}

type selectcolorOption struct { v any }

func (o selectcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectcolor %s`, optionString(o.v))
}


// # Checkbutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If 'indicatorOn' is false, this color is used as the background
// for the entire widget, in place of 'background' or 'activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
//
// # Menu(Selectcolor(...))
//
// For menu entries that are check buttons or radio buttons, this option
// specifies the color to display in the indicator when the check button
// or radio button is selected.
//
// # Radiobutton(Selectcolor(...))
//
// Specifies a background color to use when the button is selected.
// If 'indicatorOn' is true then the color is used as the background for
// the indicator regardless of the select state.
// If '-indicatoron' is false, this color is used as the background for the
// entire widget, in place of '-background' or '-activeBackground',
// whenever the widget is selected.
// If specified as an empty string then no special color is used for
// displaying when the widget is selected.
func Selectcolor(value any) option {
	return selectcolorOption{value}
}

type selectforegroundOption struct { v any }

func (o selectforegroundOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectforeground %s`, optionString(o.v))
}


// Specifies the foreground color to use when displaying selected
// items.
func Selectforeground(value any) option {
	return selectforegroundOption{value}
}

type selectimageOption struct { v any }

func (o selectimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectimage %s`, optionString(o.v))
}


// # Checkbutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Selectimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
func Selectimage(value any) option {
	return selectimageOption{value}
}

type selectmodeOption struct { v any }

func (o selectmodeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selectmode %s`, optionString(o.v))
}


// # Listbox(Selectmode(...))
//
// Specifies one of several styles for manipulating the selection.
// The value of the option may be arbitrary, but the default bindings
// expect it to be either 'single', 'browse', 'multiple',
// or 'extended';  the default value is 'browse'.
//
// # TTreeview(Selectmode(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'extended', 'browse', or 'none'.
func Selectmode(value any) option {
	return selectmodeOption{value}
}

type selecttypeOption struct { v any }

func (o selecttypeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-selecttype %s`, optionString(o.v))
}


// # TTreeview(Selecttype(...))
//
// Controls how the built-in class bindings manage the selection.
// One of 'item' or 'cell'.
func Selecttype(value any) option {
	return selecttypeOption{value}
}

type setgridOption struct { v any }

func (o setgridOption) optionString(w *Window) string {
	return fmt.Sprintf(`-setgrid %s`, optionString(o.v))
}


// Specifies a boolean value that determines whether this widget controls the
// resizing grid for its top-level window.
// This option is typically used in text widgets, where the information
// in the widget has a natural size (the size of a character) and it makes
// sense for the window's dimensions to be integral numbers of these units.
// These natural window sizes form a grid.
// If the '-setgrid' option is set to true then the widget will
// communicate with the window manager so that when the user interactively
// resizes the top-level window that contains the widget, the dimensions of
// the window will be displayed to the user in grid units and the window
// size will be constrained to integral numbers of grid units.
// See the section 'GRIDDED GEOMETRY MANAGEMENT' in the 'wm' manual
// entry for more details.
func Setgrid(value any) option {
	return setgridOption{value}
}

type showOption struct { v any }

func (o showOption) optionString(w *Window) string {
	return fmt.Sprintf(`-show %s`, optionString(o.v))
}


// # Entry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TEntry(Show(...))
//
// If this option is specified, then the true contents of the entry
// are not displayed in the window.
// Instead, each character in the entry's value will be displayed as
// the first character in the value of this option, such as
//
// # TTreeview(Show(...))
//
// A list containing zero or more of the following values, specifying
// which elements of the tree to display.
func Show(value any) option {
	return showOption{value}
}

type showhandleOption struct { v any }

func (o showhandleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-showhandle %s`, optionString(o.v))
}


// # Panedwindow(Showhandle(...))
//
// Specifies whether sash handles should be shown.  May be any valid Tcl
// boolean value.
func Showhandle(value any) option {
	return showhandleOption{value}
}

type showvalueOption struct { v any }

func (o showvalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-showvalue %s`, optionString(o.v))
}


// # Scale(Showvalue(...))
//
// Specifies a boolean value indicating whether or not the current
// value of the scale is to be displayed.
func Showvalue(value any) option {
	return showvalueOption{value}
}

type sliderlengthOption struct { v any }

func (o sliderlengthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sliderlength %s`, optionString(o.v))
}


// # Scale(Sliderlength(...))
//
// Specifies the size of the slider, measured in screen units along the slider's
// long dimension.  The value may be specified in any of the forms acceptable
// to 'Tk_GetPixels'.
func Sliderlength(value any) option {
	return sliderlengthOption{value}
}

type sliderreliefOption struct { v any }

func (o sliderreliefOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sliderrelief %s`, optionString(o.v))
}


// # Scale(Sliderrelief(...))
//
// Specifies the relief to use when drawing the slider, such as 'raised'
// or 'sunken'.
func Sliderrelief(value any) option {
	return sliderreliefOption{value}
}

type spacing1Option struct { v any }

func (o spacing1Option) optionString(w *Window) string {
	return fmt.Sprintf(`-spacing1 %s`, optionString(o.v))
}


// # Text(Spacing1(...))
//
// Requests additional space above each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the first line on the display. This option may be overridden with
// '-spacing1' options in tags.
func Spacing1(value any) option {
	return spacing1Option{value}
}

type spacing2Option struct { v any }

func (o spacing2Option) optionString(w *Window) string {
	return fmt.Sprintf(`-spacing2 %s`, optionString(o.v))
}


// # Text(Spacing2(...))
//
// For lines that wrap (so that they cover more than one line on the display)
// this option specifies additional space to provide between the display lines
// that represent a single line of text. The value may have any of the standard
// forms for screen distances. This option may be overridden with
// '-spacing2' options in tags.
func Spacing2(value any) option {
	return spacing2Option{value}
}

type spacing3Option struct { v any }

func (o spacing3Option) optionString(w *Window) string {
	return fmt.Sprintf(`-spacing3 %s`, optionString(o.v))
}


// # Text(Spacing3(...))
//
// Requests additional space below each text line in the widget, using any of the
// standard forms for screen distances. If a line wraps, this option only applies
// to the last line on the display. This option may be overridden with
// '-spacing3' options in tags.
func Spacing3(value any) option {
	return spacing3Option{value}
}

type startlineOption struct { v any }

func (o startlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-startline %s`, optionString(o.v))
}


// # Text(Startline(...))
//
// Specifies an integer line index representing the first line of the underlying
// textual data store that should be contained in the widget. This allows a text
// widget to reflect only a portion of a larger piece of text. Instead of an
// integer, the empty string can be provided to this configuration option, which
// will configure the widget to start at the very first line in the textual data
// store.
func Startline(value any) option {
	return startlineOption{value}
}

type stateOption struct { v any }

func (o stateOption) optionString(w *Window) string {
	return fmt.Sprintf(`-state %s`, optionString(o.v))
}


// # Button(State(...))
//
// Specifies one of three states for the button:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the button.  In active state
// the button is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the button
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Canvas(State(...))
//
// Modifies the default state of the canvas where 'state' may be set to
// one of: 'normal', 'disabled', or 'hidden'. Individual canvas
// objects all have their own state option which may override the default
// state. Many options can take separate specifications such that the
// appearance of the item can be different in different situations. The
// options that start with 'active' control the appearance when the mouse
// pointer is over it, while the option starting with 'disabled' controls
// the appearance when the state is disabled. Canvas items which are
// 'disabled' will not react to canvas bindings.
//
// # Checkbutton(State(...))
//
// Specifies one of three states for the checkbutton:  'normal', 'active',
// or 'disabled'.  In normal state the checkbutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the checkbutton.  In active state
// the checkbutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the checkbutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the checkbutton is displayed.
//
// # Entry(State(...))
//
// Specifies one of three states for the entry:  'normal',
// 'disabled', or 'readonly'.  If the entry is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the entry is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the entry may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Label(State(...))
//
// Specifies one of three states for the label:  'normal', 'active',
// or 'disabled'.  In normal state the button is displayed using the
// '-foreground' and '-background' options.  In active state
// the label is displayed using the '-activeforeground' and
// '-activebackground' options.  In the disabled state the
// '-disabledforeground' and '-background' options determine how
// the button is displayed.
//
// # Listbox(State(...))
//
// Specifies one of two states for the listbox:  'normal' or 'disabled'.
// If the listbox is disabled then items may not be inserted or deleted,
// items are drawn in the '-disabledforeground' color, and selection
// cannot be modified and is not shown (though selection information is retained).
//
// # Menubutton(State(...))
//
// Specifies one of three states for the menubutton:  'normal', 'active',
// or 'disabled'.  In normal state the menubutton is displayed using the
// 'foreground' and 'background' options.  The active state is
// typically used when the pointer is over the menubutton.  In active state
// the menubutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the menubutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the button is displayed.
//
// # Radiobutton(State(...))
//
// Specifies one of three states for the radiobutton:  'normal', 'active',
// or 'disabled'.  In normal state the radiobutton is displayed using the
// '-foreground' and '-background' options.  The active state is
// typically used when the pointer is over the radiobutton.  In active state
// the radiobutton is displayed using the '-activeforeground' and
// '-activebackground' options.  Disabled state means that the radiobutton
// should be insensitive:  the default bindings will refuse to activate
// the widget and will ignore mouse button presses.
// In this state the '-disabledforeground' and
// '-background' options determine how the radiobutton is displayed.
//
// # Scale(State(...))
//
// Specifies one of three states for the scale:  'normal',
// 'active', or 'disabled'.
// If the scale is disabled then the value may not be changed and the scale
// will not activate.
// If the scale is active, the slider is displayed using the color
// specified by the '-activebackground' option.
//
// # Spinbox(State(...))
//
// Specifies one of three states for the spinbox:  'normal',
// 'disabled', or 'readonly'.  If the spinbox is readonly, then the
// value may not be changed using widget commands and no insertion cursor
// will be displayed, even if the input focus is in the widget; the
// contents of the widget may still be selected.  If the spinbox is
// disabled, the value may not be changed, no insertion cursor will be
// displayed, the contents will not be selectable, and the spinbox may
// be displayed in a different color, depending on the values of the
// '-disabledforeground' and '-disabledbackground' options.
//
// # Text(State(...))
//
// Specifies one of two states for the text: 'normal' or 'disabled'. If
// the text is disabled then characters may not be inserted or deleted and no
// insertion cursor will be displayed, even if the input focus is in the widget.
//
// # TCombobox(State(...))
//
// One of 'normal', 'readonly', or 'disabled'.
// In the 'readonly' state,
// the value may not be edited directly, and
// the user can only select one of the '-values' from the
// dropdown list.
// In the 'normal' state,
// the text field is directly editable.
// In the 'disabled' state, no interaction is possible.
//
// # TEntry(State(...))
//
// Compatibility option; see 'ttk::widget(n)' for details.
// Specifies one of three states for the entry,
// 'normal', 'disabled', or 'readonly'.
// See 'WIDGET STATES', below.
//
// # TNotebook(State(...))
//
// Either 'normal', 'disabled' or 'hidden'.
// If 'disabled', then the tab is not selectable.
// If 'hidden', then the tab is not shown.
func State(value any) option {
	return stateOption{value}
}

type stickyOption struct { v any }

func (o stickyOption) optionString(w *Window) string {
	return fmt.Sprintf(`-sticky %s`, optionString(o.v))
}


// # TNotebook(Sticky(...))
//
// Specifies how the content window is positioned within the pane area.
// Value is a string containing zero or more of the characters
// 'n, s, e,' or 'w'.
// Each letter refers to a side (north, south, east, or west)
// that the content window will
func Sticky(value any) option {
	return stickyOption{value}
}

type stripedOption struct { v any }

func (o stripedOption) optionString(w *Window) string {
	return fmt.Sprintf(`-striped %s`, optionString(o.v))
}


// # TTreeview(Striped(...))
//
// Boolean specifying zebra striped item coloring.
// Note that
// striped items uses the '-stripedbackground' option if set by the theme or
// a tag. If not supported by the current theme, it will not show.
func Striped(value any) option {
	return stripedOption{value}
}

type tabsOption struct { v any }

func (o tabsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tabs %s`, optionString(o.v))
}


// # Text(Tabs(...))
//
// Specifies a set of tab stops for the window. The option's value consists of a
// list of screen distances giving the positions of the tab stops, each of which
// is a distance relative to the left edge of the widget (excluding borders,
// padding, etc). Each position may optionally be followed in the next list
// element by one of the keywords 'left', 'right', 'center', or
// 'numeric', which specifies how to justify text relative to the tab stop.
// 'Left' is the default; it causes the text following the tab character to
// be positioned with its left edge at the tab position. 'Right' means that
// the right edge of the text following the tab character is positioned at the
// tab position, and 'center' means that the text is centered at the tab
// position. 'Numeric' means that the decimal point in the text is positioned
// at the tab position; if there is no decimal point then the least significant
// digit of the number is positioned just to the left of the tab position; if
// there is no number in the text then the text is right-justified at the tab
// position. For example,
func Tabs(value any) option {
	return tabsOption{value}
}

type tabstyleOption struct { v any }

func (o tabstyleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tabstyle %s`, optionString(o.v))
}


// # Text(Tabstyle(...))
//
// Specifies how to interpret the relationship between tab stops on a line and
// tabs in the text of that line. The value must be 'tabular' (the default)
// or 'wordprocessor'. Note that tabs are interpreted as they are encountered
// in the text. If the tab style is 'tabular' then the 'n''th tab
// character in the line's text will be associated with the 'n''th tab stop
// defined for that line. If the tab character's x coordinate falls to the right
// of the 'n''th tab stop, then a gap of a single space will be inserted as a
// fallback. If the tab style is 'wordprocessor' then any tab character being
// laid out will use (and be defined by) the first tab stop to the right of the
// preceding characters already laid out on that line. The value of the
// '-tabstyle' option may be overridden by '-tabstyle' options in tags.
func Tabstyle(value any) option {
	return tabstyleOption{value}
}

type takefocusOption struct { v any }

func (o takefocusOption) optionString(w *Window) string {
	return fmt.Sprintf(`-takefocus %s`, optionString(o.v))
}


// Determines whether the window accepts the focus during keyboard
// traversal (e.g., Tab and Shift-Tab).
// Before setting the focus to a window, the traversal scripts
// consult the value of the '-takefocus' option.
// A value of '0' means that the window should be skipped entirely
// during keyboard traversal.
// '1' means that the window should receive the input
// focus as long as it is viewable (it and all of its ancestors are mapped).
// An empty value for the option means that the traversal scripts make
// the decision about whether or not to focus on the window:  the current
// algorithm is to skip the window if it is
// disabled, if it has no key bindings, or if it is not viewable.
// If the value has any other form, then the traversal scripts take
// the value, append the name of the window to it (with a separator space),
// and evaluate the resulting string as a Tcl script.
// The script must return '0', '1', or an empty string:  a
// '0' or '1' value specifies whether the window will receive
// the input focus, and an empty string results in the default decision
// described above.
// Note that this interpretation of the option is defined entirely by
// the Tcl scripts that implement traversal:  the widget implementations
// ignore the option entirely, so you can change its meaning if you
// redefine the keyboard traversal scripts.
func Takefocus(value any) option {
	return takefocusOption{value}
}

type tearoffOption struct { v any }

func (o tearoffOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tearoff %s`, optionString(o.v))
}


// # Menu(Tearoff(...))
//
// This option must have a proper boolean value (default is false),
// which specifies whether or not the menu should include a tear-off
// entry at the top.  If so, it will exist as entry 0 of the menu and
// the other entries will number starting at 1.  The default menu
// bindings arrange for the menu to be torn off when the tear-off entry
// is invoked.
// This option is ignored under Aqua/MacOS, where menus cannot
// be torn off.
func Tearoff(value any) option {
	return tearoffOption{value}
}


// See also [Event handlers]
//
// # Menu(Tearoffcommand(...))
//
// If this option has a non-empty value, then it specifies a Tcl command
// to invoke whenever the menu is torn off.  The actual command will
// consist of the value of this option, followed by a space, followed
// by the name of the menu window, followed by a space, followed by
// the name of the name of the torn off menu window.  For example, if
// the option's value is
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Tearoffcommand(args ...any) option {
	return newEventHandler("-tearoffcommand", args...)
}

type textOption struct { v any }

func (o textOption) optionString(w *Window) string {
	return fmt.Sprintf(`-text %s`, optionString(o.v))
}


// Specifies a string to be displayed inside the widget.  The way in which
// the string is displayed depends on the particular widget and may be
// determined by other options, such as '-anchor' or '-justify'.
//
// # TLabelframe(Txt(...))
//
// Specifies the text of the label.
//
// # TNotebook(Txt(...))
//
// Specifies a string to be displayed in the tab.
func Txt(value any) option {
	return textOption{value}
}


// See also [Event handlers]
//
// Specifies the name of a global variable.  The value of the variable is a text
// string to be displayed inside the widget;  if the variable value changes
// then the widget will automatically update itself to reflect the new value.
// The way in which the string is displayed in the widget depends on the
// particular widget and may be determined by other options, such as
// '-anchor' or '-justify'.
//
// # TCombobox(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the widget value.
// Whenever the variable changes value the widget value is updated,
// and vice versa.
//
// # TEntry(Textvariable(...))
//
// Specifies the name of a global variable whose value is linked
// to the entry widget's contents.
// Whenever the variable changes value, the widget's contents are updated,
// and vice versa.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Textvariable(args ...any) option {
	return newEventHandler("-textvariable", args...)
}

type tickintervalOption struct { v any }

func (o tickintervalOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tickinterval %s`, optionString(o.v))
}


// # Scale(Tickinterval(...))
//
// Must be a real value.
// Determines the spacing between numerical
// tick marks displayed below or to the left of the slider. The values will all
// be displayed with the same number of decimal places, which will be enough to
// ensure they are all accurate to within 20% of a tick interval.
// If 0, no tick marks will be displayed.
func Tickinterval(value any) option {
	return tickintervalOption{value}
}

type tileOption struct { v any }

func (o tileOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tile %s`, optionString(o.v))
}


// # Frame(Tile(...))
//
// "8.7, TIP262"
//
// # Toplevel(Tile(...))
//
// "8.7, TIP262"
func Tile(value any) option {
	return tileOption{value}
}

type titleOption struct { v any }

func (o titleOption) optionString(w *Window) string {
	return fmt.Sprintf(`-title %s`, optionString(o.v))
}


// # Menu(Title(...))
//
// The string will be used to title the window created when this menu is
// torn off. If the title is NULL, then the window will have the title
// of the menubutton or the text of the cascade item from which this menu
// was invoked.
func Title(value any) option {
	return titleOption{value}
}

type titlecolumnsOption struct { v any }

func (o titlecolumnsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-titlecolumns %s`, optionString(o.v))
}


// # TTreeview(Titlecolumns(...))
//
// Number of display columns at the left that should not be scrolled. The tree
// column counts, even if '-show tree' is not specified. Thus for value N of
// this option, column #N is the first one that is scrollable. Default is 0.
func Titlecolumns(value any) option {
	return titlecolumnsOption{value}
}

type titleitemsOption struct { v any }

func (o titleitemsOption) optionString(w *Window) string {
	return fmt.Sprintf(`-titleitems %s`, optionString(o.v))
}


// # TTreeview(Titleitems(...))
//
// Number of items at the top that should not be vertically scrolled. Default is 0.
func Titleitems(value any) option {
	return titleitemsOption{value}
}

type toOption struct { v any }

func (o toOption) optionString(w *Window) string {
	return fmt.Sprintf(`-to %s`, optionString(o.v))
}


// # Scale(To(...))
//
// Specifies a real value corresponding
// to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # Spinbox(To(...))
//
// A floating-point value corresponding to the highest value for the spinbox,
// to be used in conjunction with '-from' and '-increment'.  When
// all are specified correctly, the spinbox will use these values to control
// its contents. If this value is less than the '-from' option, then
// '-from' and '-to' values are automatically swapped.
// If '-values' is specified, it supersedes this option.
//
// # TScale(To(...))
//
// Specifies a real value corresponding to the right or bottom end of the scale.
// This value may be either less than or greater than the '-from' option.
//
// # TSpinbox(To(...))
//
// A floating-point value specifying the highest permissible value for the
// widget. See also '-from' and '-increment'.
// range.
func To(value any) option {
	return toOption{value}
}

type tristateimageOption struct { v any }

func (o tristateimageOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tristateimage %s`, optionString(o.v))
}


// # Checkbutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the checkbutton is in tri-state mode.
// This option is ignored unless the '-image' option has been
// specified.
//
// # Radiobutton(Tristateimage(...))
//
// Specifies an image to display (in place of the '-image' option)
// when the radiobutton is selected.
// This option is ignored unless the '-image' option has been
// specified.
func Tristateimage(value any) option {
	return tristateimageOption{value}
}

type tristatevalueOption struct { v any }

func (o tristatevalueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-tristatevalue %s`, optionString(o.v))
}


// # Checkbutton(Tristatevalue(...))
//
// Specifies the value that causes the checkbutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
//
// # Radiobutton(Tristatevalue(...))
//
// Specifies the value that causes the radiobutton to display the multi-value
// selection, also known as the tri-state mode.  Defaults to
func Tristatevalue(value any) option {
	return tristatevalueOption{value}
}

type troughcolorOption struct { v any }

func (o troughcolorOption) optionString(w *Window) string {
	return fmt.Sprintf(`-troughcolor %s`, optionString(o.v))
}


// Specifies the color to use for the rectangular trough areas
// in widgets such as scrollbars and scales.  This option is ignored for
// scrollbars on Windows (native widget does not recognize this option).
func Troughcolor(value any) option {
	return troughcolorOption{value}
}

type typeOption struct { v any }

func (o typeOption) optionString(w *Window) string {
	return fmt.Sprintf(`-type %s`, optionString(o.v))
}


// # Menu(Type(...))
//
// This option can be one of 'menubar', 'tearoff', or
// 'normal', and is set when the menu is created. While the string
// returned by the configuration database will change if this option is
// changed, this does not affect the menu widget's behavior. This is used
// by the cloning mechanism and is not normally set outside of the Tk
// library.
func Type(value any) option {
	return typeOption{value}
}

type underlineOption struct { v any }

func (o underlineOption) optionString(w *Window) string {
	return fmt.Sprintf(`-underline %s`, optionString(o.v))
}


// Specifies the integer index of a character to underline in the widget.
// This option is used by the default bindings to implement keyboard
// traversal for menu buttons and menu entries.
// 0 corresponds to the first character of the text displayed in the
// widget, 1 to the next character, and so on. 'end' corresponds to the
// last character, 'end'-1 to the before last character, and so on.
//
// # TLabelframe(Underline(...))
//
// If set, specifies the integer index (0-based) of a character to
// underline in the text string.
// The underlined character is used for mnemonic activation.
// Mnemonic activation for a 'ttk::labelframe'
// sets the keyboard focus to the first child of the 'ttk::labelframe' widget.
//
// # TNotebook(Underline(...))
//
// Specifies the integer index (0-based) of a character to underline
// in the text string.
// The underlined character is used for mnemonic activation
// if 'ttk::notebook::enableTraversal' is called.
func Underline(value any) option {
	return underlineOption{value}
}

type undoOption struct { v any }

func (o undoOption) optionString(w *Window) string {
	return fmt.Sprintf(`-undo %s`, optionString(o.v))
}


// # Text(Undo(...))
//
// Specifies a boolean that says whether the undo mechanism is active or not.
func Undo(value any) option {
	return undoOption{value}
}

type useOption struct { v any }

func (o useOption) optionString(w *Window) string {
	return fmt.Sprintf(`-use %s`, optionString(o.v))
}


// # Toplevel(Use(...))
//
// This option is used for embedding. If the value is not an empty string,
// it must be the window identifier of a container window, specified as
// a hexadecimal string like the ones returned by the 'winfo id'
// command. The toplevel widget will be created as a child of the given
// container instead of the root window for the screen.  If the container
// window is in a Tk application, it must be a frame or toplevel widget for
// which the '-container' option was specified.
// This option may not be changed with the 'configure'
// widget command.
func Use(value any) option {
	return useOption{value}
}

type validateOption struct { v any }

func (o validateOption) optionString(w *Window) string {
	return fmt.Sprintf(`-validate %s`, optionString(o.v))
}


// # Entry(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # Spinbox(Validate(...))
//
// Specifies the mode in which validation should operate: 'none',
// 'focus', 'focusin', 'focusout', 'key', or 'all'.
// It defaults to 'none'.  When you want validation, you must explicitly
// state which mode you wish to use.  See 'VALIDATION' below for more.
//
// # TEntry(Validate(...))
//
// Specifies the mode in which validation should operate:
// 'none', 'focus', 'focusin', 'focusout', 'key', or 'all'.
// Default is 'none', meaning that validation is disabled.
// See 'VALIDATION' below.
func Validate(value any) option {
	return validateOption{value}
}


// See also [Event handlers]
//
// # Entry(Validatecommand(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Validatecommand(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// # TEntry(Validatecommand(...))
//
// A script template to evaluate whenever validation is triggered.
// If set to the empty string (the default), validation is disabled.
// The script must return a boolean value.
// See 'VALIDATION' below.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Validatecommand(args ...any) option {
	return newEventHandler("-validatecommand", args...)
}

type valueOption struct { v any }

func (o valueOption) optionString(w *Window) string {
	return fmt.Sprintf(`-value %s`, optionString(o.v))
}


// # Radiobutton(Value(...))
//
// Specifies value to store in the button's associated variable whenever
// this button is selected.
//
// # TProgressbar(Value(...))
//
// The current value of the progress bar.
// In 'determinate' mode, this represents the amount of work completed.
// In 'indeterminate' mode, it is interpreted modulo '-maximum';
// that is, the progress bar completes one
//
// # TRadiobutton(Value(...))
//
// The value to store in the associated '-variable'
// when the widget is selected.
//
// # TScale(Value(...))
//
// Specifies the current floating-point value of the variable.
// If '-variable' is set to an existing variable, specifying '-value'
// has no effect (the variable value takes precedence).
func Value(value any) option {
	return valueOption{value}
}

type valuesOption struct { v any }

func (o valuesOption) optionString(w *Window) string {
	return fmt.Sprintf(`-values %s`, optionString(o.v))
}


// # Spinbox(Values(...))
//
// Must be a proper list value.  If specified, the spinbox will use these
// values as to control its contents, starting with the first value.  This
// option has precedence over the '-from' and '-to' range.
//
// # TCombobox(Values(...))
//
// Specifies the list of values to display in the drop-down listbox.
//
// # TSpinbox(Values(...))
//
// This must be a Tcl list of values. If this option is set then this will
// override any range set using the '-from', '-to' and
// '-increment' options. The widget will instead use the values
// specified beginning with the first value.
func Values(value any) option {
	return valuesOption{value}
}

type variableOption struct { v any }

func (o variableOption) optionString(w *Window) string {
	return fmt.Sprintf(`-variable %s`, optionString(o.v))
}


// # Checkbutton(Variable(...))
//
// Specifies the name of a global variable to set to indicate whether
// or not this button is selected.  Defaults to the name of the
// button within its parent (i.e. the last element of the button
// window's path name).
//
// # Radiobutton(Variable(...))
//
// Specifies the name of a global variable to set whenever this button is
// selected.  Changes in this variable also cause the button to select
// or deselect itself.
// Defaults to the value 'selectedButton'.
//
// # Scale(Variable(...))
//
// Specifies the name of a global variable to link to the scale.  Whenever the
// value of the variable changes, the scale will update to reflect this
// value.
// Whenever the scale is manipulated interactively, the variable
// will be modified to reflect the scale's new value.
//
// # TCheckbutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Defaults to the widget pathname if not specified.
//
// # TProgressbar(Variable(...))
//
// The name of a global Tcl variable which is linked to the '-value'.
// If specified to an existing variable, the '-value' of the progress bar is
// automatically set to the value of the variable whenever
// the latter is modified.
//
// # TRadiobutton(Variable(...))
//
// The name of a global variable whose value is linked to the widget.
// Default value is '::selectedButton'.
//
// # TScale(Variable(...))
//
// Specifies the name of a global variable to link to the scale. Whenever the
// value of the variable changes, the scale will update to reflect this value.
// Whenever the scale is manipulated interactively, the variable will be modified
// to reflect the scale's new value.
func Variable(value any) option {
	return variableOption{value}
}


// See also [Event handlers]
//
// # Entry(Vcmd(...))
//
// Specifies a script to eval when you want to validate the input into
// the entry widget.  Setting it to {} disables this feature (the default).
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then it means you reject the new edition
// and it will not occur and the '-invalidcommand' will be evaluated if it
// is set. If it returns 1, then the new edition occurs.
// See 'VALIDATION' below for more information.
//
// # Spinbox(Vcmd(...))
//
// Specifies a script to evaluate when you want to validate the input in the
// widget.  Setting it to an empty string disables this feature (the default).
// Validation occurs according to the value of '-validate'.
// This command must return a valid Tcl boolean value.  If it returns 0 (or
// the valid Tcl boolean equivalent) then the value of the widget will not
// change and the '-invalidcommand' will be evaluated if it is set.  If it
// returns 1, then value will be changed.
// See 'VALIDATION' below for more information.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Vcmd(args ...any) option {
	return newEventHandler("-vcmd", args...)
}

type visualOption struct { v any }

func (o visualOption) optionString(w *Window) string {
	return fmt.Sprintf(`-visual %s`, optionString(o.v))
}


// # Frame(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Labelframe(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the same
// visual as its parent.
// The '-visual' option may not be modified with the 'configure'
// widget command.
//
// # Toplevel(Visual(...))
//
// Specifies visual information for the new window in any of the
// forms accepted by 'Tk_GetVisual'.
// If this option is not specified, the new window will use the default
// visual for its screen.
// The '-visual' option may not be modified with the 'configure'
// widget command.
func Visual(value any) option {
	return visualOption{value}
}

type weightOption struct { v any }

func (o weightOption) optionString(w *Window) string {
	return fmt.Sprintf(`-weight %s`, optionString(o.v))
}


// # TPanedwindow(Weight(...))
//
// An integer specifying the relative stretchability of the pane.
// When the paned window is resized, the extra space is added
// or subtracted to each pane proportionally to its '-weight'.
func Weight(value any) option {
	return weightOption{value}
}

type widthOption struct { v any }

func (o widthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-width %s`, optionString(o.v))
}


// # Button(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For a text button (no image or with '-compound none') then the width
// specifies how much space in characters to allocate for the text label.
// If the width is negative then this specifies a minimum width.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Canvas(Width(...))
//
// Specifies a desired window width that the canvas widget should request from
// its geometry manager. The value may be specified in any
// of the forms described in the 'COORDINATES' section below.
//
// # Checkbutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Entry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Frame(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.  If this option is less than or equal
// to zero then the window will not request any size at all.  Note that this
// sets the total width of the frame, any '-borderwidth' or similar is
// not added.  Normally '-width' should not be used if a propagating
// geometry manager, such as 'grid' or 'pack', is used within the
// frame since the geometry manager will override the width of the frame.
//
// # Label(Width(...))
//
// Specifies a desired width for the label.
// If an image or bitmap is being displayed in the label then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the label's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Labelframe(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # Listbox(Width(...))
//
// Specifies the desired width for the window in characters.
// If the font does not have a uniform width then the width of the character
//
// # Menubutton(Width(...))
//
// Specifies a desired width for the menubutton.
// If an image or bitmap is being displayed in the menubutton then the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the menubutton's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Message(Width(...))
//
// Specifies the length of lines in the window.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
// If this option has a value greater than zero then the '-aspect'
// option is ignored and the '-width' option determines the line
// length.
// If this option has a value less than or equal to zero, then
// the '-aspect' option determines the line length.
//
// # Panedwindow(Width(...))
//
// Specifies a desired width for the overall panedwindow widget. May be any
// value accepted by 'Tk_GetPixels'. If an empty string, the widget will be
// made wide enough to allow all contained widgets to have their natural width.
//
// # Radiobutton(Width(...))
//
// Specifies a desired width for the button.
// If an image or bitmap is being displayed in the button, the value is in
// screen units (i.e. any of the forms acceptable to 'Tk_GetPixels');
// for text it is in characters.
// If this option is not specified, the button's desired width is computed
// from the size of the image or bitmap or text being displayed in it.
//
// # Scale(Width(...))
//
// Specifies the desired narrow dimension of the scale in screen units
// (i.e. any of the forms acceptable to 'Tk_GetPixels').
// For vertical scales this is the scale's width;  for horizontal scales
// this is the scale's height.
//
// # Scrollbar(Width(...))
//
// Specifies the desired narrow dimension of the scrollbar window,
// not including 3-D border, if any.  For vertical
// scrollbars this will be the width and for horizontal scrollbars
// this will be the height.
// The value may have any of the forms acceptable to 'Tk_GetPixels'.
//
// # Spinbox(Width(...))
//
// Specifies an integer value indicating the desired width of the spinbox window,
// in average-size characters of the widget's font.
// If the value is less than or equal to zero, the widget picks a
// size just large enough to hold its current text.
//
// # Text(Width(...))
//
// Specifies the desired width for the window in units of characters in the font
// given by the '-font' option. If the font does not have a uniform width
// then the width of the character
//
// # Toplevel(Width(...))
//
// Specifies the desired width for the window in any of the forms
// acceptable to 'Tk_GetPixels'.
// If this option is less than or equal to zero then the window will
// not request any size at all.
//
// # TCombobox(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # TEntry(Width(...))
//
// Specifies an integer value indicating the desired width of the entry window,
// in average-size characters of the widget's font.
//
// # TFrame(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TLabelframe(Width(...))
//
// If specified, the widget's requested width in pixels.
//
// # TNotebook(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the pane area
// (not including internal padding).
// Otherwise, the maximum width of all panes is used.
//
// # TPanedwindow(Width(...))
//
// If present and greater than zero,
// specifies the desired width of the widget in pixels.
// Otherwise, the requested width is determined by the width
// of the managed windows.
func Width(value any) option {
	return widthOption{value}
}

type wrapOption struct { v any }

func (o wrapOption) optionString(w *Window) string {
	return fmt.Sprintf(`-wrap %s`, optionString(o.v))
}


// # Spinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
//
// # Text(Wrap(...))
//
// Specifies how to handle lines in the text that are too long to be displayed in
// a single line of the text's window. The value must be 'none' or 'char'
// or 'word'. A wrap mode of 'none' means that each line of text appears
// as exactly one line on the screen; extra characters that do not fit on the
// screen are not displayed. In the other modes each line of text will be broken
// up into several screen lines if necessary to keep all the characters visible.
// In 'char' mode a screen line break may occur after any character; in
// 'word' mode a line break will only be made at word boundaries.
//
// # TSpinbox(Wrap(...))
//
// Must be a proper boolean value.  If on, the spinbox will wrap around the
// values of data in the widget.
func Wrap(value any) option {
	return wrapOption{value}
}

type wraplengthOption struct { v any }

func (o wraplengthOption) optionString(w *Window) string {
	return fmt.Sprintf(`-wraplength %s`, optionString(o.v))
}


// For widgets that can perform word-wrapping, this option specifies
// the maximum line length.
// Lines that would exceed this length are wrapped onto the next line,
// so that no line is longer than the specified length.
// The value may be specified in any of the standard forms for
// screen distances.
// If this value is less than or equal to 0 then no wrapping is done:  lines
// will break only at newline characters in the text.
//
// # TLabel(Wraplength(...))
//
// Specifies the maximum line length (in pixels).
// If this option is less than or equal to zero,
// then automatic wrapping is not performed; otherwise
// the text is split into lines such that no line is longer
// than the specified value.
func Wraplength(value any) option {
	return wraplengthOption{value}
}


// See also [Event handlers]
//
// Specifies the prefix for a command used to communicate with horizontal
// scrollbars.
// When the view in the widget's window changes (or
// whenever anything else occurs that could change the display in a
// scrollbar, such as a change in the total size of the widget's
// contents), the widget will
// generate a Tcl command by concatenating the scroll command and
// two numbers.
// Each of the numbers is a fraction between 0 and 1, which indicates
// a position in the document.  0 indicates the beginning of the document,
// 1 indicates the end, .333 indicates a position one third the way through
// the document, and so on.
// The first fraction indicates the first information in the document
// that is visible in the window, and the second fraction indicates
// the information just after the last portion that is visible.
// The command is
// then passed to the Tcl interpreter for execution.  Typically the
// '-xscrollcommand' option consists of the path name of a scrollbar
// widget followed by
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Xscrollcommand(args ...any) option {
	return newEventHandler("-xscrollcommand", args...)
}

type xscrollincrementOption struct { v any }

func (o xscrollincrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-xscrollincrement %s`, optionString(o.v))
}


// # Canvas(Xscrollincrement(...))
//
// Specifies an increment for horizontal scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the horizontal view in the window will be constrained so that
// the canvas x coordinate at the left edge of the window is always an even
// multiple of 'xScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the left and right arrows of a scrollbar
// are selected) will also be 'xScrollIncrement'. If the value of
// this option is less than or equal to zero, then horizontal scrolling
// is unconstrained.
func Xscrollincrement(value any) option {
	return xscrollincrementOption{value}
}


// See also [Event handlers]
//
// Specifies the prefix for a command used to communicate with vertical
// scrollbars.  This option is treated in the same way as the
// '-xscrollcommand' option, except that it is used for vertical
// scrollbars and is provided by widgets that support vertical scrolling.
// See the description of '-xscrollcommand' for details
// on how this option is used.
//
// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers
func Yscrollcommand(args ...any) option {
	return newEventHandler("-yscrollcommand", args...)
}

type yscrollincrementOption struct { v any }

func (o yscrollincrementOption) optionString(w *Window) string {
	return fmt.Sprintf(`-yscrollincrement %s`, optionString(o.v))
}


// # Canvas(Yscrollincrement(...))
//
// Specifies an increment for vertical scrolling, in any of the usual forms
// permitted for screen distances. If the value of this option is greater
// than zero, the vertical view in the window will be constrained so that
// the canvas y coordinate at the top edge of the window is always an even
// multiple of 'yScrollIncrement'; furthermore, the units for scrolling
// (e.g., the change in view when the top and bottom arrows of a scrollbar
// are selected) will also be 'yScrollIncrement'. If the value of
// this option is less than or equal to zero, then vertical scrolling
// is unconstrained.
func Yscrollincrement(value any) option {
	return yscrollincrementOption{value}
}

func Displayof(w *Window) option {
	return stringOption(fmt.Sprintf(`-displayof %ss`, w.path()))
}

func Nice() option {
	return stringOption(fmt.Sprintf(`-nice`))
}