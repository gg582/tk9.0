// Copyright 2024 The tk9.0-go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build none

package main

// import (
// 	"bytes"
// 	"encoding/json"
// 	"fmt"
// 	"io"
// 	"os"
// 	"slices"
// 	"strings"
//
// 	tklib "modernc.org/libtk9.0/library"
// )
//
// const (
// 	header = `// Code generated by generator.go, DO NOT EDIT.
//
// package tk9_0 // import "modernc.org/tk9.0"
//
// import (
// 	"fmt"
// )
//
// `
// )
//
// var (
// 	receivers = map[string]string{}
// )
//
// type document map[string]any
//
// func main() {
// 	var docs []document
// 	if err := json.Unmarshal([]byte(tklib.API), &docs); err != nil {
// 		panic(err)
// 	}
//
// 	generated("generated.go", docs)
// }
//
// type optionDocs struct {
// 	page string
// 	docs string
// }
//
// func generated(fn string, docs []document) {
// 	w := bytes.NewBuffer(nil)
// 	w.WriteString(header)
// 	if err := os.WriteFile(fn, w.Bytes(), 0660); err != nil {
// 		panic(err)
// 	}
//
// 	var pages []string
// 	m := map[string]document{}
// 	for _, v := range docs {
// 		nm := v["Page"].(string)
// 		pages = append(pages, nm)
// 		m[nm] = v
// 	}
// 	slices.Sort(pages)
//
// 	options := map[string][]*optionDocs{}
//
// 	for _, nm0 := range pages {
// 		doc := m[nm0]
// 		switch page := doc["Page"].(string); page {
// 		case "options":
// 			for _, v := range doc["Options"].([]any) {
// 				v := v.(map[string]any)
// 				onms := v["Name"].(string)
// 				docs := v["Docs"].(string)
// 				for _, onm := range optionNames(onms) {
// 					options[onm] = append(options[onm], &optionDocs{"", docs})
// 				}
// 			}
// 		case "ttk_widget":
// 			for _, v := range doc["Options"].([]any) {
// 				v := v.(map[string]any)
// 				onms := v["Name"].(string)
// 				docs := v["Docs"].(string)
// 				for _, onm := range optionNames(onms) {
// 					if _, ok := options[onm]; !ok {
// 						options[onm] = append(options[onm], &optionDocs{"", docs})
// 					}
// 				}
// 			}
// 		default:
// 			if opts := doc["Options"]; opts != nil {
// 				for _, v := range opts.([]any) {
// 					v := v.(map[string]any)
// 					onms := v["Name"].(string)
// 					var docs string
// 					if w := v["Docs"]; w != nil {
// 						docs = w.(string)
// 					}
// 					for _, onm := range optionNames(onms) {
// 						options[onm] = append(options[onm], &optionDocs{page, docs})
// 					}
// 				}
// 			}
// 			nm := tclName2GoName(nm0)
// 			isWindow := false
// 			if _, isWindow = doc["IsWindow"].(bool); isWindow {
// 				receivers[page] = "*Window"
// 				var description string
// 				var a []string
// 				switch x := doc["Options"].(type) {
// 				case []any:
// 					for _, v := range x {
// 						v := v.(map[string]any)
// 						if len(a) == 0 {
// 							a = append(a, "")
// 						}
// 						s := v["Name"].(string)
// 						b := strings.Fields(s)
// 						switch len(b) {
// 						case 3:
// 							a = append(a, "", fmt.Sprintf("# %s(%s(...))", nm, export(b[0][1:])), "")
// 						default:
// 							onms := optionNames(s)
// 							var c []string
// 							for _, onm := range onms {
// 								c = append(c, fmt.Sprintf("%s(%s(...))", nm, export(onm[1:])))
// 							}
// 							a = append(a, "", fmt.Sprintf("# %s", strings.Join(c, " or ")), "")
// 						}
// 						if w := v["Docs"]; w != nil {
// 							a = append(a, strings.Split(w.(string), "\n")...)
// 						}
// 					}
// 				}
// 				switch x := doc["Description"].(type) {
// 				case []any:
// 					if len(a) != 0 {
// 						a = append(a, "", "# Description")
// 					}
// 					for _, v := range x {
// 						if len(a) == 0 {
// 							a = append(a, "")
// 						}
// 						a = append(a, "")
// 						a = append(a, strings.Split(v.(string), "\n")...)
// 					}
// 				}
// 				description = strings.Join(a, "\n// ")
// 				fmt.Fprintf(w, "\n\n// %v", doc["Name"])
// 				fmt.Fprintf(w, "%s", description)
// 				fmt.Fprintf(w, "\n//\n// The resulting Window is a child of 'w'.")
// 				pageLink(w, page)
// 				fmt.Fprintf(w, "\nfunc (w *Window) %s(options ...option) *Window {", nm)
// 				fmt.Fprintf(w, "\n\treturn w.newChild(%q, options...)", nm0)
// 				fmt.Fprintf(w, "\n}")
//
// 				fmt.Fprintf(w, "\n\n// %v", doc["Name"])
// 				fmt.Fprintf(w, "%s", description)
// 				pageLink(w, page)
// 				fmt.Fprintf(w, "\nfunc %s(options ...option) *Window {", nm)
// 				fmt.Fprintf(w, "\n\treturn App.%s(options...)", nm)
// 				fmt.Fprintf(w, "\n}")
// 				if opts, ok := doc["Options"].([]any); ok {
// 					for _, v := range opts {
// 						v := v.(map[string]any)
// 						onms := v["Name"].(string)
// 						var docs string
// 						if w := v["Docs"]; w != nil {
// 							docs = w.(string)
// 						}
// 						for _, onm := range optionNames(onms) {
// 							options[onm] = append(options[onm], &optionDocs{page, docs})
// 						}
// 					}
// 				}
// 			}
//
// 			synops := doc["Synopsis"]
// 			methods := doc["Methods"]
// 			switch {
// 			case synops == nil && methods == nil:
// 				// nop
// 			case !isWindow && synops != nil && methods == nil:
// 				nonWinOnlySynops(w, doc)
// 			case synops != nil && methods != nil:
// 				synopsAndMethods(w, doc)
// 			case isWindow && synops != nil && methods == nil:
// 				winOnlySynops(w, doc)
// 			default:
// 				fmt.Printf("TODO rx=%s page=%s isWindow=%v synops=%v methods=%v\n", receivers[page], page, isWindow, synops != nil, methods != nil)
// 			}
// 		}
// 	}
// 	var onms []string
// 	for k := range options {
// 		onms = append(onms, k)
// 	}
// 	slices.Sort(onms)
// 	for _, onm := range onms {
// 		docsv := options[onm]
// 		slices.SortFunc(docsv, func(a, b *optionDocs) int { return strings.Compare(a.page, b.page) })
// 		option(w, onm, docsv)
// 	}
//
// 	moreOptions(w, optionsNeeded)
// 	moreMethods(w, methods)
//
// 	if err := os.WriteFile(fn, w.Bytes(), 0660); err != nil {
// 		panic(err)
// 	}
// }
//
// func optionNames(nm string) (r []string) {
// 	nm = strings.ReplaceAll(nm, `"`, "")
// 	r = strings.Fields(nm)
// 	x := 0
// 	for i, v := range r {
// 		if strings.HasPrefix(v, "-") && (i == 0 || r[i-1] == "or") {
// 			r[x] = v
// 			x++
// 		}
// 	}
// 	return r[:x]
// }
//
// var optionsGenerated = map[string]struct{}{} // Key = Go name.
//
// func option(w io.Writer, nm string, docsv []*optionDocs) {
// 	nm = strings.ReplaceAll(nm, `"`, "")
// 	a := optionNames(nm)
// 	for _, nm := range a {
// 		if nm == "--" {
// 			continue
// 		}
//
// 		nm = nm[1:] // remove leading '-'
// 		if !isCommand[nm] {
// 			fmt.Fprintf(w, "\n\ntype %sOption struct { v any }", nm)
// 			fmt.Fprintf(w, "\n\nfunc (o %sOption) optionString(w *Window) string {", nm)
// 			fmt.Fprintf(w, "\n\treturn fmt.Sprintf(`-%s %%s`, optionString(o.v))", nm)
// 			fmt.Fprintf(w, "\n}")
// 		}
// 		nm2 := nm
// 		if r := replaceOpt[nm]; r != "" {
// 			if r == "-" {
// 				continue
// 			}
//
// 			nm2 = r
// 		}
// 		fmt.Fprintf(w, "\n\n")
// 		if isCommand[nm] {
// 			fmt.Fprintf(w, "\n// See also [Event handlers]\n//")
// 		}
// 		for i, docs := range docsv {
// 			if docs.page != "" {
// 				if i != 0 {
// 					fmt.Fprintf(w, "\n//")
// 				}
// 				fmt.Fprintf(w, "\n// # %s(%s(...))\n//", tclName2GoName(docs.page), export(nm2))
// 			}
// 			d := strings.Split(strings.TrimSpace(docs.docs), "\n")
// 			fmt.Fprintf(w, "\n// %s", strings.Join(d, "\n// "))
// 		}
// 		enm := export(nm2)
// 		if _, ok := optionsGenerated[enm]; ok {
// 			panic(fmt.Sprintf("option %q already generated", enm))
// 		}
//
// 		optionsGenerated[enm] = struct{}{}
// 		switch {
// 		case isCommand[nm]:
// 			fmt.Fprintf(w, "\n//\n// [Event handlers]: https://pkg.go.dev/modernc.org/tk9.0#hdr-Event_handlers")
// 			fmt.Fprintf(w, "\nfunc %s(args ...any) option {", enm)
// 			fmt.Fprintf(w, "\n\treturn newEventHandler(%q, args...)", "-"+nm)
// 			fmt.Fprintf(w, "\n}")
// 		default:
// 			fmt.Fprintf(w, "\nfunc %s(value any) option {", enm)
// 			fmt.Fprintf(w, "\n\treturn %sOption{value}", nm)
// 			fmt.Fprintf(w, "\n}")
// 		}
// 	}
// }
//
// var isCommand = map[string]bool{
// 	"command":         true,
// 	"invalidcommand":  true,
// 	"invcmd":          true,
// 	"postcommand":     true,
// 	"tearoffcommand":  true,
// 	"textvariable":    true,
// 	"validatecommand": true,
// 	"vcmd":            true,
// 	"xscrollcommand":  true,
// 	"yscrollcommand":  true,
// }
//
// var replaceOpt = map[string]string{
// 	"button":  "btn",
// 	"label":   "lbl",
// 	"menu":    "mnu",
// 	"message": "msg",
// 	"text":    "txt",
// 	"window":  "-",
// }
//
// func tclName2GoName(s string) string {
// 	switch {
// 	case strings.HasPrefix(s, "ttk_"):
// 		return "T" + export(s[len("ttk_"):])
// 	default:
// 		return export(s)
// 	}
// }
//
// func export(s string) (r string) {
// 	a := strings.Split(s, "_")
// 	for i, v := range a {
// 		a[i] = strings.ToUpper(v[:1]) + v[1:]
// 	}
// 	return strings.Join(a, "")
// }
//
// type synTok struct {
// 	tok string
//
// 	variadic bool
// }
//
// func (s synTok) String() string {
// 	return fmt.Sprintf("%s%s", s.tok, vari(s.variadic))
// }
//
// func vari(b bool) string {
// 	if b {
// 		return "..."
// 	}
//
// 	return ""
// }
//
// type synOpt struct {
// 	opt []string
//
// 	variadic bool
// }
//
// func (s synOpt) String() string {
// 	return fmt.Sprintf("%s%s", s.opt, vari(s.variadic))
// }
//
// func parseSynopsisLine(line string) (r []any) {
// 	line = strings.TrimSpace(line)
// 	if line == "." {
// 		return nil
// 	}
// 	line = strings.ReplaceAll(line, "??", "")
// 	for {
// 		line = strings.TrimSpace(line)
// 		switch {
// 		case line == "":
// 			return r
// 		case line[0] == '?':
// 			x := strings.IndexByte(line[1:], '?')
// 			opt := synOpt{opt: strings.Fields(line[1 : x+1])}
// 			if n := len(opt.opt); opt.opt[n-1] == "..." {
// 				opt.opt = opt.opt[:n-1]
// 				opt.variadic = true
// 			}
// 			r = append(r, opt)
// 			line = line[x+2:]
// 		default:
// 			x := strings.IndexByte(line, ' ')
// 			switch {
// 			case x < 0:
// 				r = append(r, synTok{tok: line})
// 				return
// 			default:
// 				r = append(r, synTok{tok: line[:x]})
// 				line = line[x+1:]
// 			}
// 		}
// 	}
// }
//
// func nonWinOnlySynops(w io.Writer, doc document) {
// 	page := doc["Page"].(string)
// 	for _, v := range doc["Synopsis"].([]any) {
// 		syn := parseSynopsisLine(v.(string))
// 		switch page {
// 		case "bind": // Manual
// 			// nop
// 		case "bindtags": // Ignored, tkinter does not expose it either.
// 			// nop
// 		case "bell":
// 			command0(w, page, comment(doc["Name"], doc["Description"]), syn[0], winOpt{syn[1]}, syn[2])
// 		case "destroy":
// 			command0(w, page, comment(doc["Name"], doc["Description"]), syn[0], wins0Opt{})
// 		default:
// 			fmt.Printf("TODO nonWinOnlySynops: rx=%s page=%s non-win only synops=%v\n", receivers[page], page, syn)
// 		}
// 	}
// }
//
// func winOnlySynops(w io.Writer, doc document) {
// 	page := doc["Page"].(string)
// 	for _, v := range doc["Synopsis"].([]any) {
// 		syn := parseSynopsisLine(v.(string))
// 		fmt.Printf("TODO winOnlySynopsManual: rx=%s page=%s win only synops=%v\n", receivers[page], page, syn)
// 	}
// }
//
// func synopsAndMethods(w io.Writer, doc document) {
// 	page := doc["Page"].(string)
// 	for _, v := range doc["Synopsis"].([]any) {
// 		syn := parseSynopsisLine(v.(string))
// 		if len(syn) == 0 {
// 			break
// 		}
//
// 		syn0 := fmt.Sprint(syn[0])
// 		switch page {
// 		case "pack":
// 			command0(w, page, comment(doc["Name"], doc["Description"].([]any)[:1]), syn[0], wins0Opt{})
// 		case "bitmap", "photo":
// 			receivers[page] = "*Img"
// 			switch syn0 {
// 			case "image": // Manual
// 				// nop
// 			default:
// 				fmt.Printf("TODO synopsAndMethods: rx=%s page=%s synops=%v\n", receivers[page], page, syn)
// 			}
// 		default:
// 			fmt.Printf("TODO synopsAndMethods: rx=%s page=%s synops=%v\n", receivers[page], page, syn)
// 		}
// 		break
// 	}
// 	for _, v := range doc["Methods"].([]any) {
// 		m := v.(map[string]any)
// 		switch m["Name"] {
// 		case "cget":
// 			newMethod(page, v, methodCget, true)
// 		case "configure":
// 			newMethod(page, v, methodConfigure, true)
// 		default:
// 			fmt.Printf("TODO synopsAndMethods: rx=%s page=%s method=%v\n", receivers[page], page, m["Name"])
// 		}
// 	}
// }
//
// const (
// 	_ = iota
// 	methodCget
// 	methodConfigure
// )
//
// type method struct {
// 	page     string
// 	name     string
// 	synopsis string
// 	docs     []string
// 	typ      int
// }
//
// func newMethod(page string, v any, typ int, register bool) (r *method) {
//
// 	m := v.(map[string]any)
// 	if receivers[page] == "" {
// 		fmt.Printf("TODO rx= page=%s new method=%v\n", page, m["Name"])
// 		return
// 	}
//
// 	var a []string
// 	for _, v := range m["Docs"].([]any) {
// 		a = append(a, v.(string))
// 	}
// 	r = &method{
// 		page:     page,
// 		name:     m["Name"].(string),
// 		synopsis: m["Synopsis"].(string),
// 		docs:     a,
// 		typ:      typ,
// 	}
// 	if register {
// 		methods[r.name] = append(methods[r.name], r)
// 	}
// 	return r
// }
//
// var methods = map[string][]*method{} // method name: *method
//
// type winOpt struct {
// 	opt any
// }
//
// type wins0Opt struct{}
//
// func comment(descriptionShort, descriptionLong any) string {
// 	var a []string
// 	switch x := descriptionShort.(type) {
// 	case string:
// 		a = append(a, x)
// 	default:
// 		panic(fmt.Sprintf("%T", x))
// 	}
// 	switch x := descriptionLong.(type) {
// 	case []any:
// 		for _, v := range x {
// 			a = append(a, "")
// 			a = append(a, strings.Split(v.(string), "\n")...)
// 		}
// 	default:
// 		panic(fmt.Sprintf("%T", x))
// 	}
// 	if len(a) != 0 {
// 		return "// " + strings.Join(a, "\n// ")
// 	}
//
// 	return ""
// }
//
// func params(syns []any) (r []string) {
// 	opts := false
// 	for _, v := range syns {
// 		switch x := v.(type) {
// 		case winOpt, synOpt, wins0Opt:
// 			opts = true
// 		default:
// 			panic(fmt.Sprintf("%T", x))
// 		}
// 	}
// 	if opts {
// 		r = append(r, "options ...option")
// 	}
// 	return r
// }
//
// var optionsNeeded = map[string][]any{} // Key = Go name
//
// func registerOptions(syns []any) {
// 	for _, v := range syns {
// 		switch x := v.(type) {
// 		case winOpt:
// 			switch y := x.opt.(type) {
// 			case synOpt:
// 				enm := export(y.opt[0][1:])
// 				optionsNeeded[enm] = append(optionsNeeded[enm], x)
// 			default:
// 				panic(fmt.Sprintf("%T %v", y, y))
// 			}
// 		case wins0Opt:
// 			// nop
// 		case synOpt:
// 			enm := export(x.opt[0][1:])
// 			optionsNeeded[enm] = append(optionsNeeded[enm], x)
// 		default:
// 			panic(fmt.Sprintf("%T %v", x, x))
// 		}
// 	}
// }
//
// func command0(w io.Writer, page string, comment string, syns ...any) {
// 	fmt.Fprintf(w, "\n\n%s", comment)
// 	pageLink(w, page)
// 	params := params(syns[1:])
// 	registerOptions(syns[1:])
// 	fmt.Fprintf(w, "\nfunc %s(%s) {", export(fmt.Sprint(syns[0])), strings.Join(params, ", "))
// 	fmt.Fprintf(w, "\n\teval(fmt.Sprintf(`%s %%s`, collect(options...)))", syns[0])
// 	fmt.Fprintf(w, "\n}")
// }
//
// func pageLink(w io.Writer, page string) {
// 	if page == "" {
// 		return
// 	}
//
// 	fmt.Fprintf(w, "\n//\n// Additional information might be available at the [Tcl/Tk %s] page.", page)
// 	fmt.Fprintf(w, "\n//\n// [Tcl/Tk %s]: https://www.tcl.tk/man/tcl9.0/TkCmd/%[1]s.html ", page)
// }
//
// func moreOptions(w io.Writer, m map[string][]any) {
// 	var names []string
// 	for k := range m {
// 		names = append(names, k)
// 	}
// 	slices.Sort(names)
// 	for _, enm := range names {
// 		if _, ok := optionsGenerated[enm]; ok {
// 			continue
// 		}
//
// 		optionsGenerated[enm] = struct{}{}
// 		syn := m[enm][0]
// 		switch x := syn.(type) {
// 		case winOpt:
// 			switch y := x.opt.(type) {
// 			case synOpt:
// 				fmt.Fprintf(w, "\n\nfunc %s(w *Window) option {", enm)
// 				fmt.Fprintf(w, "\n\treturn stringOption(fmt.Sprintf(`%s %%s`, w.path()))", y.opt[0])
// 				fmt.Fprintf(w, "\n}")
// 			default:
// 				panic(fmt.Sprintf("%T %v", y, y))
// 			}
// 		case synOpt:
// 			switch len(x.opt) {
// 			case 1: // Boolean option
// 				fmt.Fprintf(w, "\n\nfunc %s() option {", enm)
// 				fmt.Fprintf(w, "\n\treturn stringOption(fmt.Sprintf(`%s`))", x.opt[0])
// 				fmt.Fprintf(w, "\n}")
// 			default:
// 				panic(fmt.Sprint(x))
// 			}
// 		default:
// 			// fmt.Fprintf(w, "\n\n//TODO func %s(...) {}", enm)
// 			panic(fmt.Sprintf("%T %v", x, x))
// 		}
// 	}
// }
//
// func moreMethods(w io.Writer, methods map[string][]*method) {
// 	var mnms []string
// 	ix := map[struct{ rx, page string }]*method{}
// 	for k, v := range methods {
// 		mnms = append(mnms, k)
// 		for _, m := range v {
// 			ix[struct{ rx, page string }{receivers[m.page], m.page}] = m
// 		}
// 	}
// 	slices.Sort(mnms)
// 	for _, mnm := range mnms {
// 		typ := -1
// 		var pages, rxs []string
// 		rxsm := map[string]struct{}{}
// 		for _, v := range methods[mnm] {
// 			pages = append(pages, v.page)
// 			rxsm[receivers[v.page]] = struct{}{}
// 			switch t := v.typ; {
// 			case typ < 0:
// 				typ = t
// 			default:
// 				if t != typ {
// 					panic(fmt.Sprint(typ, t))
// 				}
// 			}
// 		}
// 		slices.Sort(pages)
// 		for k := range rxsm {
// 			rxs = append(rxs, k)
// 		}
// 		slices.Sort(rxs)
// 		rx2page := map[string][]string{}
// 		for _, page := range pages {
// 			rx := receivers[page]
// 			rx2page[rx] = append(rx2page[rx], page)
// 		}
// 		for _, rx := range rxs {
// 			var docs []string
// 			for _, page := range rx2page[rx] {
// 				m := ix[struct{ rx, page string }{receivers[page], page}]
// 				docs = append(docs, "", fmt.Sprintf("# %s.%s(...)", page, export(mnm)), "")
// 				docs = append(docs, m.docs...)
// 			}
// 			fmt.Fprintf(w, "\n\n// %s", strings.Join(docs, "\n// "))
// 			switch typ {
// 			case methodCget:
// 				fmt.Fprintf(w, "\nfunc(rx %s) %s(opt func(any) option) any {", rx, export(mnm))
// 				fmt.Fprintf(w, "\n\treturn evalAny(fmt.Sprintf(`%%s %s %%s`, rx.optionString(nil), collect0(opt)))", mnm)
// 				fmt.Fprintf(w, "\n}")
// 			case methodConfigure:
// 				fmt.Fprintf(w, "\nfunc(rx %s) %s(options ...option) any {", rx, export(mnm))
// 				fmt.Fprintf(w, "\n\treturn evalAny(fmt.Sprintf(`%%s %s %%s`, rx.optionString(nil), collect(options...)))", mnm)
// 				fmt.Fprintf(w, "\n}")
// 			default:
// 				fmt.Printf("TODO method=%s typ=%v pages=%v rx=%q\n", mnm, typ, rx2page[rx], rx)
// 			}
// 		}
// 	}
// }
